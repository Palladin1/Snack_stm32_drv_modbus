   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.xQueueGenericCreate,"ax",%progbits
  19              		.align	2
  20              		.global	xQueueGenericCreate
  21              		.thumb
  22              		.thumb_func
  24              	xQueueGenericCreate:
  25              	.LFB0:
  26              		.file 1 "../FreeRTOS_Source/queue.c"
   1:../FreeRTOS_Source/queue.c **** /*
   2:../FreeRTOS_Source/queue.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS_Source/queue.c **** 
   4:../FreeRTOS_Source/queue.c **** 
   5:../FreeRTOS_Source/queue.c ****     ***************************************************************************
   6:../FreeRTOS_Source/queue.c ****      *                                                                       *
   7:../FreeRTOS_Source/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS_Source/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS_Source/queue.c ****      *    available.                                                         *
  10:../FreeRTOS_Source/queue.c ****      *                                                                       *
  11:../FreeRTOS_Source/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS_Source/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS_Source/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS_Source/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS_Source/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS_Source/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS_Source/queue.c ****      *                                                                       *
  18:../FreeRTOS_Source/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS_Source/queue.c ****      *                                                                       *
  20:../FreeRTOS_Source/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS_Source/queue.c ****      *                                                                       *
  22:../FreeRTOS_Source/queue.c ****     ***************************************************************************
  23:../FreeRTOS_Source/queue.c **** 
  24:../FreeRTOS_Source/queue.c **** 
  25:../FreeRTOS_Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS_Source/queue.c **** 
  27:../FreeRTOS_Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS_Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS_Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS_Source/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS_Source/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS_Source/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS_Source/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS_Source/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS_Source/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS_Source/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS_Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS_Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS_Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS_Source/queue.c ****     FreeRTOS WEB site.
  41:../FreeRTOS_Source/queue.c **** 
  42:../FreeRTOS_Source/queue.c ****     1 tab == 4 spaces!
  43:../FreeRTOS_Source/queue.c **** 
  44:../FreeRTOS_Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS_Source/queue.c ****     contact details.
  46:../FreeRTOS_Source/queue.c **** 
  47:../FreeRTOS_Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS_Source/queue.c ****     critical systems.
  49:../FreeRTOS_Source/queue.c **** 
  50:../FreeRTOS_Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS_Source/queue.c ****     licensing and training services.
  52:../FreeRTOS_Source/queue.c **** */
  53:../FreeRTOS_Source/queue.c **** 
  54:../FreeRTOS_Source/queue.c **** #include <stdlib.h>
  55:../FreeRTOS_Source/queue.c **** #include <string.h>
  56:../FreeRTOS_Source/queue.c **** 
  57:../FreeRTOS_Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../FreeRTOS_Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../FreeRTOS_Source/queue.c **** task.h is included from an application file. */
  60:../FreeRTOS_Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../FreeRTOS_Source/queue.c **** 
  62:../FreeRTOS_Source/queue.c **** #include "FreeRTOS.h"
  63:../FreeRTOS_Source/queue.c **** #include "task.h"
  64:../FreeRTOS_Source/queue.c **** 
  65:../FreeRTOS_Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:../FreeRTOS_Source/queue.c **** 	#include "croutine.h"
  67:../FreeRTOS_Source/queue.c **** #endif
  68:../FreeRTOS_Source/queue.c **** 
  69:../FreeRTOS_Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS_Source/queue.c **** 
  71:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------
  72:../FreeRTOS_Source/queue.c ****  * PUBLIC LIST API documented in list.h
  73:../FreeRTOS_Source/queue.c ****  *----------------------------------------------------------*/
  74:../FreeRTOS_Source/queue.c **** 
  75:../FreeRTOS_Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:../FreeRTOS_Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:../FreeRTOS_Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:../FreeRTOS_Source/queue.c **** 
  79:../FreeRTOS_Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:../FreeRTOS_Source/queue.c **** 
  81:../FreeRTOS_Source/queue.c **** /* For internal use only. */
  82:../FreeRTOS_Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:../FreeRTOS_Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:../FreeRTOS_Source/queue.c **** 
  85:../FreeRTOS_Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:../FreeRTOS_Source/queue.c **** #define pxMutexHolder					pcTail
  87:../FreeRTOS_Source/queue.c **** #define uxQueueType						pcHead
  88:../FreeRTOS_Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:../FreeRTOS_Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:../FreeRTOS_Source/queue.c **** 
  91:../FreeRTOS_Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:../FreeRTOS_Source/queue.c **** zero. */
  93:../FreeRTOS_Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:../FreeRTOS_Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:../FreeRTOS_Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:../FreeRTOS_Source/queue.c **** 
  97:../FreeRTOS_Source/queue.c **** /* These definitions *must* match those in queue.h. */
  98:../FreeRTOS_Source/queue.c **** #define queueQUEUE_TYPE_BASE				( 0U )
  99:../FreeRTOS_Source/queue.c **** #define queueQUEUE_TYPE_MUTEX 				( 1U )
 100:../FreeRTOS_Source/queue.c **** #define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
 101:../FreeRTOS_Source/queue.c **** #define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
 102:../FreeRTOS_Source/queue.c **** #define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
 103:../FreeRTOS_Source/queue.c **** 
 104:../FreeRTOS_Source/queue.c **** /*
 105:../FreeRTOS_Source/queue.c ****  * Definition of the queue used by the scheduler.
 106:../FreeRTOS_Source/queue.c ****  * Items are queued by copy, not reference.
 107:../FreeRTOS_Source/queue.c ****  */
 108:../FreeRTOS_Source/queue.c **** typedef struct QueueDefinition
 109:../FreeRTOS_Source/queue.c **** {
 110:../FreeRTOS_Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 111:../FreeRTOS_Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 112:../FreeRTOS_Source/queue.c **** 
 113:../FreeRTOS_Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 114:../FreeRTOS_Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 115:../FreeRTOS_Source/queue.c **** 
 116:../FreeRTOS_Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 117:../FreeRTOS_Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 118:../FreeRTOS_Source/queue.c **** 
 119:../FreeRTOS_Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 120:../FreeRTOS_Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 121:../FreeRTOS_Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 122:../FreeRTOS_Source/queue.c **** 
 123:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 124:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 125:../FreeRTOS_Source/queue.c **** 	
 126:../FreeRTOS_Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../FreeRTOS_Source/queue.c **** 		unsigned char ucQueueNumber;
 128:../FreeRTOS_Source/queue.c **** 		unsigned char ucQueueType;
 129:../FreeRTOS_Source/queue.c **** 	#endif
 130:../FreeRTOS_Source/queue.c **** 
 131:../FreeRTOS_Source/queue.c **** } xQUEUE;
 132:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 133:../FreeRTOS_Source/queue.c **** 
 134:../FreeRTOS_Source/queue.c **** /*
 135:../FreeRTOS_Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 136:../FreeRTOS_Source/queue.c ****  * To keep the definition private the API header file defines it as a
 137:../FreeRTOS_Source/queue.c ****  * pointer to void.
 138:../FreeRTOS_Source/queue.c ****  */
 139:../FreeRTOS_Source/queue.c **** typedef xQUEUE * xQueueHandle;
 140:../FreeRTOS_Source/queue.c **** 
 141:../FreeRTOS_Source/queue.c **** /*
 142:../FreeRTOS_Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 143:../FreeRTOS_Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 144:../FreeRTOS_Source/queue.c ****  * functions are documented in the API header file.
 145:../FreeRTOS_Source/queue.c ****  */
 146:../FreeRTOS_Source/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 147:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 148:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:../FreeRTOS_Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 150:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 151:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 152:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 153:../FreeRTOS_Source/queue.c **** xQueueHandle xQueueCreateMutex( unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
 154:../FreeRTOS_Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 155:../FreeRTOS_Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 156:../FreeRTOS_Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 157:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 158:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 159:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 160:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 161:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 162:../FreeRTOS_Source/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 163:../FreeRTOS_Source/queue.c **** unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 164:../FreeRTOS_Source/queue.c **** void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
 165:../FreeRTOS_Source/queue.c **** unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 166:../FreeRTOS_Source/queue.c **** 
 167:../FreeRTOS_Source/queue.c **** /*
 168:../FreeRTOS_Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 169:../FreeRTOS_Source/queue.c ****  * an optional component.
 170:../FreeRTOS_Source/queue.c ****  */
 171:../FreeRTOS_Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 172:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 173:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 174:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 175:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 176:../FreeRTOS_Source/queue.c **** #endif
 177:../FreeRTOS_Source/queue.c **** 
 178:../FreeRTOS_Source/queue.c **** /*
 179:../FreeRTOS_Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 180:../FreeRTOS_Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 181:../FreeRTOS_Source/queue.c ****  */
 182:../FreeRTOS_Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 183:../FreeRTOS_Source/queue.c **** 
 184:../FreeRTOS_Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 185:../FreeRTOS_Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 186:../FreeRTOS_Source/queue.c **** 	more user friendly. */
 187:../FreeRTOS_Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 188:../FreeRTOS_Source/queue.c **** 	{
 189:../FreeRTOS_Source/queue.c **** 		signed char *pcQueueName;
 190:../FreeRTOS_Source/queue.c **** 		xQueueHandle xHandle;
 191:../FreeRTOS_Source/queue.c **** 	} xQueueRegistryItem;
 192:../FreeRTOS_Source/queue.c **** 
 193:../FreeRTOS_Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 194:../FreeRTOS_Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:../FreeRTOS_Source/queue.c **** 	array position being vacant. */
 196:../FreeRTOS_Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:../FreeRTOS_Source/queue.c **** 
 198:../FreeRTOS_Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 199:../FreeRTOS_Source/queue.c **** 	member to NULL. */
 200:../FreeRTOS_Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 201:../FreeRTOS_Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 202:../FreeRTOS_Source/queue.c **** #endif
 203:../FreeRTOS_Source/queue.c **** 
 204:../FreeRTOS_Source/queue.c **** /*
 205:../FreeRTOS_Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 206:../FreeRTOS_Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 207:../FreeRTOS_Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 208:../FreeRTOS_Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 209:../FreeRTOS_Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 210:../FreeRTOS_Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 211:../FreeRTOS_Source/queue.c ****  */
 212:../FreeRTOS_Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 213:../FreeRTOS_Source/queue.c **** 
 214:../FreeRTOS_Source/queue.c **** /*
 215:../FreeRTOS_Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 216:../FreeRTOS_Source/queue.c ****  *
 217:../FreeRTOS_Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 218:../FreeRTOS_Source/queue.c ****  */
 219:../FreeRTOS_Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 220:../FreeRTOS_Source/queue.c **** 
 221:../FreeRTOS_Source/queue.c **** /*
 222:../FreeRTOS_Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 223:../FreeRTOS_Source/queue.c ****  *
 224:../FreeRTOS_Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 225:../FreeRTOS_Source/queue.c ****  */
 226:../FreeRTOS_Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 227:../FreeRTOS_Source/queue.c **** 
 228:../FreeRTOS_Source/queue.c **** /*
 229:../FreeRTOS_Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 230:../FreeRTOS_Source/queue.c ****  * back of the queue.
 231:../FreeRTOS_Source/queue.c ****  */
 232:../FreeRTOS_Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 233:../FreeRTOS_Source/queue.c **** 
 234:../FreeRTOS_Source/queue.c **** /*
 235:../FreeRTOS_Source/queue.c ****  * Copies an item out of a queue.
 236:../FreeRTOS_Source/queue.c ****  */
 237:../FreeRTOS_Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 238:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 239:../FreeRTOS_Source/queue.c **** 
 240:../FreeRTOS_Source/queue.c **** /*
 241:../FreeRTOS_Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 242:../FreeRTOS_Source/queue.c ****  * accessing the queue event lists.
 243:../FreeRTOS_Source/queue.c ****  */
 244:../FreeRTOS_Source/queue.c **** #define prvLockQueue( pxQueue )								\
 245:../FreeRTOS_Source/queue.c **** 	taskENTER_CRITICAL();									\
 246:../FreeRTOS_Source/queue.c **** 	{														\
 247:../FreeRTOS_Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 248:../FreeRTOS_Source/queue.c **** 		{													\
 249:../FreeRTOS_Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 250:../FreeRTOS_Source/queue.c **** 		}													\
 251:../FreeRTOS_Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 252:../FreeRTOS_Source/queue.c **** 		{													\
 253:../FreeRTOS_Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 254:../FreeRTOS_Source/queue.c **** 		}													\
 255:../FreeRTOS_Source/queue.c **** 	}														\
 256:../FreeRTOS_Source/queue.c **** 	taskEXIT_CRITICAL()
 257:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 258:../FreeRTOS_Source/queue.c **** 
 259:../FreeRTOS_Source/queue.c **** 
 260:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------
 261:../FreeRTOS_Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 262:../FreeRTOS_Source/queue.c ****  *----------------------------------------------------------*/
 263:../FreeRTOS_Source/queue.c **** 
 264:../FreeRTOS_Source/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 265:../FreeRTOS_Source/queue.c **** {
  27              		.loc 1 265 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 32
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 14, -4
  35              		.cfi_offset 7, -8
  36 0002 88B0     		sub	sp, sp, #32
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 40
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 F860     		str	r0, [r7, #12]
  43 0008 B960     		str	r1, [r7, #8]
  44 000a 1346     		mov	r3, r2
  45 000c FB71     		strb	r3, [r7, #7]
 266:../FreeRTOS_Source/queue.c **** xQUEUE *pxNewQueue;
 267:../FreeRTOS_Source/queue.c **** size_t xQueueSizeInBytes;
 268:../FreeRTOS_Source/queue.c **** xQueueHandle xReturn = NULL;
  46              		.loc 1 268 0
  47 000e 4FF00003 		mov	r3, #0
  48 0012 FB61     		str	r3, [r7, #28]
 269:../FreeRTOS_Source/queue.c **** 
 270:../FreeRTOS_Source/queue.c **** 	/* Remove compiler warnings about unused parameters should 
 271:../FreeRTOS_Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 272:../FreeRTOS_Source/queue.c **** 	( void ) ucQueueType;
 273:../FreeRTOS_Source/queue.c **** 
 274:../FreeRTOS_Source/queue.c **** 	/* Allocate the new queue structure. */
 275:../FreeRTOS_Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  49              		.loc 1 275 0
  50 0014 FB68     		ldr	r3, [r7, #12]
  51 0016 002B     		cmp	r3, #0
  52 0018 54D0     		beq	.L2
 276:../FreeRTOS_Source/queue.c **** 	{
 277:../FreeRTOS_Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  53              		.loc 1 277 0
  54 001a 4FF04C00 		mov	r0, #76
  55 001e FFF7FEFF 		bl	pvPortMalloc
  56 0022 B861     		str	r0, [r7, #24]
 278:../FreeRTOS_Source/queue.c **** 		if( pxNewQueue != NULL )
  57              		.loc 1 278 0
  58 0024 BB69     		ldr	r3, [r7, #24]
  59 0026 002B     		cmp	r3, #0
  60 0028 4CD0     		beq	.L2
 279:../FreeRTOS_Source/queue.c **** 		{
 280:../FreeRTOS_Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 281:../FreeRTOS_Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 282:../FreeRTOS_Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  61              		.loc 1 282 0
  62 002a FB68     		ldr	r3, [r7, #12]
  63 002c BA68     		ldr	r2, [r7, #8]
  64 002e 02FB03F3 		mul	r3, r2, r3
  65 0032 03F10103 		add	r3, r3, #1
  66 0036 7B61     		str	r3, [r7, #20]
 283:../FreeRTOS_Source/queue.c **** 
 284:../FreeRTOS_Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  67              		.loc 1 284 0
  68 0038 7869     		ldr	r0, [r7, #20]
  69 003a FFF7FEFF 		bl	pvPortMalloc
  70 003e 0246     		mov	r2, r0
  71 0040 BB69     		ldr	r3, [r7, #24]
  72 0042 1A60     		str	r2, [r3, #0]
 285:../FreeRTOS_Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
  73              		.loc 1 285 0
  74 0044 BB69     		ldr	r3, [r7, #24]
  75 0046 1B68     		ldr	r3, [r3, #0]
  76 0048 002B     		cmp	r3, #0
  77 004a 38D0     		beq	.L3
 286:../FreeRTOS_Source/queue.c **** 			{
 287:../FreeRTOS_Source/queue.c **** 				/* Initialise the queue members as described above where the
 288:../FreeRTOS_Source/queue.c **** 				queue type is defined. */
 289:../FreeRTOS_Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  78              		.loc 1 289 0
  79 004c BB69     		ldr	r3, [r7, #24]
  80 004e 1A68     		ldr	r2, [r3, #0]
  81 0050 FB68     		ldr	r3, [r7, #12]
  82 0052 B968     		ldr	r1, [r7, #8]
  83 0054 01FB03F3 		mul	r3, r1, r3
  84 0058 D218     		adds	r2, r2, r3
  85 005a BB69     		ldr	r3, [r7, #24]
  86 005c 5A60     		str	r2, [r3, #4]
 290:../FreeRTOS_Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  87              		.loc 1 290 0
  88 005e BB69     		ldr	r3, [r7, #24]
  89 0060 4FF00002 		mov	r2, #0
  90 0064 9A63     		str	r2, [r3, #56]
 291:../FreeRTOS_Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
  91              		.loc 1 291 0
  92 0066 BB69     		ldr	r3, [r7, #24]
  93 0068 1A68     		ldr	r2, [r3, #0]
  94 006a BB69     		ldr	r3, [r7, #24]
  95 006c 9A60     		str	r2, [r3, #8]
 292:../FreeRTOS_Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
  96              		.loc 1 292 0
  97 006e BB69     		ldr	r3, [r7, #24]
  98 0070 1A68     		ldr	r2, [r3, #0]
  99 0072 FB68     		ldr	r3, [r7, #12]
 100 0074 03F1FF33 		add	r3, r3, #-1
 101 0078 B968     		ldr	r1, [r7, #8]
 102 007a 01FB03F3 		mul	r3, r1, r3
 103 007e D218     		adds	r2, r2, r3
 104 0080 BB69     		ldr	r3, [r7, #24]
 105 0082 DA60     		str	r2, [r3, #12]
 293:../FreeRTOS_Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 106              		.loc 1 293 0
 107 0084 BB69     		ldr	r3, [r7, #24]
 108 0086 FA68     		ldr	r2, [r7, #12]
 109 0088 DA63     		str	r2, [r3, #60]
 294:../FreeRTOS_Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 110              		.loc 1 294 0
 111 008a BB69     		ldr	r3, [r7, #24]
 112 008c BA68     		ldr	r2, [r7, #8]
 113 008e 1A64     		str	r2, [r3, #64]
 295:../FreeRTOS_Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 114              		.loc 1 295 0
 115 0090 BB69     		ldr	r3, [r7, #24]
 116 0092 4FF0FF32 		mov	r2, #-1
 117 0096 5A64     		str	r2, [r3, #68]
 296:../FreeRTOS_Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 118              		.loc 1 296 0
 119 0098 BB69     		ldr	r3, [r7, #24]
 120 009a 4FF0FF32 		mov	r2, #-1
 121 009e 9A64     		str	r2, [r3, #72]
 297:../FreeRTOS_Source/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 298:../FreeRTOS_Source/queue.c **** 				{
 299:../FreeRTOS_Source/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 300:../FreeRTOS_Source/queue.c **** 				}
 301:../FreeRTOS_Source/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 302:../FreeRTOS_Source/queue.c **** 
 303:../FreeRTOS_Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 304:../FreeRTOS_Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 122              		.loc 1 304 0
 123 00a0 BB69     		ldr	r3, [r7, #24]
 124 00a2 03F11003 		add	r3, r3, #16
 125 00a6 1846     		mov	r0, r3
 126 00a8 FFF7FEFF 		bl	vListInitialise
 305:../FreeRTOS_Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 127              		.loc 1 305 0
 128 00ac BB69     		ldr	r3, [r7, #24]
 129 00ae 03F12403 		add	r3, r3, #36
 130 00b2 1846     		mov	r0, r3
 131 00b4 FFF7FEFF 		bl	vListInitialise
 306:../FreeRTOS_Source/queue.c **** 
 307:../FreeRTOS_Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 308:../FreeRTOS_Source/queue.c **** 				xReturn = pxNewQueue;
 132              		.loc 1 308 0
 133 00b8 BB69     		ldr	r3, [r7, #24]
 134 00ba FB61     		str	r3, [r7, #28]
 135 00bc 02E0     		b	.L2
 136              	.L3:
 309:../FreeRTOS_Source/queue.c **** 			}
 310:../FreeRTOS_Source/queue.c **** 			else
 311:../FreeRTOS_Source/queue.c **** 			{
 312:../FreeRTOS_Source/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 313:../FreeRTOS_Source/queue.c **** 				vPortFree( pxNewQueue );
 137              		.loc 1 313 0
 138 00be B869     		ldr	r0, [r7, #24]
 139 00c0 FFF7FEFF 		bl	vPortFree
 140              	.L2:
 314:../FreeRTOS_Source/queue.c **** 			}
 315:../FreeRTOS_Source/queue.c **** 		}
 316:../FreeRTOS_Source/queue.c **** 	}
 317:../FreeRTOS_Source/queue.c **** 
 318:../FreeRTOS_Source/queue.c **** 	configASSERT( xReturn );
 141              		.loc 1 318 0
 142 00c4 FB69     		ldr	r3, [r7, #28]
 143 00c6 002B     		cmp	r3, #0
 144 00c8 04D1     		bne	.L4
 145              		.loc 1 318 0 is_stmt 0 discriminator 1
 146              	@ 318 "../FreeRTOS_Source/queue.c" 1
 147 00ca 4FF05000 			mov r0, #80								
 148 00ce 80F31188 		msr basepri, r0							
 149              	
 150              	@ 0 "" 2
 151              		.thumb
 152              	.L5:
 153              		.loc 1 318 0 discriminator 2
 154 00d2 FEE7     		b	.L5
 155              	.L4:
 319:../FreeRTOS_Source/queue.c **** 
 320:../FreeRTOS_Source/queue.c **** 	return xReturn;
 156              		.loc 1 320 0 is_stmt 1
 157 00d4 FB69     		ldr	r3, [r7, #28]
 321:../FreeRTOS_Source/queue.c **** }
 158              		.loc 1 321 0
 159 00d6 1846     		mov	r0, r3
 160 00d8 07F12007 		add	r7, r7, #32
 161 00dc BD46     		mov	sp, r7
 162 00de 80BD     		pop	{r7, pc}
 163              		.cfi_endproc
 164              	.LFE0:
 166              		.section	.text.xQueueCreateMutex,"ax",%progbits
 167              		.align	2
 168              		.global	xQueueCreateMutex
 169              		.thumb
 170              		.thumb_func
 172              	xQueueCreateMutex:
 173              	.LFB1:
 322:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 323:../FreeRTOS_Source/queue.c **** 
 324:../FreeRTOS_Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 325:../FreeRTOS_Source/queue.c **** 
 326:../FreeRTOS_Source/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 327:../FreeRTOS_Source/queue.c **** 	{
 174              		.loc 1 327 0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 16
 177              		@ frame_needed = 1, uses_anonymous_args = 0
 178 0000 80B5     		push	{r7, lr}
 179              	.LCFI3:
 180              		.cfi_def_cfa_offset 8
 181              		.cfi_offset 14, -4
 182              		.cfi_offset 7, -8
 183 0002 84B0     		sub	sp, sp, #16
 184              	.LCFI4:
 185              		.cfi_def_cfa_offset 24
 186 0004 00AF     		add	r7, sp, #0
 187              	.LCFI5:
 188              		.cfi_def_cfa_register 7
 189 0006 0346     		mov	r3, r0
 190 0008 FB71     		strb	r3, [r7, #7]
 328:../FreeRTOS_Source/queue.c **** 	xQUEUE *pxNewQueue;
 329:../FreeRTOS_Source/queue.c **** 
 330:../FreeRTOS_Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 331:../FreeRTOS_Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 332:../FreeRTOS_Source/queue.c **** 		( void ) ucQueueType;
 333:../FreeRTOS_Source/queue.c **** 	
 334:../FreeRTOS_Source/queue.c **** 		/* Allocate the new queue structure. */
 335:../FreeRTOS_Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 191              		.loc 1 335 0
 192 000a 4FF04C00 		mov	r0, #76
 193 000e FFF7FEFF 		bl	pvPortMalloc
 194 0012 F860     		str	r0, [r7, #12]
 336:../FreeRTOS_Source/queue.c **** 		if( pxNewQueue != NULL )
 195              		.loc 1 336 0
 196 0014 FB68     		ldr	r3, [r7, #12]
 197 0016 002B     		cmp	r3, #0
 198 0018 38D0     		beq	.L7
 337:../FreeRTOS_Source/queue.c **** 		{
 338:../FreeRTOS_Source/queue.c **** 			/* Information required for priority inheritance. */
 339:../FreeRTOS_Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 199              		.loc 1 339 0
 200 001a FB68     		ldr	r3, [r7, #12]
 201 001c 4FF00002 		mov	r2, #0
 202 0020 5A60     		str	r2, [r3, #4]
 340:../FreeRTOS_Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 203              		.loc 1 340 0
 204 0022 FB68     		ldr	r3, [r7, #12]
 205 0024 4FF00002 		mov	r2, #0
 206 0028 1A60     		str	r2, [r3, #0]
 341:../FreeRTOS_Source/queue.c **** 
 342:../FreeRTOS_Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 343:../FreeRTOS_Source/queue.c **** 			of the queue. */
 344:../FreeRTOS_Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 207              		.loc 1 344 0
 208 002a FB68     		ldr	r3, [r7, #12]
 209 002c 4FF00002 		mov	r2, #0
 210 0030 9A60     		str	r2, [r3, #8]
 345:../FreeRTOS_Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 211              		.loc 1 345 0
 212 0032 FB68     		ldr	r3, [r7, #12]
 213 0034 4FF00002 		mov	r2, #0
 214 0038 DA60     		str	r2, [r3, #12]
 346:../FreeRTOS_Source/queue.c **** 
 347:../FreeRTOS_Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 348:../FreeRTOS_Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 349:../FreeRTOS_Source/queue.c **** 			of the mutex. */
 350:../FreeRTOS_Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 215              		.loc 1 350 0
 216 003a FB68     		ldr	r3, [r7, #12]
 217 003c 4FF00002 		mov	r2, #0
 218 0040 9A63     		str	r2, [r3, #56]
 351:../FreeRTOS_Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 219              		.loc 1 351 0
 220 0042 FB68     		ldr	r3, [r7, #12]
 221 0044 4FF00102 		mov	r2, #1
 222 0048 DA63     		str	r2, [r3, #60]
 352:../FreeRTOS_Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 223              		.loc 1 352 0
 224 004a FB68     		ldr	r3, [r7, #12]
 225 004c 4FF00002 		mov	r2, #0
 226 0050 1A64     		str	r2, [r3, #64]
 353:../FreeRTOS_Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 227              		.loc 1 353 0
 228 0052 FB68     		ldr	r3, [r7, #12]
 229 0054 4FF0FF32 		mov	r2, #-1
 230 0058 5A64     		str	r2, [r3, #68]
 354:../FreeRTOS_Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 231              		.loc 1 354 0
 232 005a FB68     		ldr	r3, [r7, #12]
 233 005c 4FF0FF32 		mov	r2, #-1
 234 0060 9A64     		str	r2, [r3, #72]
 355:../FreeRTOS_Source/queue.c **** 			
 356:../FreeRTOS_Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 357:../FreeRTOS_Source/queue.c **** 			{
 358:../FreeRTOS_Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 359:../FreeRTOS_Source/queue.c **** 			}
 360:../FreeRTOS_Source/queue.c **** 			#endif
 361:../FreeRTOS_Source/queue.c **** 
 362:../FreeRTOS_Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 363:../FreeRTOS_Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 235              		.loc 1 363 0
 236 0062 FB68     		ldr	r3, [r7, #12]
 237 0064 03F11003 		add	r3, r3, #16
 238 0068 1846     		mov	r0, r3
 239 006a FFF7FEFF 		bl	vListInitialise
 364:../FreeRTOS_Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 240              		.loc 1 364 0
 241 006e FB68     		ldr	r3, [r7, #12]
 242 0070 03F12403 		add	r3, r3, #36
 243 0074 1846     		mov	r0, r3
 244 0076 FFF7FEFF 		bl	vListInitialise
 365:../FreeRTOS_Source/queue.c **** 
 366:../FreeRTOS_Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 367:../FreeRTOS_Source/queue.c **** 
 368:../FreeRTOS_Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 369:../FreeRTOS_Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 245              		.loc 1 369 0
 246 007a F868     		ldr	r0, [r7, #12]
 247 007c 4FF00001 		mov	r1, #0
 248 0080 4FF00002 		mov	r2, #0
 249 0084 4FF00003 		mov	r3, #0
 250 0088 FFF7FEFF 		bl	xQueueGenericSend
 251              	.L7:
 370:../FreeRTOS_Source/queue.c **** 		}
 371:../FreeRTOS_Source/queue.c **** 		else
 372:../FreeRTOS_Source/queue.c **** 		{
 373:../FreeRTOS_Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 374:../FreeRTOS_Source/queue.c **** 		}
 375:../FreeRTOS_Source/queue.c **** 
 376:../FreeRTOS_Source/queue.c **** 		configASSERT( pxNewQueue );
 252              		.loc 1 376 0
 253 008c FB68     		ldr	r3, [r7, #12]
 254 008e 002B     		cmp	r3, #0
 255 0090 04D1     		bne	.L8
 256              		.loc 1 376 0 is_stmt 0 discriminator 1
 257              	@ 376 "../FreeRTOS_Source/queue.c" 1
 258 0092 4FF05000 			mov r0, #80								
 259 0096 80F31188 		msr basepri, r0							
 260              	
 261              	@ 0 "" 2
 262              		.thumb
 263              	.L9:
 264              		.loc 1 376 0 discriminator 2
 265 009a FEE7     		b	.L9
 266              	.L8:
 377:../FreeRTOS_Source/queue.c **** 		return pxNewQueue;
 267              		.loc 1 377 0 is_stmt 1
 268 009c FB68     		ldr	r3, [r7, #12]
 378:../FreeRTOS_Source/queue.c **** 	}
 269              		.loc 1 378 0
 270 009e 1846     		mov	r0, r3
 271 00a0 07F11007 		add	r7, r7, #16
 272 00a4 BD46     		mov	sp, r7
 273 00a6 80BD     		pop	{r7, pc}
 274              		.cfi_endproc
 275              	.LFE1:
 277              		.section	.text.xQueueGenericSend,"ax",%progbits
 278              		.align	2
 279              		.global	xQueueGenericSend
 280              		.thumb
 281              		.thumb_func
 283              	xQueueGenericSend:
 284              	.LFB2:
 379:../FreeRTOS_Source/queue.c **** 
 380:../FreeRTOS_Source/queue.c **** #endif /* configUSE_MUTEXES */
 381:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 382:../FreeRTOS_Source/queue.c **** 
 383:../FreeRTOS_Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 384:../FreeRTOS_Source/queue.c **** 
 385:../FreeRTOS_Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 386:../FreeRTOS_Source/queue.c **** 	{
 387:../FreeRTOS_Source/queue.c **** 	portBASE_TYPE xReturn;
 388:../FreeRTOS_Source/queue.c **** 
 389:../FreeRTOS_Source/queue.c **** 		configASSERT( pxMutex );
 390:../FreeRTOS_Source/queue.c **** 
 391:../FreeRTOS_Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 392:../FreeRTOS_Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 393:../FreeRTOS_Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 394:../FreeRTOS_Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 395:../FreeRTOS_Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 396:../FreeRTOS_Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 397:../FreeRTOS_Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 398:../FreeRTOS_Source/queue.c **** 		{
 399:../FreeRTOS_Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 400:../FreeRTOS_Source/queue.c **** 
 401:../FreeRTOS_Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 402:../FreeRTOS_Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 403:../FreeRTOS_Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 404:../FreeRTOS_Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 405:../FreeRTOS_Source/queue.c **** 			uxRecursiveCallCount member. */
 406:../FreeRTOS_Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 407:../FreeRTOS_Source/queue.c **** 
 408:../FreeRTOS_Source/queue.c **** 			/* Have we unwound the call count? */
 409:../FreeRTOS_Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 410:../FreeRTOS_Source/queue.c **** 			{
 411:../FreeRTOS_Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 412:../FreeRTOS_Source/queue.c **** 				task that might be waiting to access the mutex. */
 413:../FreeRTOS_Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 414:../FreeRTOS_Source/queue.c **** 			}
 415:../FreeRTOS_Source/queue.c **** 
 416:../FreeRTOS_Source/queue.c **** 			xReturn = pdPASS;
 417:../FreeRTOS_Source/queue.c **** 		}
 418:../FreeRTOS_Source/queue.c **** 		else
 419:../FreeRTOS_Source/queue.c **** 		{
 420:../FreeRTOS_Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 421:../FreeRTOS_Source/queue.c **** 			xReturn = pdFAIL;
 422:../FreeRTOS_Source/queue.c **** 
 423:../FreeRTOS_Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 424:../FreeRTOS_Source/queue.c **** 		}
 425:../FreeRTOS_Source/queue.c **** 
 426:../FreeRTOS_Source/queue.c **** 		return xReturn;
 427:../FreeRTOS_Source/queue.c **** 	}
 428:../FreeRTOS_Source/queue.c **** 
 429:../FreeRTOS_Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 430:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 431:../FreeRTOS_Source/queue.c **** 
 432:../FreeRTOS_Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 433:../FreeRTOS_Source/queue.c **** 
 434:../FreeRTOS_Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 435:../FreeRTOS_Source/queue.c **** 	{
 436:../FreeRTOS_Source/queue.c **** 	portBASE_TYPE xReturn;
 437:../FreeRTOS_Source/queue.c **** 
 438:../FreeRTOS_Source/queue.c **** 		configASSERT( pxMutex );
 439:../FreeRTOS_Source/queue.c **** 
 440:../FreeRTOS_Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 441:../FreeRTOS_Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 442:../FreeRTOS_Source/queue.c **** 
 443:../FreeRTOS_Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 444:../FreeRTOS_Source/queue.c **** 
 445:../FreeRTOS_Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 446:../FreeRTOS_Source/queue.c **** 		{
 447:../FreeRTOS_Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 448:../FreeRTOS_Source/queue.c **** 			xReturn = pdPASS;
 449:../FreeRTOS_Source/queue.c **** 		}
 450:../FreeRTOS_Source/queue.c **** 		else
 451:../FreeRTOS_Source/queue.c **** 		{
 452:../FreeRTOS_Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 453:../FreeRTOS_Source/queue.c **** 
 454:../FreeRTOS_Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 455:../FreeRTOS_Source/queue.c **** 			we may have blocked to reach here. */
 456:../FreeRTOS_Source/queue.c **** 			if( xReturn == pdPASS )
 457:../FreeRTOS_Source/queue.c **** 			{
 458:../FreeRTOS_Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 459:../FreeRTOS_Source/queue.c **** 			}
 460:../FreeRTOS_Source/queue.c **** 			else
 461:../FreeRTOS_Source/queue.c **** 			{
 462:../FreeRTOS_Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 463:../FreeRTOS_Source/queue.c **** 			}
 464:../FreeRTOS_Source/queue.c **** 		}
 465:../FreeRTOS_Source/queue.c **** 
 466:../FreeRTOS_Source/queue.c **** 		return xReturn;
 467:../FreeRTOS_Source/queue.c **** 	}
 468:../FreeRTOS_Source/queue.c **** 
 469:../FreeRTOS_Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 470:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 471:../FreeRTOS_Source/queue.c **** 
 472:../FreeRTOS_Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 473:../FreeRTOS_Source/queue.c **** 
 474:../FreeRTOS_Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 475:../FreeRTOS_Source/queue.c **** 	{
 476:../FreeRTOS_Source/queue.c **** 	xQueueHandle pxHandle;
 477:../FreeRTOS_Source/queue.c **** 
 478:../FreeRTOS_Source/queue.c **** 		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITE
 479:../FreeRTOS_Source/queue.c **** 
 480:../FreeRTOS_Source/queue.c **** 		if( pxHandle != NULL )
 481:../FreeRTOS_Source/queue.c **** 		{
 482:../FreeRTOS_Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 483:../FreeRTOS_Source/queue.c **** 
 484:../FreeRTOS_Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 485:../FreeRTOS_Source/queue.c **** 		}
 486:../FreeRTOS_Source/queue.c **** 		else
 487:../FreeRTOS_Source/queue.c **** 		{
 488:../FreeRTOS_Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 489:../FreeRTOS_Source/queue.c **** 		}
 490:../FreeRTOS_Source/queue.c **** 
 491:../FreeRTOS_Source/queue.c **** 		configASSERT( pxHandle );
 492:../FreeRTOS_Source/queue.c **** 		return pxHandle;
 493:../FreeRTOS_Source/queue.c **** 	}
 494:../FreeRTOS_Source/queue.c **** 
 495:../FreeRTOS_Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 496:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 497:../FreeRTOS_Source/queue.c **** 
 498:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 499:../FreeRTOS_Source/queue.c **** {
 285              		.loc 1 499 0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 32
 288              		@ frame_needed = 1, uses_anonymous_args = 0
 289 0000 80B5     		push	{r7, lr}
 290              	.LCFI6:
 291              		.cfi_def_cfa_offset 8
 292              		.cfi_offset 14, -4
 293              		.cfi_offset 7, -8
 294 0002 88B0     		sub	sp, sp, #32
 295              	.LCFI7:
 296              		.cfi_def_cfa_offset 40
 297 0004 00AF     		add	r7, sp, #0
 298              	.LCFI8:
 299              		.cfi_def_cfa_register 7
 300 0006 F860     		str	r0, [r7, #12]
 301 0008 B960     		str	r1, [r7, #8]
 302 000a 7A60     		str	r2, [r7, #4]
 303 000c 3B60     		str	r3, [r7, #0]
 500:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 304              		.loc 1 500 0
 305 000e 4FF00003 		mov	r3, #0
 306 0012 FB61     		str	r3, [r7, #28]
 501:../FreeRTOS_Source/queue.c **** xTimeOutType xTimeOut;
 502:../FreeRTOS_Source/queue.c **** 
 503:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 307              		.loc 1 503 0
 308 0014 FB68     		ldr	r3, [r7, #12]
 309 0016 002B     		cmp	r3, #0
 310 0018 04D1     		bne	.L11
 311              		.loc 1 503 0 is_stmt 0 discriminator 1
 312              	@ 503 "../FreeRTOS_Source/queue.c" 1
 313 001a 4FF05000 			mov r0, #80								
 314 001e 80F31188 		msr basepri, r0							
 315              	
 316              	@ 0 "" 2
 317              		.thumb
 318              	.L12:
 319              		.loc 1 503 0 discriminator 2
 320 0022 FEE7     		b	.L12
 321              	.L11:
 504:../FreeRTOS_Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 322              		.loc 1 504 0 is_stmt 1
 323 0024 BB68     		ldr	r3, [r7, #8]
 324 0026 002B     		cmp	r3, #0
 325 0028 03D1     		bne	.L13
 326              		.loc 1 504 0 is_stmt 0 discriminator 2
 327 002a FB68     		ldr	r3, [r7, #12]
 328 002c 1B6C     		ldr	r3, [r3, #64]
 329 002e 002B     		cmp	r3, #0
 330 0030 02D1     		bne	.L14
 331              	.L13:
 332              		.loc 1 504 0 discriminator 1
 333 0032 4FF00103 		mov	r3, #1
 334 0036 01E0     		b	.L15
 335              	.L14:
 336              		.loc 1 504 0 discriminator 3
 337 0038 4FF00003 		mov	r3, #0
 338              	.L15:
 339              		.loc 1 504 0 discriminator 4
 340 003c 002B     		cmp	r3, #0
 341 003e 05D1     		bne	.L16
 342              		.loc 1 504 0 discriminator 5
 343              	@ 504 "../FreeRTOS_Source/queue.c" 1
 344 0040 4FF05000 			mov r0, #80								
 345 0044 80F31188 		msr basepri, r0							
 346              	
 347              	@ 0 "" 2
 348              		.thumb
 349              	.L17:
 350              		.loc 1 504 0 discriminator 6
 351 0048 FEE7     		b	.L17
 352              	.L28:
 505:../FreeRTOS_Source/queue.c **** 
 506:../FreeRTOS_Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../FreeRTOS_Source/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../FreeRTOS_Source/queue.c **** 	of execution time efficiency. */
 509:../FreeRTOS_Source/queue.c **** 	for( ;; )
 510:../FreeRTOS_Source/queue.c **** 	{
 511:../FreeRTOS_Source/queue.c **** 		taskENTER_CRITICAL();
 512:../FreeRTOS_Source/queue.c **** 		{
 513:../FreeRTOS_Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../FreeRTOS_Source/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../FreeRTOS_Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../FreeRTOS_Source/queue.c **** 			{
 517:../FreeRTOS_Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../FreeRTOS_Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../FreeRTOS_Source/queue.c **** 
 520:../FreeRTOS_Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../FreeRTOS_Source/queue.c **** 				queue then unblock it now. */
 522:../FreeRTOS_Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../FreeRTOS_Source/queue.c **** 				{
 524:../FreeRTOS_Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../FreeRTOS_Source/queue.c **** 					{
 526:../FreeRTOS_Source/queue.c **** 						/* The unblocked task has a priority higher than
 527:../FreeRTOS_Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../FreeRTOS_Source/queue.c **** 						this from within the critical section - the kernel
 529:../FreeRTOS_Source/queue.c **** 						takes care of that. */
 530:../FreeRTOS_Source/queue.c **** 						portYIELD_WITHIN_API();
 531:../FreeRTOS_Source/queue.c **** 					}
 532:../FreeRTOS_Source/queue.c **** 				}
 533:../FreeRTOS_Source/queue.c **** 
 534:../FreeRTOS_Source/queue.c **** 				taskEXIT_CRITICAL();
 535:../FreeRTOS_Source/queue.c **** 
 536:../FreeRTOS_Source/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../FreeRTOS_Source/queue.c **** 				function. */
 538:../FreeRTOS_Source/queue.c **** 				return pdPASS;
 539:../FreeRTOS_Source/queue.c **** 			}
 540:../FreeRTOS_Source/queue.c **** 			else
 541:../FreeRTOS_Source/queue.c **** 			{
 542:../FreeRTOS_Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../FreeRTOS_Source/queue.c **** 				{
 544:../FreeRTOS_Source/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../FreeRTOS_Source/queue.c **** 					the block time has expired) so leave now. */
 546:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 547:../FreeRTOS_Source/queue.c **** 
 548:../FreeRTOS_Source/queue.c **** 					/* Return to the original privilege level before exiting
 549:../FreeRTOS_Source/queue.c **** 					the function. */
 550:../FreeRTOS_Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../FreeRTOS_Source/queue.c **** 					return errQUEUE_FULL;
 552:../FreeRTOS_Source/queue.c **** 				}
 553:../FreeRTOS_Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../FreeRTOS_Source/queue.c **** 				{
 555:../FreeRTOS_Source/queue.c **** 					/* The queue was full and a block time was specified so
 556:../FreeRTOS_Source/queue.c **** 					configure the timeout structure. */
 557:../FreeRTOS_Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../FreeRTOS_Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../FreeRTOS_Source/queue.c **** 				}
 560:../FreeRTOS_Source/queue.c **** 			}
 561:../FreeRTOS_Source/queue.c **** 		}
 562:../FreeRTOS_Source/queue.c **** 		taskEXIT_CRITICAL();
 563:../FreeRTOS_Source/queue.c **** 
 564:../FreeRTOS_Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../FreeRTOS_Source/queue.c **** 		now the critical section has been exited. */
 566:../FreeRTOS_Source/queue.c **** 
 567:../FreeRTOS_Source/queue.c **** 		vTaskSuspendAll();
 568:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 569:../FreeRTOS_Source/queue.c **** 
 570:../FreeRTOS_Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../FreeRTOS_Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../FreeRTOS_Source/queue.c **** 		{
 573:../FreeRTOS_Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 574:../FreeRTOS_Source/queue.c **** 			{
 575:../FreeRTOS_Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../FreeRTOS_Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../FreeRTOS_Source/queue.c **** 
 578:../FreeRTOS_Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../FreeRTOS_Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../FreeRTOS_Source/queue.c **** 				remove this task from the event	list again - but as the
 581:../FreeRTOS_Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../FreeRTOS_Source/queue.c **** 				ready last instead of the actual ready list. */
 583:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../FreeRTOS_Source/queue.c **** 
 585:../FreeRTOS_Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../FreeRTOS_Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../FreeRTOS_Source/queue.c **** 				task is already in a ready list before it yields - in which
 588:../FreeRTOS_Source/queue.c **** 				case the yield will not cause a context switch unless there
 589:../FreeRTOS_Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../FreeRTOS_Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 591:../FreeRTOS_Source/queue.c **** 				{
 592:../FreeRTOS_Source/queue.c **** 					portYIELD_WITHIN_API();
 593:../FreeRTOS_Source/queue.c **** 				}
 594:../FreeRTOS_Source/queue.c **** 			}
 595:../FreeRTOS_Source/queue.c **** 			else
 596:../FreeRTOS_Source/queue.c **** 			{
 597:../FreeRTOS_Source/queue.c **** 				/* Try again. */
 598:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../FreeRTOS_Source/queue.c **** 				( void ) xTaskResumeAll();
 600:../FreeRTOS_Source/queue.c **** 			}
 601:../FreeRTOS_Source/queue.c **** 		}
 602:../FreeRTOS_Source/queue.c **** 		else
 603:../FreeRTOS_Source/queue.c **** 		{
 604:../FreeRTOS_Source/queue.c **** 			/* The timeout has expired. */
 605:../FreeRTOS_Source/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../FreeRTOS_Source/queue.c **** 			( void ) xTaskResumeAll();
 607:../FreeRTOS_Source/queue.c **** 
 608:../FreeRTOS_Source/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../FreeRTOS_Source/queue.c **** 			function. */
 610:../FreeRTOS_Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../FreeRTOS_Source/queue.c **** 			return errQUEUE_FULL;
 612:../FreeRTOS_Source/queue.c **** 		}
 613:../FreeRTOS_Source/queue.c **** 	}
 353              		.loc 1 613 0 is_stmt 1
 354 004a 00BF     		nop
 355              	.L16:
 511:../FreeRTOS_Source/queue.c **** 		taskENTER_CRITICAL();
 356              		.loc 1 511 0
 357 004c FFF7FEFF 		bl	vPortEnterCritical
 515:../FreeRTOS_Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 358              		.loc 1 515 0
 359 0050 FB68     		ldr	r3, [r7, #12]
 360 0052 9A6B     		ldr	r2, [r3, #56]
 361 0054 FB68     		ldr	r3, [r7, #12]
 362 0056 DB6B     		ldr	r3, [r3, #60]
 363 0058 9A42     		cmp	r2, r3
 364 005a 18D2     		bcs	.L18
 518:../FreeRTOS_Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 365              		.loc 1 518 0
 366 005c F868     		ldr	r0, [r7, #12]
 367 005e B968     		ldr	r1, [r7, #8]
 368 0060 3A68     		ldr	r2, [r7, #0]
 369 0062 FFF7FEFF 		bl	prvCopyDataToQueue
 522:../FreeRTOS_Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 370              		.loc 1 522 0
 371 0066 FB68     		ldr	r3, [r7, #12]
 372 0068 5B6A     		ldr	r3, [r3, #36]
 373 006a 002B     		cmp	r3, #0
 374 006c 0AD0     		beq	.L19
 524:../FreeRTOS_Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 375              		.loc 1 524 0
 376 006e FB68     		ldr	r3, [r7, #12]
 377 0070 03F12403 		add	r3, r3, #36
 378 0074 1846     		mov	r0, r3
 379 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 380 007a 0346     		mov	r3, r0
 381 007c 012B     		cmp	r3, #1
 382 007e 01D1     		bne	.L19
 530:../FreeRTOS_Source/queue.c **** 						portYIELD_WITHIN_API();
 383              		.loc 1 530 0
 384 0080 FFF7FEFF 		bl	vPortYieldFromISR
 385              	.L19:
 534:../FreeRTOS_Source/queue.c **** 				taskEXIT_CRITICAL();
 386              		.loc 1 534 0
 387 0084 FFF7FEFF 		bl	vPortExitCritical
 538:../FreeRTOS_Source/queue.c **** 				return pdPASS;
 388              		.loc 1 538 0
 389 0088 4FF00103 		mov	r3, #1
 390 008c 5DE0     		b	.L20
 391              	.L18:
 542:../FreeRTOS_Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 392              		.loc 1 542 0
 393 008e 7B68     		ldr	r3, [r7, #4]
 394 0090 002B     		cmp	r3, #0
 395 0092 04D1     		bne	.L21
 546:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 396              		.loc 1 546 0
 397 0094 FFF7FEFF 		bl	vPortExitCritical
 551:../FreeRTOS_Source/queue.c **** 					return errQUEUE_FULL;
 398              		.loc 1 551 0
 399 0098 4FF00003 		mov	r3, #0
 400 009c 55E0     		b	.L20
 401              	.L21:
 553:../FreeRTOS_Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 402              		.loc 1 553 0
 403 009e FB69     		ldr	r3, [r7, #28]
 404 00a0 002B     		cmp	r3, #0
 405 00a2 07D1     		bne	.L22
 557:../FreeRTOS_Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 406              		.loc 1 557 0
 407 00a4 07F11403 		add	r3, r7, #20
 408 00a8 1846     		mov	r0, r3
 409 00aa FFF7FEFF 		bl	vTaskSetTimeOutState
 558:../FreeRTOS_Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 410              		.loc 1 558 0
 411 00ae 4FF00103 		mov	r3, #1
 412 00b2 FB61     		str	r3, [r7, #28]
 413              	.L22:
 562:../FreeRTOS_Source/queue.c **** 		taskEXIT_CRITICAL();
 414              		.loc 1 562 0
 415 00b4 FFF7FEFF 		bl	vPortExitCritical
 567:../FreeRTOS_Source/queue.c **** 		vTaskSuspendAll();
 416              		.loc 1 567 0
 417 00b8 FFF7FEFF 		bl	vTaskSuspendAll
 568:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 418              		.loc 1 568 0
 419 00bc FFF7FEFF 		bl	vPortEnterCritical
 420 00c0 FB68     		ldr	r3, [r7, #12]
 421 00c2 5B6C     		ldr	r3, [r3, #68]
 422 00c4 B3F1FF3F 		cmp	r3, #-1
 423 00c8 03D1     		bne	.L23
 568:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 424              		.loc 1 568 0 is_stmt 0 discriminator 1
 425 00ca FB68     		ldr	r3, [r7, #12]
 426 00cc 4FF00002 		mov	r2, #0
 427 00d0 5A64     		str	r2, [r3, #68]
 428              	.L23:
 568:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 429              		.loc 1 568 0 discriminator 2
 430 00d2 FB68     		ldr	r3, [r7, #12]
 431 00d4 9B6C     		ldr	r3, [r3, #72]
 432 00d6 B3F1FF3F 		cmp	r3, #-1
 433 00da 03D1     		bne	.L24
 568:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 434              		.loc 1 568 0 discriminator 3
 435 00dc FB68     		ldr	r3, [r7, #12]
 436 00de 4FF00002 		mov	r2, #0
 437 00e2 9A64     		str	r2, [r3, #72]
 438              	.L24:
 568:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 439              		.loc 1 568 0 discriminator 4
 440 00e4 FFF7FEFF 		bl	vPortExitCritical
 571:../FreeRTOS_Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 441              		.loc 1 571 0 is_stmt 1 discriminator 4
 442 00e8 07F11402 		add	r2, r7, #20
 443 00ec 07F10403 		add	r3, r7, #4
 444 00f0 1046     		mov	r0, r2
 445 00f2 1946     		mov	r1, r3
 446 00f4 FFF7FEFF 		bl	xTaskCheckForTimeOut
 447 00f8 0346     		mov	r3, r0
 448 00fa 002B     		cmp	r3, #0
 449 00fc 1ED1     		bne	.L25
 573:../FreeRTOS_Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 450              		.loc 1 573 0
 451 00fe F868     		ldr	r0, [r7, #12]
 452 0100 FFF7FEFF 		bl	prvIsQueueFull
 453 0104 0346     		mov	r3, r0
 454 0106 002B     		cmp	r3, #0
 455 0108 12D0     		beq	.L26
 576:../FreeRTOS_Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 456              		.loc 1 576 0
 457 010a FB68     		ldr	r3, [r7, #12]
 458 010c 03F11002 		add	r2, r3, #16
 459 0110 7B68     		ldr	r3, [r7, #4]
 460 0112 1046     		mov	r0, r2
 461 0114 1946     		mov	r1, r3
 462 0116 FFF7FEFF 		bl	vTaskPlaceOnEventList
 583:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
 463              		.loc 1 583 0
 464 011a F868     		ldr	r0, [r7, #12]
 465 011c FFF7FEFF 		bl	prvUnlockQueue
 590:../FreeRTOS_Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 466              		.loc 1 590 0
 467 0120 FFF7FEFF 		bl	xTaskResumeAll
 468 0124 0346     		mov	r3, r0
 469 0126 002B     		cmp	r3, #0
 470 0128 8FD1     		bne	.L28
 592:../FreeRTOS_Source/queue.c **** 					portYIELD_WITHIN_API();
 471              		.loc 1 592 0
 472 012a FFF7FEFF 		bl	vPortYieldFromISR
 473              		.loc 1 613 0
 474 012e 8CE7     		b	.L28
 475              	.L26:
 598:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
 476              		.loc 1 598 0
 477 0130 F868     		ldr	r0, [r7, #12]
 478 0132 FFF7FEFF 		bl	prvUnlockQueue
 599:../FreeRTOS_Source/queue.c **** 				( void ) xTaskResumeAll();
 479              		.loc 1 599 0
 480 0136 FFF7FEFF 		bl	xTaskResumeAll
 481              		.loc 1 613 0
 482 013a 86E7     		b	.L28
 483              	.L25:
 605:../FreeRTOS_Source/queue.c **** 			prvUnlockQueue( pxQueue );
 484              		.loc 1 605 0
 485 013c F868     		ldr	r0, [r7, #12]
 486 013e FFF7FEFF 		bl	prvUnlockQueue
 606:../FreeRTOS_Source/queue.c **** 			( void ) xTaskResumeAll();
 487              		.loc 1 606 0
 488 0142 FFF7FEFF 		bl	xTaskResumeAll
 611:../FreeRTOS_Source/queue.c **** 			return errQUEUE_FULL;
 489              		.loc 1 611 0
 490 0146 4FF00003 		mov	r3, #0
 491              	.L20:
 614:../FreeRTOS_Source/queue.c **** }
 492              		.loc 1 614 0
 493 014a 1846     		mov	r0, r3
 494 014c 07F12007 		add	r7, r7, #32
 495 0150 BD46     		mov	sp, r7
 496 0152 80BD     		pop	{r7, pc}
 497              		.cfi_endproc
 498              	.LFE2:
 500              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 501              		.align	2
 502              		.global	xQueueGenericSendFromISR
 503              		.thumb
 504              		.thumb_func
 506              	xQueueGenericSendFromISR:
 507              	.LFB3:
 615:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 616:../FreeRTOS_Source/queue.c **** 
 617:../FreeRTOS_Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../FreeRTOS_Source/queue.c **** 
 619:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../FreeRTOS_Source/queue.c **** 	{
 621:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../FreeRTOS_Source/queue.c **** 	xTimeOutType xTimeOut;
 623:../FreeRTOS_Source/queue.c **** 
 624:../FreeRTOS_Source/queue.c **** 		configASSERT( pxQueue );
 625:../FreeRTOS_Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 626:../FreeRTOS_Source/queue.c **** 
 627:../FreeRTOS_Source/queue.c **** 		for( ;; )
 628:../FreeRTOS_Source/queue.c **** 		{
 629:../FreeRTOS_Source/queue.c **** 			taskENTER_CRITICAL();
 630:../FreeRTOS_Source/queue.c **** 			{
 631:../FreeRTOS_Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 632:../FreeRTOS_Source/queue.c **** 				the highest priority task wanting to access the queue. */
 633:../FreeRTOS_Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 634:../FreeRTOS_Source/queue.c **** 				{
 635:../FreeRTOS_Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 636:../FreeRTOS_Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 637:../FreeRTOS_Source/queue.c **** 
 638:../FreeRTOS_Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 639:../FreeRTOS_Source/queue.c **** 					queue then unblock it now. */
 640:../FreeRTOS_Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 641:../FreeRTOS_Source/queue.c **** 					{
 642:../FreeRTOS_Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 643:../FreeRTOS_Source/queue.c **** 						{
 644:../FreeRTOS_Source/queue.c **** 							/* The unblocked task has a priority higher than
 645:../FreeRTOS_Source/queue.c **** 							our own so yield immediately. */
 646:../FreeRTOS_Source/queue.c **** 							portYIELD_WITHIN_API();
 647:../FreeRTOS_Source/queue.c **** 						}
 648:../FreeRTOS_Source/queue.c **** 					}
 649:../FreeRTOS_Source/queue.c **** 
 650:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 651:../FreeRTOS_Source/queue.c **** 					return pdPASS;
 652:../FreeRTOS_Source/queue.c **** 				}
 653:../FreeRTOS_Source/queue.c **** 				else
 654:../FreeRTOS_Source/queue.c **** 				{
 655:../FreeRTOS_Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 656:../FreeRTOS_Source/queue.c **** 					{
 657:../FreeRTOS_Source/queue.c **** 						taskEXIT_CRITICAL();
 658:../FreeRTOS_Source/queue.c **** 						return errQUEUE_FULL;
 659:../FreeRTOS_Source/queue.c **** 					}
 660:../FreeRTOS_Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 661:../FreeRTOS_Source/queue.c **** 					{
 662:../FreeRTOS_Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 663:../FreeRTOS_Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 664:../FreeRTOS_Source/queue.c **** 					}
 665:../FreeRTOS_Source/queue.c **** 				}
 666:../FreeRTOS_Source/queue.c **** 			}
 667:../FreeRTOS_Source/queue.c **** 			taskEXIT_CRITICAL();
 668:../FreeRTOS_Source/queue.c **** 
 669:../FreeRTOS_Source/queue.c **** 			taskENTER_CRITICAL();
 670:../FreeRTOS_Source/queue.c **** 			{
 671:../FreeRTOS_Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 672:../FreeRTOS_Source/queue.c **** 				{
 673:../FreeRTOS_Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 674:../FreeRTOS_Source/queue.c **** 					{
 675:../FreeRTOS_Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 676:../FreeRTOS_Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 677:../FreeRTOS_Source/queue.c **** 						portYIELD_WITHIN_API();
 678:../FreeRTOS_Source/queue.c **** 					}
 679:../FreeRTOS_Source/queue.c **** 				}
 680:../FreeRTOS_Source/queue.c **** 				else
 681:../FreeRTOS_Source/queue.c **** 				{
 682:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 683:../FreeRTOS_Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 684:../FreeRTOS_Source/queue.c **** 					return errQUEUE_FULL;
 685:../FreeRTOS_Source/queue.c **** 				}
 686:../FreeRTOS_Source/queue.c **** 			}
 687:../FreeRTOS_Source/queue.c **** 			taskEXIT_CRITICAL();
 688:../FreeRTOS_Source/queue.c **** 		}
 689:../FreeRTOS_Source/queue.c **** 	}
 690:../FreeRTOS_Source/queue.c **** 
 691:../FreeRTOS_Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 692:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 693:../FreeRTOS_Source/queue.c **** 
 694:../FreeRTOS_Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 695:../FreeRTOS_Source/queue.c **** 
 696:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 697:../FreeRTOS_Source/queue.c **** 	{
 698:../FreeRTOS_Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 699:../FreeRTOS_Source/queue.c **** 	xTimeOutType xTimeOut;
 700:../FreeRTOS_Source/queue.c **** 	signed char *pcOriginalReadPosition;
 701:../FreeRTOS_Source/queue.c **** 
 702:../FreeRTOS_Source/queue.c **** 		configASSERT( pxQueue );
 703:../FreeRTOS_Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 704:../FreeRTOS_Source/queue.c **** 
 705:../FreeRTOS_Source/queue.c **** 		for( ;; )
 706:../FreeRTOS_Source/queue.c **** 		{
 707:../FreeRTOS_Source/queue.c **** 			taskENTER_CRITICAL();
 708:../FreeRTOS_Source/queue.c **** 			{
 709:../FreeRTOS_Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 710:../FreeRTOS_Source/queue.c **** 				{
 711:../FreeRTOS_Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 712:../FreeRTOS_Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 713:../FreeRTOS_Source/queue.c **** 
 714:../FreeRTOS_Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 715:../FreeRTOS_Source/queue.c **** 
 716:../FreeRTOS_Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 717:../FreeRTOS_Source/queue.c **** 					{
 718:../FreeRTOS_Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 719:../FreeRTOS_Source/queue.c **** 
 720:../FreeRTOS_Source/queue.c **** 						/* We are actually removing data. */
 721:../FreeRTOS_Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 722:../FreeRTOS_Source/queue.c **** 
 723:../FreeRTOS_Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 724:../FreeRTOS_Source/queue.c **** 						{
 725:../FreeRTOS_Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 726:../FreeRTOS_Source/queue.c **** 							{
 727:../FreeRTOS_Source/queue.c **** 								/* Record the information required to implement
 728:../FreeRTOS_Source/queue.c **** 								priority inheritance should it become necessary. */
 729:../FreeRTOS_Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 730:../FreeRTOS_Source/queue.c **** 							}
 731:../FreeRTOS_Source/queue.c **** 						}
 732:../FreeRTOS_Source/queue.c **** 						#endif
 733:../FreeRTOS_Source/queue.c **** 
 734:../FreeRTOS_Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 735:../FreeRTOS_Source/queue.c **** 						{
 736:../FreeRTOS_Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 737:../FreeRTOS_Source/queue.c **** 							{
 738:../FreeRTOS_Source/queue.c **** 								portYIELD_WITHIN_API();
 739:../FreeRTOS_Source/queue.c **** 							}
 740:../FreeRTOS_Source/queue.c **** 						}
 741:../FreeRTOS_Source/queue.c **** 					}
 742:../FreeRTOS_Source/queue.c **** 					else
 743:../FreeRTOS_Source/queue.c **** 					{
 744:../FreeRTOS_Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 745:../FreeRTOS_Source/queue.c **** 
 746:../FreeRTOS_Source/queue.c **** 						/* We are not removing the data, so reset our read
 747:../FreeRTOS_Source/queue.c **** 						pointer. */
 748:../FreeRTOS_Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 749:../FreeRTOS_Source/queue.c **** 
 750:../FreeRTOS_Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 751:../FreeRTOS_Source/queue.c **** 						any other tasks waiting for the data. */
 752:../FreeRTOS_Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 753:../FreeRTOS_Source/queue.c **** 						{
 754:../FreeRTOS_Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 755:../FreeRTOS_Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 756:../FreeRTOS_Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 757:../FreeRTOS_Source/queue.c **** 							{
 758:../FreeRTOS_Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 759:../FreeRTOS_Source/queue.c **** 								portYIELD_WITHIN_API();
 760:../FreeRTOS_Source/queue.c **** 							}
 761:../FreeRTOS_Source/queue.c **** 						}
 762:../FreeRTOS_Source/queue.c **** 
 763:../FreeRTOS_Source/queue.c **** 					}
 764:../FreeRTOS_Source/queue.c **** 
 765:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 766:../FreeRTOS_Source/queue.c **** 					return pdPASS;
 767:../FreeRTOS_Source/queue.c **** 				}
 768:../FreeRTOS_Source/queue.c **** 				else
 769:../FreeRTOS_Source/queue.c **** 				{
 770:../FreeRTOS_Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 771:../FreeRTOS_Source/queue.c **** 					{
 772:../FreeRTOS_Source/queue.c **** 						taskEXIT_CRITICAL();
 773:../FreeRTOS_Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 774:../FreeRTOS_Source/queue.c **** 						return errQUEUE_EMPTY;
 775:../FreeRTOS_Source/queue.c **** 					}
 776:../FreeRTOS_Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 777:../FreeRTOS_Source/queue.c **** 					{
 778:../FreeRTOS_Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 779:../FreeRTOS_Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 780:../FreeRTOS_Source/queue.c **** 					}
 781:../FreeRTOS_Source/queue.c **** 				}
 782:../FreeRTOS_Source/queue.c **** 			}
 783:../FreeRTOS_Source/queue.c **** 			taskEXIT_CRITICAL();
 784:../FreeRTOS_Source/queue.c **** 
 785:../FreeRTOS_Source/queue.c **** 			taskENTER_CRITICAL();
 786:../FreeRTOS_Source/queue.c **** 			{
 787:../FreeRTOS_Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 788:../FreeRTOS_Source/queue.c **** 				{
 789:../FreeRTOS_Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 790:../FreeRTOS_Source/queue.c **** 					{
 791:../FreeRTOS_Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 792:../FreeRTOS_Source/queue.c **** 
 793:../FreeRTOS_Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 794:../FreeRTOS_Source/queue.c **** 						{
 795:../FreeRTOS_Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 796:../FreeRTOS_Source/queue.c **** 							{
 797:../FreeRTOS_Source/queue.c **** 								portENTER_CRITICAL();
 798:../FreeRTOS_Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 799:../FreeRTOS_Source/queue.c **** 								portEXIT_CRITICAL();
 800:../FreeRTOS_Source/queue.c **** 							}
 801:../FreeRTOS_Source/queue.c **** 						}
 802:../FreeRTOS_Source/queue.c **** 						#endif
 803:../FreeRTOS_Source/queue.c **** 
 804:../FreeRTOS_Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805:../FreeRTOS_Source/queue.c **** 						portYIELD_WITHIN_API();
 806:../FreeRTOS_Source/queue.c **** 					}
 807:../FreeRTOS_Source/queue.c **** 				}
 808:../FreeRTOS_Source/queue.c **** 				else
 809:../FreeRTOS_Source/queue.c **** 				{
 810:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 811:../FreeRTOS_Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 812:../FreeRTOS_Source/queue.c **** 					return errQUEUE_EMPTY;
 813:../FreeRTOS_Source/queue.c **** 				}
 814:../FreeRTOS_Source/queue.c **** 			}
 815:../FreeRTOS_Source/queue.c **** 			taskEXIT_CRITICAL();
 816:../FreeRTOS_Source/queue.c **** 		}
 817:../FreeRTOS_Source/queue.c **** 	}
 818:../FreeRTOS_Source/queue.c **** 
 819:../FreeRTOS_Source/queue.c **** 
 820:../FreeRTOS_Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 821:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 822:../FreeRTOS_Source/queue.c **** 
 823:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 824:../FreeRTOS_Source/queue.c **** {
 508              		.loc 1 824 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 24
 511              		@ frame_needed = 1, uses_anonymous_args = 0
 512 0000 80B5     		push	{r7, lr}
 513              	.LCFI9:
 514              		.cfi_def_cfa_offset 8
 515              		.cfi_offset 14, -4
 516              		.cfi_offset 7, -8
 517 0002 86B0     		sub	sp, sp, #24
 518              	.LCFI10:
 519              		.cfi_def_cfa_offset 32
 520 0004 00AF     		add	r7, sp, #0
 521              	.LCFI11:
 522              		.cfi_def_cfa_register 7
 523 0006 F860     		str	r0, [r7, #12]
 524 0008 B960     		str	r1, [r7, #8]
 525 000a 7A60     		str	r2, [r7, #4]
 526 000c 3B60     		str	r3, [r7, #0]
 825:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
 826:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 827:../FreeRTOS_Source/queue.c **** 
 828:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 527              		.loc 1 828 0
 528 000e FB68     		ldr	r3, [r7, #12]
 529 0010 002B     		cmp	r3, #0
 530 0012 04D1     		bne	.L30
 531              		.loc 1 828 0 is_stmt 0 discriminator 1
 532              	@ 828 "../FreeRTOS_Source/queue.c" 1
 533 0014 4FF05000 			mov r0, #80								
 534 0018 80F31188 		msr basepri, r0							
 535              	
 536              	@ 0 "" 2
 537              		.thumb
 538              	.L31:
 539              		.loc 1 828 0 discriminator 2
 540 001c FEE7     		b	.L31
 541              	.L30:
 829:../FreeRTOS_Source/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 542              		.loc 1 829 0 is_stmt 1
 543 001e 7B68     		ldr	r3, [r7, #4]
 544 0020 002B     		cmp	r3, #0
 545 0022 04D1     		bne	.L32
 546              		.loc 1 829 0 is_stmt 0 discriminator 1
 547              	@ 829 "../FreeRTOS_Source/queue.c" 1
 548 0024 4FF05000 			mov r0, #80								
 549 0028 80F31188 		msr basepri, r0							
 550              	
 551              	@ 0 "" 2
 552              		.thumb
 553              	.L33:
 554              		.loc 1 829 0 discriminator 2
 555 002c FEE7     		b	.L33
 556              	.L32:
 830:../FreeRTOS_Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 557              		.loc 1 830 0 is_stmt 1
 558 002e BB68     		ldr	r3, [r7, #8]
 559 0030 002B     		cmp	r3, #0
 560 0032 03D1     		bne	.L34
 561              		.loc 1 830 0 is_stmt 0 discriminator 2
 562 0034 FB68     		ldr	r3, [r7, #12]
 563 0036 1B6C     		ldr	r3, [r3, #64]
 564 0038 002B     		cmp	r3, #0
 565 003a 02D1     		bne	.L35
 566              	.L34:
 567              		.loc 1 830 0 discriminator 1
 568 003c 4FF00103 		mov	r3, #1
 569 0040 01E0     		b	.L36
 570              	.L35:
 571              		.loc 1 830 0 discriminator 3
 572 0042 4FF00003 		mov	r3, #0
 573              	.L36:
 574              		.loc 1 830 0 discriminator 4
 575 0046 002B     		cmp	r3, #0
 576 0048 04D1     		bne	.L37
 577              		.loc 1 830 0 discriminator 5
 578              	@ 830 "../FreeRTOS_Source/queue.c" 1
 579 004a 4FF05000 			mov r0, #80								
 580 004e 80F31188 		msr basepri, r0							
 581              	
 582              	@ 0 "" 2
 583              		.thumb
 584              	.L38:
 585              		.loc 1 830 0 discriminator 6
 586 0052 FEE7     		b	.L38
 587              	.L37:
 831:../FreeRTOS_Source/queue.c **** 
 832:../FreeRTOS_Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 833:../FreeRTOS_Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 834:../FreeRTOS_Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 835:../FreeRTOS_Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 836:../FreeRTOS_Source/queue.c **** 	by this	post). */
 837:../FreeRTOS_Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 588              		.loc 1 837 0 is_stmt 1
 589 0054 4FF00003 		mov	r3, #0
 590 0058 3B61     		str	r3, [r7, #16]
 591              	@ 837 "../FreeRTOS_Source/queue.c" 1
 592 005a 4FF05000 			mov r0, #80								
 593 005e 80F31188 		msr basepri, r0							
 594              	
 595              	@ 0 "" 2
 838:../FreeRTOS_Source/queue.c **** 	{
 839:../FreeRTOS_Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 596              		.loc 1 839 0
 597              		.thumb
 598 0062 FB68     		ldr	r3, [r7, #12]
 599 0064 9A6B     		ldr	r2, [r3, #56]
 600 0066 FB68     		ldr	r3, [r7, #12]
 601 0068 DB6B     		ldr	r3, [r3, #60]
 602 006a 9A42     		cmp	r2, r3
 603 006c 25D2     		bcs	.L39
 840:../FreeRTOS_Source/queue.c **** 		{
 841:../FreeRTOS_Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 842:../FreeRTOS_Source/queue.c **** 
 843:../FreeRTOS_Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 604              		.loc 1 843 0
 605 006e F868     		ldr	r0, [r7, #12]
 606 0070 B968     		ldr	r1, [r7, #8]
 607 0072 3A68     		ldr	r2, [r7, #0]
 608 0074 FFF7FEFF 		bl	prvCopyDataToQueue
 844:../FreeRTOS_Source/queue.c **** 
 845:../FreeRTOS_Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 846:../FreeRTOS_Source/queue.c **** 			be done when the queue is unlocked later. */
 847:../FreeRTOS_Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 609              		.loc 1 847 0
 610 0078 FB68     		ldr	r3, [r7, #12]
 611 007a 9B6C     		ldr	r3, [r3, #72]
 612 007c B3F1FF3F 		cmp	r3, #-1
 613 0080 11D1     		bne	.L40
 848:../FreeRTOS_Source/queue.c **** 			{
 849:../FreeRTOS_Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 614              		.loc 1 849 0
 615 0082 FB68     		ldr	r3, [r7, #12]
 616 0084 5B6A     		ldr	r3, [r3, #36]
 617 0086 002B     		cmp	r3, #0
 618 0088 13D0     		beq	.L41
 850:../FreeRTOS_Source/queue.c **** 				{
 851:../FreeRTOS_Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 619              		.loc 1 851 0
 620 008a FB68     		ldr	r3, [r7, #12]
 621 008c 03F12403 		add	r3, r3, #36
 622 0090 1846     		mov	r0, r3
 623 0092 FFF7FEFF 		bl	xTaskRemoveFromEventList
 624 0096 0346     		mov	r3, r0
 625 0098 002B     		cmp	r3, #0
 626 009a 0AD0     		beq	.L41
 852:../FreeRTOS_Source/queue.c **** 					{
 853:../FreeRTOS_Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 854:../FreeRTOS_Source/queue.c **** 						context	switch is required. */
 855:../FreeRTOS_Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 627              		.loc 1 855 0
 628 009c 7B68     		ldr	r3, [r7, #4]
 629 009e 4FF00102 		mov	r2, #1
 630 00a2 1A60     		str	r2, [r3, #0]
 631 00a4 05E0     		b	.L41
 632              	.L40:
 856:../FreeRTOS_Source/queue.c **** 					}
 857:../FreeRTOS_Source/queue.c **** 				}
 858:../FreeRTOS_Source/queue.c **** 			}
 859:../FreeRTOS_Source/queue.c **** 			else
 860:../FreeRTOS_Source/queue.c **** 			{
 861:../FreeRTOS_Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 862:../FreeRTOS_Source/queue.c **** 				knows that data was posted while it was locked. */
 863:../FreeRTOS_Source/queue.c **** 				++( pxQueue->xTxLock );
 633              		.loc 1 863 0
 634 00a6 FB68     		ldr	r3, [r7, #12]
 635 00a8 9B6C     		ldr	r3, [r3, #72]
 636 00aa 03F10102 		add	r2, r3, #1
 637 00ae FB68     		ldr	r3, [r7, #12]
 638 00b0 9A64     		str	r2, [r3, #72]
 639              	.L41:
 864:../FreeRTOS_Source/queue.c **** 			}
 865:../FreeRTOS_Source/queue.c **** 
 866:../FreeRTOS_Source/queue.c **** 			xReturn = pdPASS;
 640              		.loc 1 866 0
 641 00b2 4FF00103 		mov	r3, #1
 642 00b6 7B61     		str	r3, [r7, #20]
 643 00b8 02E0     		b	.L42
 644              	.L39:
 867:../FreeRTOS_Source/queue.c **** 		}
 868:../FreeRTOS_Source/queue.c **** 		else
 869:../FreeRTOS_Source/queue.c **** 		{
 870:../FreeRTOS_Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 871:../FreeRTOS_Source/queue.c **** 			xReturn = errQUEUE_FULL;
 645              		.loc 1 871 0
 646 00ba 4FF00003 		mov	r3, #0
 647 00be 7B61     		str	r3, [r7, #20]
 648              	.L42:
 872:../FreeRTOS_Source/queue.c **** 		}
 873:../FreeRTOS_Source/queue.c **** 	}
 874:../FreeRTOS_Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 649              		.loc 1 874 0
 650              	@ 874 "../FreeRTOS_Source/queue.c" 1
 651 00c0 4FF00000 			mov r0, #0					
 652 00c4 80F31188 		msr basepri, r0				
 653              	
 654              	@ 0 "" 2
 875:../FreeRTOS_Source/queue.c **** 
 876:../FreeRTOS_Source/queue.c **** 	return xReturn;
 655              		.loc 1 876 0
 656              		.thumb
 657 00c8 7B69     		ldr	r3, [r7, #20]
 877:../FreeRTOS_Source/queue.c **** }
 658              		.loc 1 877 0
 659 00ca 1846     		mov	r0, r3
 660 00cc 07F11807 		add	r7, r7, #24
 661 00d0 BD46     		mov	sp, r7
 662 00d2 80BD     		pop	{r7, pc}
 663              		.cfi_endproc
 664              	.LFE3:
 666              		.section	.text.xQueueGenericReceive,"ax",%progbits
 667              		.align	2
 668              		.global	xQueueGenericReceive
 669              		.thumb
 670              		.thumb_func
 672              	xQueueGenericReceive:
 673              	.LFB4:
 878:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
 879:../FreeRTOS_Source/queue.c **** 
 880:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 881:../FreeRTOS_Source/queue.c **** {
 674              		.loc 1 881 0
 675              		.cfi_startproc
 676              		@ args = 0, pretend = 0, frame = 32
 677              		@ frame_needed = 1, uses_anonymous_args = 0
 678 0000 80B5     		push	{r7, lr}
 679              	.LCFI12:
 680              		.cfi_def_cfa_offset 8
 681              		.cfi_offset 14, -4
 682              		.cfi_offset 7, -8
 683 0002 88B0     		sub	sp, sp, #32
 684              	.LCFI13:
 685              		.cfi_def_cfa_offset 40
 686 0004 00AF     		add	r7, sp, #0
 687              	.LCFI14:
 688              		.cfi_def_cfa_register 7
 689 0006 F860     		str	r0, [r7, #12]
 690 0008 B960     		str	r1, [r7, #8]
 691 000a 7A60     		str	r2, [r7, #4]
 692 000c 3B60     		str	r3, [r7, #0]
 882:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 693              		.loc 1 882 0
 694 000e 4FF00003 		mov	r3, #0
 695 0012 FB61     		str	r3, [r7, #28]
 883:../FreeRTOS_Source/queue.c **** xTimeOutType xTimeOut;
 884:../FreeRTOS_Source/queue.c **** signed char *pcOriginalReadPosition;
 885:../FreeRTOS_Source/queue.c **** 
 886:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 696              		.loc 1 886 0
 697 0014 FB68     		ldr	r3, [r7, #12]
 698 0016 002B     		cmp	r3, #0
 699 0018 04D1     		bne	.L44
 700              		.loc 1 886 0 is_stmt 0 discriminator 1
 701              	@ 886 "../FreeRTOS_Source/queue.c" 1
 702 001a 4FF05000 			mov r0, #80								
 703 001e 80F31188 		msr basepri, r0							
 704              	
 705              	@ 0 "" 2
 706              		.thumb
 707              	.L45:
 708              		.loc 1 886 0 discriminator 2
 709 0022 FEE7     		b	.L45
 710              	.L44:
 887:../FreeRTOS_Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 711              		.loc 1 887 0 is_stmt 1
 712 0024 BB68     		ldr	r3, [r7, #8]
 713 0026 002B     		cmp	r3, #0
 714 0028 03D1     		bne	.L46
 715              		.loc 1 887 0 is_stmt 0 discriminator 2
 716 002a FB68     		ldr	r3, [r7, #12]
 717 002c 1B6C     		ldr	r3, [r3, #64]
 718 002e 002B     		cmp	r3, #0
 719 0030 02D1     		bne	.L47
 720              	.L46:
 721              		.loc 1 887 0 discriminator 1
 722 0032 4FF00103 		mov	r3, #1
 723 0036 01E0     		b	.L48
 724              	.L47:
 725              		.loc 1 887 0 discriminator 3
 726 0038 4FF00003 		mov	r3, #0
 727              	.L48:
 728              		.loc 1 887 0 discriminator 4
 729 003c 002B     		cmp	r3, #0
 730 003e 05D1     		bne	.L49
 731              		.loc 1 887 0 discriminator 5
 732              	@ 887 "../FreeRTOS_Source/queue.c" 1
 733 0040 4FF05000 			mov r0, #80								
 734 0044 80F31188 		msr basepri, r0							
 735              	
 736              	@ 0 "" 2
 737              		.thumb
 738              	.L50:
 739              		.loc 1 887 0 discriminator 6
 740 0048 FEE7     		b	.L50
 741              	.L64:
 888:../FreeRTOS_Source/queue.c **** 
 889:../FreeRTOS_Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 890:../FreeRTOS_Source/queue.c **** 	statements within the function itself.  This is done in the interest
 891:../FreeRTOS_Source/queue.c **** 	of execution time efficiency. */
 892:../FreeRTOS_Source/queue.c **** 
 893:../FreeRTOS_Source/queue.c **** 	for( ;; )
 894:../FreeRTOS_Source/queue.c **** 	{
 895:../FreeRTOS_Source/queue.c **** 		taskENTER_CRITICAL();
 896:../FreeRTOS_Source/queue.c **** 		{
 897:../FreeRTOS_Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 898:../FreeRTOS_Source/queue.c **** 			the highest priority task wanting to access the queue. */
 899:../FreeRTOS_Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 900:../FreeRTOS_Source/queue.c **** 			{
 901:../FreeRTOS_Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 902:../FreeRTOS_Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 903:../FreeRTOS_Source/queue.c **** 
 904:../FreeRTOS_Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 905:../FreeRTOS_Source/queue.c **** 
 906:../FreeRTOS_Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 907:../FreeRTOS_Source/queue.c **** 				{
 908:../FreeRTOS_Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 909:../FreeRTOS_Source/queue.c **** 
 910:../FreeRTOS_Source/queue.c **** 					/* We are actually removing data. */
 911:../FreeRTOS_Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 912:../FreeRTOS_Source/queue.c **** 
 913:../FreeRTOS_Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 914:../FreeRTOS_Source/queue.c **** 					{
 915:../FreeRTOS_Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 916:../FreeRTOS_Source/queue.c **** 						{
 917:../FreeRTOS_Source/queue.c **** 							/* Record the information required to implement
 918:../FreeRTOS_Source/queue.c **** 							priority inheritance should it become necessary. */
 919:../FreeRTOS_Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 920:../FreeRTOS_Source/queue.c **** 						}
 921:../FreeRTOS_Source/queue.c **** 					}
 922:../FreeRTOS_Source/queue.c **** 					#endif
 923:../FreeRTOS_Source/queue.c **** 
 924:../FreeRTOS_Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 925:../FreeRTOS_Source/queue.c **** 					{
 926:../FreeRTOS_Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 927:../FreeRTOS_Source/queue.c **** 						{
 928:../FreeRTOS_Source/queue.c **** 							portYIELD_WITHIN_API();
 929:../FreeRTOS_Source/queue.c **** 						}
 930:../FreeRTOS_Source/queue.c **** 					}
 931:../FreeRTOS_Source/queue.c **** 				}
 932:../FreeRTOS_Source/queue.c **** 				else
 933:../FreeRTOS_Source/queue.c **** 				{
 934:../FreeRTOS_Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 935:../FreeRTOS_Source/queue.c **** 
 936:../FreeRTOS_Source/queue.c **** 					/* We are not removing the data, so reset our read
 937:../FreeRTOS_Source/queue.c **** 					pointer. */
 938:../FreeRTOS_Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 939:../FreeRTOS_Source/queue.c **** 
 940:../FreeRTOS_Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 941:../FreeRTOS_Source/queue.c **** 					any other tasks waiting for the data. */
 942:../FreeRTOS_Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 943:../FreeRTOS_Source/queue.c **** 					{
 944:../FreeRTOS_Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 945:../FreeRTOS_Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 946:../FreeRTOS_Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 947:../FreeRTOS_Source/queue.c **** 						{
 948:../FreeRTOS_Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 949:../FreeRTOS_Source/queue.c **** 							portYIELD_WITHIN_API();
 950:../FreeRTOS_Source/queue.c **** 						}
 951:../FreeRTOS_Source/queue.c **** 					}
 952:../FreeRTOS_Source/queue.c **** 
 953:../FreeRTOS_Source/queue.c **** 				}
 954:../FreeRTOS_Source/queue.c **** 
 955:../FreeRTOS_Source/queue.c **** 				taskEXIT_CRITICAL();
 956:../FreeRTOS_Source/queue.c **** 				return pdPASS;
 957:../FreeRTOS_Source/queue.c **** 			}
 958:../FreeRTOS_Source/queue.c **** 			else
 959:../FreeRTOS_Source/queue.c **** 			{
 960:../FreeRTOS_Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 961:../FreeRTOS_Source/queue.c **** 				{
 962:../FreeRTOS_Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 963:../FreeRTOS_Source/queue.c **** 					the block time has expired) so leave now. */
 964:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 965:../FreeRTOS_Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:../FreeRTOS_Source/queue.c **** 					return errQUEUE_EMPTY;
 967:../FreeRTOS_Source/queue.c **** 				}
 968:../FreeRTOS_Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 969:../FreeRTOS_Source/queue.c **** 				{
 970:../FreeRTOS_Source/queue.c **** 					/* The queue was empty and a block time was specified so
 971:../FreeRTOS_Source/queue.c **** 					configure the timeout structure. */
 972:../FreeRTOS_Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 973:../FreeRTOS_Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 974:../FreeRTOS_Source/queue.c **** 				}
 975:../FreeRTOS_Source/queue.c **** 			}
 976:../FreeRTOS_Source/queue.c **** 		}
 977:../FreeRTOS_Source/queue.c **** 		taskEXIT_CRITICAL();
 978:../FreeRTOS_Source/queue.c **** 
 979:../FreeRTOS_Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 980:../FreeRTOS_Source/queue.c **** 		now the critical section has been exited. */
 981:../FreeRTOS_Source/queue.c **** 
 982:../FreeRTOS_Source/queue.c **** 		vTaskSuspendAll();
 983:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 984:../FreeRTOS_Source/queue.c **** 
 985:../FreeRTOS_Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 986:../FreeRTOS_Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 987:../FreeRTOS_Source/queue.c **** 		{
 988:../FreeRTOS_Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 989:../FreeRTOS_Source/queue.c **** 			{
 990:../FreeRTOS_Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 991:../FreeRTOS_Source/queue.c **** 
 992:../FreeRTOS_Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:../FreeRTOS_Source/queue.c **** 				{
 994:../FreeRTOS_Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 995:../FreeRTOS_Source/queue.c **** 					{
 996:../FreeRTOS_Source/queue.c **** 						portENTER_CRITICAL();
 997:../FreeRTOS_Source/queue.c **** 						{
 998:../FreeRTOS_Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 999:../FreeRTOS_Source/queue.c **** 						}
1000:../FreeRTOS_Source/queue.c **** 						portEXIT_CRITICAL();
1001:../FreeRTOS_Source/queue.c **** 					}
1002:../FreeRTOS_Source/queue.c **** 				}
1003:../FreeRTOS_Source/queue.c **** 				#endif
1004:../FreeRTOS_Source/queue.c **** 
1005:../FreeRTOS_Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1006:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
1007:../FreeRTOS_Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1008:../FreeRTOS_Source/queue.c **** 				{
1009:../FreeRTOS_Source/queue.c **** 					portYIELD_WITHIN_API();
1010:../FreeRTOS_Source/queue.c **** 				}
1011:../FreeRTOS_Source/queue.c **** 			}
1012:../FreeRTOS_Source/queue.c **** 			else
1013:../FreeRTOS_Source/queue.c **** 			{
1014:../FreeRTOS_Source/queue.c **** 				/* Try again. */
1015:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
1016:../FreeRTOS_Source/queue.c **** 				( void ) xTaskResumeAll();
1017:../FreeRTOS_Source/queue.c **** 			}
1018:../FreeRTOS_Source/queue.c **** 		}
1019:../FreeRTOS_Source/queue.c **** 		else
1020:../FreeRTOS_Source/queue.c **** 		{
1021:../FreeRTOS_Source/queue.c **** 			prvUnlockQueue( pxQueue );
1022:../FreeRTOS_Source/queue.c **** 			( void ) xTaskResumeAll();
1023:../FreeRTOS_Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1024:../FreeRTOS_Source/queue.c **** 			return errQUEUE_EMPTY;
1025:../FreeRTOS_Source/queue.c **** 		}
1026:../FreeRTOS_Source/queue.c **** 	}
 742              		.loc 1 1026 0 is_stmt 1
 743 004a 00BF     		nop
 744              	.L49:
 895:../FreeRTOS_Source/queue.c **** 		taskENTER_CRITICAL();
 745              		.loc 1 895 0
 746 004c FFF7FEFF 		bl	vPortEnterCritical
 899:../FreeRTOS_Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 747              		.loc 1 899 0
 748 0050 FB68     		ldr	r3, [r7, #12]
 749 0052 9B6B     		ldr	r3, [r3, #56]
 750 0054 002B     		cmp	r3, #0
 751 0056 3FD0     		beq	.L51
 902:../FreeRTOS_Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 752              		.loc 1 902 0
 753 0058 FB68     		ldr	r3, [r7, #12]
 754 005a DB68     		ldr	r3, [r3, #12]
 755 005c BB61     		str	r3, [r7, #24]
 904:../FreeRTOS_Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 756              		.loc 1 904 0
 757 005e F868     		ldr	r0, [r7, #12]
 758 0060 B968     		ldr	r1, [r7, #8]
 759 0062 FFF7FEFF 		bl	prvCopyDataFromQueue
 906:../FreeRTOS_Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 760              		.loc 1 906 0
 761 0066 3B68     		ldr	r3, [r7, #0]
 762 0068 002B     		cmp	r3, #0
 763 006a 1ED1     		bne	.L52
 911:../FreeRTOS_Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 764              		.loc 1 911 0
 765 006c FB68     		ldr	r3, [r7, #12]
 766 006e 9B6B     		ldr	r3, [r3, #56]
 767 0070 03F1FF32 		add	r2, r3, #-1
 768 0074 FB68     		ldr	r3, [r7, #12]
 769 0076 9A63     		str	r2, [r3, #56]
 915:../FreeRTOS_Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 770              		.loc 1 915 0
 771 0078 FB68     		ldr	r3, [r7, #12]
 772 007a 1B68     		ldr	r3, [r3, #0]
 773 007c 002B     		cmp	r3, #0
 774 007e 04D1     		bne	.L53
 919:../FreeRTOS_Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 775              		.loc 1 919 0
 776 0080 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 777 0084 0246     		mov	r2, r0
 778 0086 FB68     		ldr	r3, [r7, #12]
 779 0088 5A60     		str	r2, [r3, #4]
 780              	.L53:
 924:../FreeRTOS_Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 781              		.loc 1 924 0
 782 008a FB68     		ldr	r3, [r7, #12]
 783 008c 1B69     		ldr	r3, [r3, #16]
 784 008e 002B     		cmp	r3, #0
 785 0090 1DD0     		beq	.L54
 926:../FreeRTOS_Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 786              		.loc 1 926 0
 787 0092 FB68     		ldr	r3, [r7, #12]
 788 0094 03F11003 		add	r3, r3, #16
 789 0098 1846     		mov	r0, r3
 790 009a FFF7FEFF 		bl	xTaskRemoveFromEventList
 791 009e 0346     		mov	r3, r0
 792 00a0 012B     		cmp	r3, #1
 793 00a2 14D1     		bne	.L54
 928:../FreeRTOS_Source/queue.c **** 							portYIELD_WITHIN_API();
 794              		.loc 1 928 0
 795 00a4 FFF7FEFF 		bl	vPortYieldFromISR
 796 00a8 11E0     		b	.L54
 797              	.L52:
 938:../FreeRTOS_Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 798              		.loc 1 938 0
 799 00aa FB68     		ldr	r3, [r7, #12]
 800 00ac BA69     		ldr	r2, [r7, #24]
 801 00ae DA60     		str	r2, [r3, #12]
 942:../FreeRTOS_Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 802              		.loc 1 942 0
 803 00b0 FB68     		ldr	r3, [r7, #12]
 804 00b2 5B6A     		ldr	r3, [r3, #36]
 805 00b4 002B     		cmp	r3, #0
 806 00b6 0AD0     		beq	.L54
 946:../FreeRTOS_Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 807              		.loc 1 946 0
 808 00b8 FB68     		ldr	r3, [r7, #12]
 809 00ba 03F12403 		add	r3, r3, #36
 810 00be 1846     		mov	r0, r3
 811 00c0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 812 00c4 0346     		mov	r3, r0
 813 00c6 002B     		cmp	r3, #0
 814 00c8 01D0     		beq	.L54
 949:../FreeRTOS_Source/queue.c **** 							portYIELD_WITHIN_API();
 815              		.loc 1 949 0
 816 00ca FFF7FEFF 		bl	vPortYieldFromISR
 817              	.L54:
 955:../FreeRTOS_Source/queue.c **** 				taskEXIT_CRITICAL();
 818              		.loc 1 955 0
 819 00ce FFF7FEFF 		bl	vPortExitCritical
 956:../FreeRTOS_Source/queue.c **** 				return pdPASS;
 820              		.loc 1 956 0
 821 00d2 4FF00103 		mov	r3, #1
 822 00d6 6BE0     		b	.L55
 823              	.L51:
 960:../FreeRTOS_Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 824              		.loc 1 960 0
 825 00d8 7B68     		ldr	r3, [r7, #4]
 826 00da 002B     		cmp	r3, #0
 827 00dc 04D1     		bne	.L56
 964:../FreeRTOS_Source/queue.c **** 					taskEXIT_CRITICAL();
 828              		.loc 1 964 0
 829 00de FFF7FEFF 		bl	vPortExitCritical
 966:../FreeRTOS_Source/queue.c **** 					return errQUEUE_EMPTY;
 830              		.loc 1 966 0
 831 00e2 4FF00003 		mov	r3, #0
 832 00e6 63E0     		b	.L55
 833              	.L56:
 968:../FreeRTOS_Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 834              		.loc 1 968 0
 835 00e8 FB69     		ldr	r3, [r7, #28]
 836 00ea 002B     		cmp	r3, #0
 837 00ec 07D1     		bne	.L57
 972:../FreeRTOS_Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 838              		.loc 1 972 0
 839 00ee 07F11003 		add	r3, r7, #16
 840 00f2 1846     		mov	r0, r3
 841 00f4 FFF7FEFF 		bl	vTaskSetTimeOutState
 973:../FreeRTOS_Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 842              		.loc 1 973 0
 843 00f8 4FF00103 		mov	r3, #1
 844 00fc FB61     		str	r3, [r7, #28]
 845              	.L57:
 977:../FreeRTOS_Source/queue.c **** 		taskEXIT_CRITICAL();
 846              		.loc 1 977 0
 847 00fe FFF7FEFF 		bl	vPortExitCritical
 982:../FreeRTOS_Source/queue.c **** 		vTaskSuspendAll();
 848              		.loc 1 982 0
 849 0102 FFF7FEFF 		bl	vTaskSuspendAll
 983:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 850              		.loc 1 983 0
 851 0106 FFF7FEFF 		bl	vPortEnterCritical
 852 010a FB68     		ldr	r3, [r7, #12]
 853 010c 5B6C     		ldr	r3, [r3, #68]
 854 010e B3F1FF3F 		cmp	r3, #-1
 855 0112 03D1     		bne	.L58
 983:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 856              		.loc 1 983 0 is_stmt 0 discriminator 1
 857 0114 FB68     		ldr	r3, [r7, #12]
 858 0116 4FF00002 		mov	r2, #0
 859 011a 5A64     		str	r2, [r3, #68]
 860              	.L58:
 983:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 861              		.loc 1 983 0 discriminator 2
 862 011c FB68     		ldr	r3, [r7, #12]
 863 011e 9B6C     		ldr	r3, [r3, #72]
 864 0120 B3F1FF3F 		cmp	r3, #-1
 865 0124 03D1     		bne	.L59
 983:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 866              		.loc 1 983 0 discriminator 3
 867 0126 FB68     		ldr	r3, [r7, #12]
 868 0128 4FF00002 		mov	r2, #0
 869 012c 9A64     		str	r2, [r3, #72]
 870              	.L59:
 983:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 871              		.loc 1 983 0 discriminator 4
 872 012e FFF7FEFF 		bl	vPortExitCritical
 986:../FreeRTOS_Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 873              		.loc 1 986 0 is_stmt 1 discriminator 4
 874 0132 07F11002 		add	r2, r7, #16
 875 0136 07F10403 		add	r3, r7, #4
 876 013a 1046     		mov	r0, r2
 877 013c 1946     		mov	r1, r3
 878 013e FFF7FEFF 		bl	xTaskCheckForTimeOut
 879 0142 0346     		mov	r3, r0
 880 0144 002B     		cmp	r3, #0
 881 0146 2CD1     		bne	.L60
 988:../FreeRTOS_Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 882              		.loc 1 988 0
 883 0148 F868     		ldr	r0, [r7, #12]
 884 014a FFF7FEFF 		bl	prvIsQueueEmpty
 885 014e 0346     		mov	r3, r0
 886 0150 002B     		cmp	r3, #0
 887 0152 20D0     		beq	.L61
 994:../FreeRTOS_Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 888              		.loc 1 994 0
 889 0154 FB68     		ldr	r3, [r7, #12]
 890 0156 1B68     		ldr	r3, [r3, #0]
 891 0158 002B     		cmp	r3, #0
 892 015a 08D1     		bne	.L62
 996:../FreeRTOS_Source/queue.c **** 						portENTER_CRITICAL();
 893              		.loc 1 996 0
 894 015c FFF7FEFF 		bl	vPortEnterCritical
 998:../FreeRTOS_Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 895              		.loc 1 998 0
 896 0160 FB68     		ldr	r3, [r7, #12]
 897 0162 5B68     		ldr	r3, [r3, #4]
 898 0164 1846     		mov	r0, r3
 899 0166 FFF7FEFF 		bl	vTaskPriorityInherit
1000:../FreeRTOS_Source/queue.c **** 						portEXIT_CRITICAL();
 900              		.loc 1 1000 0
 901 016a FFF7FEFF 		bl	vPortExitCritical
 902              	.L62:
1005:../FreeRTOS_Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 903              		.loc 1 1005 0
 904 016e FB68     		ldr	r3, [r7, #12]
 905 0170 03F12402 		add	r2, r3, #36
 906 0174 7B68     		ldr	r3, [r7, #4]
 907 0176 1046     		mov	r0, r2
 908 0178 1946     		mov	r1, r3
 909 017a FFF7FEFF 		bl	vTaskPlaceOnEventList
1006:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
 910              		.loc 1 1006 0
 911 017e F868     		ldr	r0, [r7, #12]
 912 0180 FFF7FEFF 		bl	prvUnlockQueue
1007:../FreeRTOS_Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 913              		.loc 1 1007 0
 914 0184 FFF7FEFF 		bl	xTaskResumeAll
 915 0188 0346     		mov	r3, r0
 916 018a 002B     		cmp	r3, #0
 917 018c 7FF45DAF 		bne	.L64
1009:../FreeRTOS_Source/queue.c **** 					portYIELD_WITHIN_API();
 918              		.loc 1 1009 0
 919 0190 FFF7FEFF 		bl	vPortYieldFromISR
 920              		.loc 1 1026 0
 921 0194 59E7     		b	.L64
 922              	.L61:
1015:../FreeRTOS_Source/queue.c **** 				prvUnlockQueue( pxQueue );
 923              		.loc 1 1015 0
 924 0196 F868     		ldr	r0, [r7, #12]
 925 0198 FFF7FEFF 		bl	prvUnlockQueue
1016:../FreeRTOS_Source/queue.c **** 				( void ) xTaskResumeAll();
 926              		.loc 1 1016 0
 927 019c FFF7FEFF 		bl	xTaskResumeAll
 928              		.loc 1 1026 0
 929 01a0 53E7     		b	.L64
 930              	.L60:
1021:../FreeRTOS_Source/queue.c **** 			prvUnlockQueue( pxQueue );
 931              		.loc 1 1021 0
 932 01a2 F868     		ldr	r0, [r7, #12]
 933 01a4 FFF7FEFF 		bl	prvUnlockQueue
1022:../FreeRTOS_Source/queue.c **** 			( void ) xTaskResumeAll();
 934              		.loc 1 1022 0
 935 01a8 FFF7FEFF 		bl	xTaskResumeAll
1024:../FreeRTOS_Source/queue.c **** 			return errQUEUE_EMPTY;
 936              		.loc 1 1024 0
 937 01ac 4FF00003 		mov	r3, #0
 938              	.L55:
1027:../FreeRTOS_Source/queue.c **** }
 939              		.loc 1 1027 0
 940 01b0 1846     		mov	r0, r3
 941 01b2 07F12007 		add	r7, r7, #32
 942 01b6 BD46     		mov	sp, r7
 943 01b8 80BD     		pop	{r7, pc}
 944              		.cfi_endproc
 945              	.LFE4:
 947 01ba 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 948              		.align	2
 949              		.global	xQueueReceiveFromISR
 950              		.thumb
 951              		.thumb_func
 953              	xQueueReceiveFromISR:
 954              	.LFB5:
1028:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1029:../FreeRTOS_Source/queue.c **** 
1030:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1031:../FreeRTOS_Source/queue.c **** {
 955              		.loc 1 1031 0
 956              		.cfi_startproc
 957              		@ args = 0, pretend = 0, frame = 24
 958              		@ frame_needed = 1, uses_anonymous_args = 0
 959 0000 80B5     		push	{r7, lr}
 960              	.LCFI15:
 961              		.cfi_def_cfa_offset 8
 962              		.cfi_offset 14, -4
 963              		.cfi_offset 7, -8
 964 0002 86B0     		sub	sp, sp, #24
 965              	.LCFI16:
 966              		.cfi_def_cfa_offset 32
 967 0004 00AF     		add	r7, sp, #0
 968              	.LCFI17:
 969              		.cfi_def_cfa_register 7
 970 0006 F860     		str	r0, [r7, #12]
 971 0008 B960     		str	r1, [r7, #8]
 972 000a 7A60     		str	r2, [r7, #4]
1032:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1033:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1034:../FreeRTOS_Source/queue.c **** 
1035:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 973              		.loc 1 1035 0
 974 000c FB68     		ldr	r3, [r7, #12]
 975 000e 002B     		cmp	r3, #0
 976 0010 04D1     		bne	.L66
 977              		.loc 1 1035 0 is_stmt 0 discriminator 1
 978              	@ 1035 "../FreeRTOS_Source/queue.c" 1
 979 0012 4FF05000 			mov r0, #80								
 980 0016 80F31188 		msr basepri, r0							
 981              	
 982              	@ 0 "" 2
 983              		.thumb
 984              	.L67:
 985              		.loc 1 1035 0 discriminator 2
 986 001a FEE7     		b	.L67
 987              	.L66:
1036:../FreeRTOS_Source/queue.c **** 	configASSERT( pxTaskWoken );
 988              		.loc 1 1036 0 is_stmt 1
 989 001c 7B68     		ldr	r3, [r7, #4]
 990 001e 002B     		cmp	r3, #0
 991 0020 04D1     		bne	.L68
 992              		.loc 1 1036 0 is_stmt 0 discriminator 1
 993              	@ 1036 "../FreeRTOS_Source/queue.c" 1
 994 0022 4FF05000 			mov r0, #80								
 995 0026 80F31188 		msr basepri, r0							
 996              	
 997              	@ 0 "" 2
 998              		.thumb
 999              	.L69:
 1000              		.loc 1 1036 0 discriminator 2
 1001 002a FEE7     		b	.L69
 1002              	.L68:
1037:../FreeRTOS_Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1003              		.loc 1 1037 0 is_stmt 1
 1004 002c BB68     		ldr	r3, [r7, #8]
 1005 002e 002B     		cmp	r3, #0
 1006 0030 03D1     		bne	.L70
 1007              		.loc 1 1037 0 is_stmt 0 discriminator 2
 1008 0032 FB68     		ldr	r3, [r7, #12]
 1009 0034 1B6C     		ldr	r3, [r3, #64]
 1010 0036 002B     		cmp	r3, #0
 1011 0038 02D1     		bne	.L71
 1012              	.L70:
 1013              		.loc 1 1037 0 discriminator 1
 1014 003a 4FF00103 		mov	r3, #1
 1015 003e 01E0     		b	.L72
 1016              	.L71:
 1017              		.loc 1 1037 0 discriminator 3
 1018 0040 4FF00003 		mov	r3, #0
 1019              	.L72:
 1020              		.loc 1 1037 0 discriminator 4
 1021 0044 002B     		cmp	r3, #0
 1022 0046 04D1     		bne	.L73
 1023              		.loc 1 1037 0 discriminator 5
 1024              	@ 1037 "../FreeRTOS_Source/queue.c" 1
 1025 0048 4FF05000 			mov r0, #80								
 1026 004c 80F31188 		msr basepri, r0							
 1027              	
 1028              	@ 0 "" 2
 1029              		.thumb
 1030              	.L74:
 1031              		.loc 1 1037 0 discriminator 6
 1032 0050 FEE7     		b	.L74
 1033              	.L73:
1038:../FreeRTOS_Source/queue.c **** 
1039:../FreeRTOS_Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1034              		.loc 1 1039 0 is_stmt 1
 1035 0052 4FF00003 		mov	r3, #0
 1036 0056 3B61     		str	r3, [r7, #16]
 1037              	@ 1039 "../FreeRTOS_Source/queue.c" 1
 1038 0058 4FF05000 			mov r0, #80								
 1039 005c 80F31188 		msr basepri, r0							
 1040              	
 1041              	@ 0 "" 2
1040:../FreeRTOS_Source/queue.c **** 	{
1041:../FreeRTOS_Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1042:../FreeRTOS_Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1042              		.loc 1 1042 0
 1043              		.thumb
 1044 0060 FB68     		ldr	r3, [r7, #12]
 1045 0062 9B6B     		ldr	r3, [r3, #56]
 1046 0064 002B     		cmp	r3, #0
 1047 0066 2AD0     		beq	.L75
1043:../FreeRTOS_Source/queue.c **** 		{
1044:../FreeRTOS_Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1045:../FreeRTOS_Source/queue.c **** 
1046:../FreeRTOS_Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1048              		.loc 1 1046 0
 1049 0068 F868     		ldr	r0, [r7, #12]
 1050 006a B968     		ldr	r1, [r7, #8]
 1051 006c FFF7FEFF 		bl	prvCopyDataFromQueue
1047:../FreeRTOS_Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1052              		.loc 1 1047 0
 1053 0070 FB68     		ldr	r3, [r7, #12]
 1054 0072 9B6B     		ldr	r3, [r3, #56]
 1055 0074 03F1FF32 		add	r2, r3, #-1
 1056 0078 FB68     		ldr	r3, [r7, #12]
 1057 007a 9A63     		str	r2, [r3, #56]
1048:../FreeRTOS_Source/queue.c **** 
1049:../FreeRTOS_Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1050:../FreeRTOS_Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1051:../FreeRTOS_Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1052:../FreeRTOS_Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1058              		.loc 1 1052 0
 1059 007c FB68     		ldr	r3, [r7, #12]
 1060 007e 5B6C     		ldr	r3, [r3, #68]
 1061 0080 B3F1FF3F 		cmp	r3, #-1
 1062 0084 11D1     		bne	.L76
1053:../FreeRTOS_Source/queue.c **** 			{
1054:../FreeRTOS_Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1063              		.loc 1 1054 0
 1064 0086 FB68     		ldr	r3, [r7, #12]
 1065 0088 1B69     		ldr	r3, [r3, #16]
 1066 008a 002B     		cmp	r3, #0
 1067 008c 13D0     		beq	.L77
1055:../FreeRTOS_Source/queue.c **** 				{
1056:../FreeRTOS_Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1068              		.loc 1 1056 0
 1069 008e FB68     		ldr	r3, [r7, #12]
 1070 0090 03F11003 		add	r3, r3, #16
 1071 0094 1846     		mov	r0, r3
 1072 0096 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1073 009a 0346     		mov	r3, r0
 1074 009c 002B     		cmp	r3, #0
 1075 009e 0AD0     		beq	.L77
1057:../FreeRTOS_Source/queue.c **** 					{
1058:../FreeRTOS_Source/queue.c **** 						/* The task waiting has a higher priority than us so
1059:../FreeRTOS_Source/queue.c **** 						force a context switch. */
1060:../FreeRTOS_Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 1076              		.loc 1 1060 0
 1077 00a0 7B68     		ldr	r3, [r7, #4]
 1078 00a2 4FF00102 		mov	r2, #1
 1079 00a6 1A60     		str	r2, [r3, #0]
 1080 00a8 05E0     		b	.L77
 1081              	.L76:
1061:../FreeRTOS_Source/queue.c **** 					}
1062:../FreeRTOS_Source/queue.c **** 				}
1063:../FreeRTOS_Source/queue.c **** 			}
1064:../FreeRTOS_Source/queue.c **** 			else
1065:../FreeRTOS_Source/queue.c **** 			{
1066:../FreeRTOS_Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1067:../FreeRTOS_Source/queue.c **** 				knows that data was removed while it was locked. */
1068:../FreeRTOS_Source/queue.c **** 				++( pxQueue->xRxLock );
 1082              		.loc 1 1068 0
 1083 00aa FB68     		ldr	r3, [r7, #12]
 1084 00ac 5B6C     		ldr	r3, [r3, #68]
 1085 00ae 03F10102 		add	r2, r3, #1
 1086 00b2 FB68     		ldr	r3, [r7, #12]
 1087 00b4 5A64     		str	r2, [r3, #68]
 1088              	.L77:
1069:../FreeRTOS_Source/queue.c **** 			}
1070:../FreeRTOS_Source/queue.c **** 
1071:../FreeRTOS_Source/queue.c **** 			xReturn = pdPASS;
 1089              		.loc 1 1071 0
 1090 00b6 4FF00103 		mov	r3, #1
 1091 00ba 7B61     		str	r3, [r7, #20]
 1092 00bc 02E0     		b	.L78
 1093              	.L75:
1072:../FreeRTOS_Source/queue.c **** 		}
1073:../FreeRTOS_Source/queue.c **** 		else
1074:../FreeRTOS_Source/queue.c **** 		{
1075:../FreeRTOS_Source/queue.c **** 			xReturn = pdFAIL;
 1094              		.loc 1 1075 0
 1095 00be 4FF00003 		mov	r3, #0
 1096 00c2 7B61     		str	r3, [r7, #20]
 1097              	.L78:
1076:../FreeRTOS_Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1077:../FreeRTOS_Source/queue.c **** 		}
1078:../FreeRTOS_Source/queue.c **** 	}
1079:../FreeRTOS_Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1098              		.loc 1 1079 0
 1099              	@ 1079 "../FreeRTOS_Source/queue.c" 1
 1100 00c4 4FF00000 			mov r0, #0					
 1101 00c8 80F31188 		msr basepri, r0				
 1102              	
 1103              	@ 0 "" 2
1080:../FreeRTOS_Source/queue.c **** 
1081:../FreeRTOS_Source/queue.c **** 	return xReturn;
 1104              		.loc 1 1081 0
 1105              		.thumb
 1106 00cc 7B69     		ldr	r3, [r7, #20]
1082:../FreeRTOS_Source/queue.c **** }
 1107              		.loc 1 1082 0
 1108 00ce 1846     		mov	r0, r3
 1109 00d0 07F11807 		add	r7, r7, #24
 1110 00d4 BD46     		mov	sp, r7
 1111 00d6 80BD     		pop	{r7, pc}
 1112              		.cfi_endproc
 1113              	.LFE5:
 1115              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1116              		.align	2
 1117              		.global	uxQueueMessagesWaiting
 1118              		.thumb
 1119              		.thumb_func
 1121              	uxQueueMessagesWaiting:
 1122              	.LFB6:
1083:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1084:../FreeRTOS_Source/queue.c **** 
1085:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1086:../FreeRTOS_Source/queue.c **** {
 1123              		.loc 1 1086 0
 1124              		.cfi_startproc
 1125              		@ args = 0, pretend = 0, frame = 16
 1126              		@ frame_needed = 1, uses_anonymous_args = 0
 1127 0000 80B5     		push	{r7, lr}
 1128              	.LCFI18:
 1129              		.cfi_def_cfa_offset 8
 1130              		.cfi_offset 14, -4
 1131              		.cfi_offset 7, -8
 1132 0002 84B0     		sub	sp, sp, #16
 1133              	.LCFI19:
 1134              		.cfi_def_cfa_offset 24
 1135 0004 00AF     		add	r7, sp, #0
 1136              	.LCFI20:
 1137              		.cfi_def_cfa_register 7
 1138 0006 7860     		str	r0, [r7, #4]
1087:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1088:../FreeRTOS_Source/queue.c **** 
1089:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 1139              		.loc 1 1089 0
 1140 0008 7B68     		ldr	r3, [r7, #4]
 1141 000a 002B     		cmp	r3, #0
 1142 000c 04D1     		bne	.L80
 1143              		.loc 1 1089 0 is_stmt 0 discriminator 1
 1144              	@ 1089 "../FreeRTOS_Source/queue.c" 1
 1145 000e 4FF05000 			mov r0, #80								
 1146 0012 80F31188 		msr basepri, r0							
 1147              	
 1148              	@ 0 "" 2
 1149              		.thumb
 1150              	.L81:
 1151              		.loc 1 1089 0 discriminator 2
 1152 0016 FEE7     		b	.L81
 1153              	.L80:
1090:../FreeRTOS_Source/queue.c **** 
1091:../FreeRTOS_Source/queue.c **** 	taskENTER_CRITICAL();
 1154              		.loc 1 1091 0 is_stmt 1
 1155 0018 FFF7FEFF 		bl	vPortEnterCritical
1092:../FreeRTOS_Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 1156              		.loc 1 1092 0
 1157 001c 7B68     		ldr	r3, [r7, #4]
 1158 001e 9B6B     		ldr	r3, [r3, #56]
 1159 0020 FB60     		str	r3, [r7, #12]
1093:../FreeRTOS_Source/queue.c **** 	taskEXIT_CRITICAL();
 1160              		.loc 1 1093 0
 1161 0022 FFF7FEFF 		bl	vPortExitCritical
1094:../FreeRTOS_Source/queue.c **** 
1095:../FreeRTOS_Source/queue.c **** 	return uxReturn;
 1162              		.loc 1 1095 0
 1163 0026 FB68     		ldr	r3, [r7, #12]
1096:../FreeRTOS_Source/queue.c **** }
 1164              		.loc 1 1096 0
 1165 0028 1846     		mov	r0, r3
 1166 002a 07F11007 		add	r7, r7, #16
 1167 002e BD46     		mov	sp, r7
 1168 0030 80BD     		pop	{r7, pc}
 1169              		.cfi_endproc
 1170              	.LFE6:
 1172 0032 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1173              		.align	2
 1174              		.global	uxQueueMessagesWaitingFromISR
 1175              		.thumb
 1176              		.thumb_func
 1178              	uxQueueMessagesWaitingFromISR:
 1179              	.LFB7:
1097:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1098:../FreeRTOS_Source/queue.c **** 
1099:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1100:../FreeRTOS_Source/queue.c **** {
 1180              		.loc 1 1100 0
 1181              		.cfi_startproc
 1182              		@ args = 0, pretend = 0, frame = 16
 1183              		@ frame_needed = 1, uses_anonymous_args = 0
 1184              		@ link register save eliminated.
 1185 0000 80B4     		push	{r7}
 1186              	.LCFI21:
 1187              		.cfi_def_cfa_offset 4
 1188              		.cfi_offset 7, -4
 1189 0002 85B0     		sub	sp, sp, #20
 1190              	.LCFI22:
 1191              		.cfi_def_cfa_offset 24
 1192 0004 00AF     		add	r7, sp, #0
 1193              	.LCFI23:
 1194              		.cfi_def_cfa_register 7
 1195 0006 7860     		str	r0, [r7, #4]
1101:../FreeRTOS_Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1102:../FreeRTOS_Source/queue.c **** 
1103:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 1196              		.loc 1 1103 0
 1197 0008 7B68     		ldr	r3, [r7, #4]
 1198 000a 002B     		cmp	r3, #0
 1199 000c 04D1     		bne	.L83
 1200              		.loc 1 1103 0 is_stmt 0 discriminator 1
 1201              	@ 1103 "../FreeRTOS_Source/queue.c" 1
 1202 000e 4FF05000 			mov r0, #80								
 1203 0012 80F31188 		msr basepri, r0							
 1204              	
 1205              	@ 0 "" 2
 1206              		.thumb
 1207              	.L84:
 1208              		.loc 1 1103 0 discriminator 2
 1209 0016 FEE7     		b	.L84
 1210              	.L83:
1104:../FreeRTOS_Source/queue.c **** 
1105:../FreeRTOS_Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 1211              		.loc 1 1105 0 is_stmt 1
 1212 0018 7B68     		ldr	r3, [r7, #4]
 1213 001a 9B6B     		ldr	r3, [r3, #56]
 1214 001c FB60     		str	r3, [r7, #12]
1106:../FreeRTOS_Source/queue.c **** 
1107:../FreeRTOS_Source/queue.c **** 	return uxReturn;
 1215              		.loc 1 1107 0
 1216 001e FB68     		ldr	r3, [r7, #12]
1108:../FreeRTOS_Source/queue.c **** }
 1217              		.loc 1 1108 0
 1218 0020 1846     		mov	r0, r3
 1219 0022 07F11407 		add	r7, r7, #20
 1220 0026 BD46     		mov	sp, r7
 1221 0028 80BC     		pop	{r7}
 1222 002a 7047     		bx	lr
 1223              		.cfi_endproc
 1224              	.LFE7:
 1226              		.section	.text.vQueueDelete,"ax",%progbits
 1227              		.align	2
 1228              		.global	vQueueDelete
 1229              		.thumb
 1230              		.thumb_func
 1232              	vQueueDelete:
 1233              	.LFB8:
1109:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1110:../FreeRTOS_Source/queue.c **** 
1111:../FreeRTOS_Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1112:../FreeRTOS_Source/queue.c **** {
 1234              		.loc 1 1112 0
 1235              		.cfi_startproc
 1236              		@ args = 0, pretend = 0, frame = 8
 1237              		@ frame_needed = 1, uses_anonymous_args = 0
 1238 0000 80B5     		push	{r7, lr}
 1239              	.LCFI24:
 1240              		.cfi_def_cfa_offset 8
 1241              		.cfi_offset 14, -4
 1242              		.cfi_offset 7, -8
 1243 0002 82B0     		sub	sp, sp, #8
 1244              	.LCFI25:
 1245              		.cfi_def_cfa_offset 16
 1246 0004 00AF     		add	r7, sp, #0
 1247              	.LCFI26:
 1248              		.cfi_def_cfa_register 7
 1249 0006 7860     		str	r0, [r7, #4]
1113:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 1250              		.loc 1 1113 0
 1251 0008 7B68     		ldr	r3, [r7, #4]
 1252 000a 002B     		cmp	r3, #0
 1253 000c 04D1     		bne	.L86
 1254              		.loc 1 1113 0 is_stmt 0 discriminator 1
 1255              	@ 1113 "../FreeRTOS_Source/queue.c" 1
 1256 000e 4FF05000 			mov r0, #80								
 1257 0012 80F31188 		msr basepri, r0							
 1258              	
 1259              	@ 0 "" 2
 1260              		.thumb
 1261              	.L87:
 1262              		.loc 1 1113 0 discriminator 2
 1263 0016 FEE7     		b	.L87
 1264              	.L86:
1114:../FreeRTOS_Source/queue.c **** 
1115:../FreeRTOS_Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1116:../FreeRTOS_Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1117:../FreeRTOS_Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 1265              		.loc 1 1117 0 is_stmt 1
 1266 0018 7B68     		ldr	r3, [r7, #4]
 1267 001a 1B68     		ldr	r3, [r3, #0]
 1268 001c 1846     		mov	r0, r3
 1269 001e FFF7FEFF 		bl	vPortFree
1118:../FreeRTOS_Source/queue.c **** 	vPortFree( pxQueue );
 1270              		.loc 1 1118 0
 1271 0022 7868     		ldr	r0, [r7, #4]
 1272 0024 FFF7FEFF 		bl	vPortFree
1119:../FreeRTOS_Source/queue.c **** }
 1273              		.loc 1 1119 0
 1274 0028 07F10807 		add	r7, r7, #8
 1275 002c BD46     		mov	sp, r7
 1276 002e 80BD     		pop	{r7, pc}
 1277              		.cfi_endproc
 1278              	.LFE8:
 1280              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1281              		.align	2
 1282              		.thumb
 1283              		.thumb_func
 1285              	prvCopyDataToQueue:
 1286              	.LFB9:
1120:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1121:../FreeRTOS_Source/queue.c **** 
1122:../FreeRTOS_Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1123:../FreeRTOS_Source/queue.c **** 
1124:../FreeRTOS_Source/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
1125:../FreeRTOS_Source/queue.c **** 	{
1126:../FreeRTOS_Source/queue.c **** 		return pxQueue->ucQueueNumber;
1127:../FreeRTOS_Source/queue.c **** 	}
1128:../FreeRTOS_Source/queue.c **** 
1129:../FreeRTOS_Source/queue.c **** #endif
1130:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1131:../FreeRTOS_Source/queue.c **** 
1132:../FreeRTOS_Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1133:../FreeRTOS_Source/queue.c **** 
1134:../FreeRTOS_Source/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
1135:../FreeRTOS_Source/queue.c **** 	{
1136:../FreeRTOS_Source/queue.c **** 		pxQueue->ucQueueNumber = ucQueueNumber;
1137:../FreeRTOS_Source/queue.c **** 	}
1138:../FreeRTOS_Source/queue.c **** 
1139:../FreeRTOS_Source/queue.c **** #endif
1140:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1141:../FreeRTOS_Source/queue.c **** 
1142:../FreeRTOS_Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1143:../FreeRTOS_Source/queue.c **** 
1144:../FreeRTOS_Source/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
1145:../FreeRTOS_Source/queue.c **** 	{
1146:../FreeRTOS_Source/queue.c **** 		return pxQueue->ucQueueType;
1147:../FreeRTOS_Source/queue.c **** 	}
1148:../FreeRTOS_Source/queue.c **** 
1149:../FreeRTOS_Source/queue.c **** #endif
1150:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1151:../FreeRTOS_Source/queue.c **** 
1152:../FreeRTOS_Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1153:../FreeRTOS_Source/queue.c **** {
 1287              		.loc 1 1153 0
 1288              		.cfi_startproc
 1289              		@ args = 0, pretend = 0, frame = 16
 1290              		@ frame_needed = 1, uses_anonymous_args = 0
 1291 0000 80B5     		push	{r7, lr}
 1292              	.LCFI27:
 1293              		.cfi_def_cfa_offset 8
 1294              		.cfi_offset 14, -4
 1295              		.cfi_offset 7, -8
 1296 0002 84B0     		sub	sp, sp, #16
 1297              	.LCFI28:
 1298              		.cfi_def_cfa_offset 24
 1299 0004 00AF     		add	r7, sp, #0
 1300              	.LCFI29:
 1301              		.cfi_def_cfa_register 7
 1302 0006 F860     		str	r0, [r7, #12]
 1303 0008 B960     		str	r1, [r7, #8]
 1304 000a 7A60     		str	r2, [r7, #4]
1154:../FreeRTOS_Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1305              		.loc 1 1154 0
 1306 000c FB68     		ldr	r3, [r7, #12]
 1307 000e 1B6C     		ldr	r3, [r3, #64]
 1308 0010 002B     		cmp	r3, #0
 1309 0012 0DD1     		bne	.L89
1155:../FreeRTOS_Source/queue.c **** 	{
1156:../FreeRTOS_Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1157:../FreeRTOS_Source/queue.c **** 		{
1158:../FreeRTOS_Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1310              		.loc 1 1158 0
 1311 0014 FB68     		ldr	r3, [r7, #12]
 1312 0016 1B68     		ldr	r3, [r3, #0]
 1313 0018 002B     		cmp	r3, #0
 1314 001a 4AD1     		bne	.L90
1159:../FreeRTOS_Source/queue.c **** 			{
1160:../FreeRTOS_Source/queue.c **** 				/* The mutex is no longer being held. */
1161:../FreeRTOS_Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1315              		.loc 1 1161 0
 1316 001c FB68     		ldr	r3, [r7, #12]
 1317 001e 5B68     		ldr	r3, [r3, #4]
 1318 0020 1846     		mov	r0, r3
 1319 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1162:../FreeRTOS_Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1320              		.loc 1 1162 0
 1321 0026 FB68     		ldr	r3, [r7, #12]
 1322 0028 4FF00002 		mov	r2, #0
 1323 002c 5A60     		str	r2, [r3, #4]
 1324 002e 40E0     		b	.L90
 1325              	.L89:
1163:../FreeRTOS_Source/queue.c **** 			}
1164:../FreeRTOS_Source/queue.c **** 		}
1165:../FreeRTOS_Source/queue.c **** 		#endif
1166:../FreeRTOS_Source/queue.c **** 	}
1167:../FreeRTOS_Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1326              		.loc 1 1167 0
 1327 0030 7B68     		ldr	r3, [r7, #4]
 1328 0032 002B     		cmp	r3, #0
 1329 0034 1BD1     		bne	.L91
1168:../FreeRTOS_Source/queue.c **** 	{
1169:../FreeRTOS_Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1330              		.loc 1 1169 0
 1331 0036 FB68     		ldr	r3, [r7, #12]
 1332 0038 9968     		ldr	r1, [r3, #8]
 1333 003a FB68     		ldr	r3, [r7, #12]
 1334 003c 1B6C     		ldr	r3, [r3, #64]
 1335 003e BA68     		ldr	r2, [r7, #8]
 1336 0040 0846     		mov	r0, r1
 1337 0042 1146     		mov	r1, r2
 1338 0044 1A46     		mov	r2, r3
 1339 0046 FFF7FEFF 		bl	memcpy
1170:../FreeRTOS_Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1340              		.loc 1 1170 0
 1341 004a FB68     		ldr	r3, [r7, #12]
 1342 004c 9A68     		ldr	r2, [r3, #8]
 1343 004e FB68     		ldr	r3, [r7, #12]
 1344 0050 1B6C     		ldr	r3, [r3, #64]
 1345 0052 D218     		adds	r2, r2, r3
 1346 0054 FB68     		ldr	r3, [r7, #12]
 1347 0056 9A60     		str	r2, [r3, #8]
1171:../FreeRTOS_Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1348              		.loc 1 1171 0
 1349 0058 FB68     		ldr	r3, [r7, #12]
 1350 005a 9A68     		ldr	r2, [r3, #8]
 1351 005c FB68     		ldr	r3, [r7, #12]
 1352 005e 5B68     		ldr	r3, [r3, #4]
 1353 0060 9A42     		cmp	r2, r3
 1354 0062 26D3     		bcc	.L90
1172:../FreeRTOS_Source/queue.c **** 		{
1173:../FreeRTOS_Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1355              		.loc 1 1173 0
 1356 0064 FB68     		ldr	r3, [r7, #12]
 1357 0066 1A68     		ldr	r2, [r3, #0]
 1358 0068 FB68     		ldr	r3, [r7, #12]
 1359 006a 9A60     		str	r2, [r3, #8]
 1360 006c 21E0     		b	.L90
 1361              	.L91:
1174:../FreeRTOS_Source/queue.c **** 		}
1175:../FreeRTOS_Source/queue.c **** 	}
1176:../FreeRTOS_Source/queue.c **** 	else
1177:../FreeRTOS_Source/queue.c **** 	{
1178:../FreeRTOS_Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1362              		.loc 1 1178 0
 1363 006e FB68     		ldr	r3, [r7, #12]
 1364 0070 D968     		ldr	r1, [r3, #12]
 1365 0072 FB68     		ldr	r3, [r7, #12]
 1366 0074 1B6C     		ldr	r3, [r3, #64]
 1367 0076 BA68     		ldr	r2, [r7, #8]
 1368 0078 0846     		mov	r0, r1
 1369 007a 1146     		mov	r1, r2
 1370 007c 1A46     		mov	r2, r3
 1371 007e FFF7FEFF 		bl	memcpy
1179:../FreeRTOS_Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1372              		.loc 1 1179 0
 1373 0082 FB68     		ldr	r3, [r7, #12]
 1374 0084 DA68     		ldr	r2, [r3, #12]
 1375 0086 FB68     		ldr	r3, [r7, #12]
 1376 0088 1B6C     		ldr	r3, [r3, #64]
 1377 008a C3F10003 		rsb	r3, r3, #0
 1378 008e D218     		adds	r2, r2, r3
 1379 0090 FB68     		ldr	r3, [r7, #12]
 1380 0092 DA60     		str	r2, [r3, #12]
1180:../FreeRTOS_Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1381              		.loc 1 1180 0
 1382 0094 FB68     		ldr	r3, [r7, #12]
 1383 0096 DA68     		ldr	r2, [r3, #12]
 1384 0098 FB68     		ldr	r3, [r7, #12]
 1385 009a 1B68     		ldr	r3, [r3, #0]
 1386 009c 9A42     		cmp	r2, r3
 1387 009e 08D2     		bcs	.L90
1181:../FreeRTOS_Source/queue.c **** 		{
1182:../FreeRTOS_Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1388              		.loc 1 1182 0
 1389 00a0 FB68     		ldr	r3, [r7, #12]
 1390 00a2 5A68     		ldr	r2, [r3, #4]
 1391 00a4 FB68     		ldr	r3, [r7, #12]
 1392 00a6 1B6C     		ldr	r3, [r3, #64]
 1393 00a8 C3F10003 		rsb	r3, r3, #0
 1394 00ac D218     		adds	r2, r2, r3
 1395 00ae FB68     		ldr	r3, [r7, #12]
 1396 00b0 DA60     		str	r2, [r3, #12]
 1397              	.L90:
1183:../FreeRTOS_Source/queue.c **** 		}
1184:../FreeRTOS_Source/queue.c **** 	}
1185:../FreeRTOS_Source/queue.c **** 
1186:../FreeRTOS_Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1398              		.loc 1 1186 0
 1399 00b2 FB68     		ldr	r3, [r7, #12]
 1400 00b4 9B6B     		ldr	r3, [r3, #56]
 1401 00b6 03F10102 		add	r2, r3, #1
 1402 00ba FB68     		ldr	r3, [r7, #12]
 1403 00bc 9A63     		str	r2, [r3, #56]
1187:../FreeRTOS_Source/queue.c **** }
 1404              		.loc 1 1187 0
 1405 00be 07F11007 		add	r7, r7, #16
 1406 00c2 BD46     		mov	sp, r7
 1407 00c4 80BD     		pop	{r7, pc}
 1408              		.cfi_endproc
 1409              	.LFE9:
 1411 00c6 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1412              		.align	2
 1413              		.thumb
 1414              		.thumb_func
 1416              	prvCopyDataFromQueue:
 1417              	.LFB10:
1188:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1189:../FreeRTOS_Source/queue.c **** 
1190:../FreeRTOS_Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1191:../FreeRTOS_Source/queue.c **** {
 1418              		.loc 1 1191 0
 1419              		.cfi_startproc
 1420              		@ args = 0, pretend = 0, frame = 8
 1421              		@ frame_needed = 1, uses_anonymous_args = 0
 1422 0000 80B5     		push	{r7, lr}
 1423              	.LCFI30:
 1424              		.cfi_def_cfa_offset 8
 1425              		.cfi_offset 14, -4
 1426              		.cfi_offset 7, -8
 1427 0002 82B0     		sub	sp, sp, #8
 1428              	.LCFI31:
 1429              		.cfi_def_cfa_offset 16
 1430 0004 00AF     		add	r7, sp, #0
 1431              	.LCFI32:
 1432              		.cfi_def_cfa_register 7
 1433 0006 7860     		str	r0, [r7, #4]
 1434 0008 3960     		str	r1, [r7, #0]
1192:../FreeRTOS_Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1435              		.loc 1 1192 0
 1436 000a 7B68     		ldr	r3, [r7, #4]
 1437 000c 1B68     		ldr	r3, [r3, #0]
 1438 000e 002B     		cmp	r3, #0
 1439 0010 1AD0     		beq	.L92
1193:../FreeRTOS_Source/queue.c **** 	{
1194:../FreeRTOS_Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1440              		.loc 1 1194 0
 1441 0012 7B68     		ldr	r3, [r7, #4]
 1442 0014 DA68     		ldr	r2, [r3, #12]
 1443 0016 7B68     		ldr	r3, [r7, #4]
 1444 0018 1B6C     		ldr	r3, [r3, #64]
 1445 001a D218     		adds	r2, r2, r3
 1446 001c 7B68     		ldr	r3, [r7, #4]
 1447 001e DA60     		str	r2, [r3, #12]
1195:../FreeRTOS_Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1448              		.loc 1 1195 0
 1449 0020 7B68     		ldr	r3, [r7, #4]
 1450 0022 DA68     		ldr	r2, [r3, #12]
 1451 0024 7B68     		ldr	r3, [r7, #4]
 1452 0026 5B68     		ldr	r3, [r3, #4]
 1453 0028 9A42     		cmp	r2, r3
 1454 002a 03D3     		bcc	.L94
1196:../FreeRTOS_Source/queue.c **** 		{
1197:../FreeRTOS_Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1455              		.loc 1 1197 0
 1456 002c 7B68     		ldr	r3, [r7, #4]
 1457 002e 1A68     		ldr	r2, [r3, #0]
 1458 0030 7B68     		ldr	r3, [r7, #4]
 1459 0032 DA60     		str	r2, [r3, #12]
 1460              	.L94:
1198:../FreeRTOS_Source/queue.c **** 		}
1199:../FreeRTOS_Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1461              		.loc 1 1199 0
 1462 0034 7B68     		ldr	r3, [r7, #4]
 1463 0036 DA68     		ldr	r2, [r3, #12]
 1464 0038 7B68     		ldr	r3, [r7, #4]
 1465 003a 1B6C     		ldr	r3, [r3, #64]
 1466 003c 3968     		ldr	r1, [r7, #0]
 1467 003e 0846     		mov	r0, r1
 1468 0040 1146     		mov	r1, r2
 1469 0042 1A46     		mov	r2, r3
 1470 0044 FFF7FEFF 		bl	memcpy
 1471              	.L92:
1200:../FreeRTOS_Source/queue.c **** 	}
1201:../FreeRTOS_Source/queue.c **** }
 1472              		.loc 1 1201 0
 1473 0048 07F10807 		add	r7, r7, #8
 1474 004c BD46     		mov	sp, r7
 1475 004e 80BD     		pop	{r7, pc}
 1476              		.cfi_endproc
 1477              	.LFE10:
 1479              		.section	.text.prvUnlockQueue,"ax",%progbits
 1480              		.align	2
 1481              		.thumb
 1482              		.thumb_func
 1484              	prvUnlockQueue:
 1485              	.LFB11:
1202:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1203:../FreeRTOS_Source/queue.c **** 
1204:../FreeRTOS_Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1205:../FreeRTOS_Source/queue.c **** {
 1486              		.loc 1 1205 0
 1487              		.cfi_startproc
 1488              		@ args = 0, pretend = 0, frame = 8
 1489              		@ frame_needed = 1, uses_anonymous_args = 0
 1490 0000 80B5     		push	{r7, lr}
 1491              	.LCFI33:
 1492              		.cfi_def_cfa_offset 8
 1493              		.cfi_offset 14, -4
 1494              		.cfi_offset 7, -8
 1495 0002 82B0     		sub	sp, sp, #8
 1496              	.LCFI34:
 1497              		.cfi_def_cfa_offset 16
 1498 0004 00AF     		add	r7, sp, #0
 1499              	.LCFI35:
 1500              		.cfi_def_cfa_register 7
 1501 0006 7860     		str	r0, [r7, #4]
1206:../FreeRTOS_Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1207:../FreeRTOS_Source/queue.c **** 
1208:../FreeRTOS_Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1209:../FreeRTOS_Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1210:../FreeRTOS_Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1211:../FreeRTOS_Source/queue.c **** 	updated. */
1212:../FreeRTOS_Source/queue.c **** 	taskENTER_CRITICAL();
 1502              		.loc 1 1212 0
 1503 0008 FFF7FEFF 		bl	vPortEnterCritical
1213:../FreeRTOS_Source/queue.c **** 	{
1214:../FreeRTOS_Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1215:../FreeRTOS_Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1504              		.loc 1 1215 0
 1505 000c 14E0     		b	.L96
 1506              	.L100:
1216:../FreeRTOS_Source/queue.c **** 		{
1217:../FreeRTOS_Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1218:../FreeRTOS_Source/queue.c **** 			blocked waiting for data to become available? */
1219:../FreeRTOS_Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1507              		.loc 1 1219 0
 1508 000e 7B68     		ldr	r3, [r7, #4]
 1509 0010 5B6A     		ldr	r3, [r3, #36]
 1510 0012 002B     		cmp	r3, #0
 1511 0014 15D0     		beq	.L106
1220:../FreeRTOS_Source/queue.c **** 			{
1221:../FreeRTOS_Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1222:../FreeRTOS_Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1223:../FreeRTOS_Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1512              		.loc 1 1223 0
 1513 0016 7B68     		ldr	r3, [r7, #4]
 1514 0018 03F12403 		add	r3, r3, #36
 1515 001c 1846     		mov	r0, r3
 1516 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1517 0022 0346     		mov	r3, r0
 1518 0024 002B     		cmp	r3, #0
 1519 0026 01D0     		beq	.L98
1224:../FreeRTOS_Source/queue.c **** 				{
1225:../FreeRTOS_Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1226:../FreeRTOS_Source/queue.c **** 					context	switch is required. */
1227:../FreeRTOS_Source/queue.c **** 					vTaskMissedYield();
 1520              		.loc 1 1227 0
 1521 0028 FFF7FEFF 		bl	vTaskMissedYield
 1522              	.L98:
1228:../FreeRTOS_Source/queue.c **** 				}
1229:../FreeRTOS_Source/queue.c **** 
1230:../FreeRTOS_Source/queue.c **** 				--( pxQueue->xTxLock );
 1523              		.loc 1 1230 0
 1524 002c 7B68     		ldr	r3, [r7, #4]
 1525 002e 9B6C     		ldr	r3, [r3, #72]
 1526 0030 03F1FF32 		add	r2, r3, #-1
 1527 0034 7B68     		ldr	r3, [r7, #4]
 1528 0036 9A64     		str	r2, [r3, #72]
 1529              	.L96:
1215:../FreeRTOS_Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1530              		.loc 1 1215 0 discriminator 1
 1531 0038 7B68     		ldr	r3, [r7, #4]
 1532 003a 9B6C     		ldr	r3, [r3, #72]
 1533 003c 002B     		cmp	r3, #0
 1534 003e E6DC     		bgt	.L100
 1535 0040 00E0     		b	.L99
 1536              	.L106:
1231:../FreeRTOS_Source/queue.c **** 			}
1232:../FreeRTOS_Source/queue.c **** 			else
1233:../FreeRTOS_Source/queue.c **** 			{
1234:../FreeRTOS_Source/queue.c **** 				break;
 1537              		.loc 1 1234 0
 1538 0042 00BF     		nop
 1539              	.L99:
1235:../FreeRTOS_Source/queue.c **** 			}
1236:../FreeRTOS_Source/queue.c **** 		}
1237:../FreeRTOS_Source/queue.c **** 
1238:../FreeRTOS_Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1540              		.loc 1 1238 0
 1541 0044 7B68     		ldr	r3, [r7, #4]
 1542 0046 4FF0FF32 		mov	r2, #-1
 1543 004a 9A64     		str	r2, [r3, #72]
1239:../FreeRTOS_Source/queue.c **** 	}
1240:../FreeRTOS_Source/queue.c **** 	taskEXIT_CRITICAL();
 1544              		.loc 1 1240 0
 1545 004c FFF7FEFF 		bl	vPortExitCritical
1241:../FreeRTOS_Source/queue.c **** 
1242:../FreeRTOS_Source/queue.c **** 	/* Do the same for the Rx lock. */
1243:../FreeRTOS_Source/queue.c **** 	taskENTER_CRITICAL();
 1546              		.loc 1 1243 0
 1547 0050 FFF7FEFF 		bl	vPortEnterCritical
1244:../FreeRTOS_Source/queue.c **** 	{
1245:../FreeRTOS_Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1548              		.loc 1 1245 0
 1549 0054 14E0     		b	.L101
 1550              	.L105:
1246:../FreeRTOS_Source/queue.c **** 		{
1247:../FreeRTOS_Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1551              		.loc 1 1247 0
 1552 0056 7B68     		ldr	r3, [r7, #4]
 1553 0058 1B69     		ldr	r3, [r3, #16]
 1554 005a 002B     		cmp	r3, #0
 1555 005c 15D0     		beq	.L107
1248:../FreeRTOS_Source/queue.c **** 			{
1249:../FreeRTOS_Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1556              		.loc 1 1249 0
 1557 005e 7B68     		ldr	r3, [r7, #4]
 1558 0060 03F11003 		add	r3, r3, #16
 1559 0064 1846     		mov	r0, r3
 1560 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1561 006a 0346     		mov	r3, r0
 1562 006c 002B     		cmp	r3, #0
 1563 006e 01D0     		beq	.L103
1250:../FreeRTOS_Source/queue.c **** 				{
1251:../FreeRTOS_Source/queue.c **** 					vTaskMissedYield();
 1564              		.loc 1 1251 0
 1565 0070 FFF7FEFF 		bl	vTaskMissedYield
 1566              	.L103:
1252:../FreeRTOS_Source/queue.c **** 				}
1253:../FreeRTOS_Source/queue.c **** 
1254:../FreeRTOS_Source/queue.c **** 				--( pxQueue->xRxLock );
 1567              		.loc 1 1254 0
 1568 0074 7B68     		ldr	r3, [r7, #4]
 1569 0076 5B6C     		ldr	r3, [r3, #68]
 1570 0078 03F1FF32 		add	r2, r3, #-1
 1571 007c 7B68     		ldr	r3, [r7, #4]
 1572 007e 5A64     		str	r2, [r3, #68]
 1573              	.L101:
1245:../FreeRTOS_Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1574              		.loc 1 1245 0 discriminator 1
 1575 0080 7B68     		ldr	r3, [r7, #4]
 1576 0082 5B6C     		ldr	r3, [r3, #68]
 1577 0084 002B     		cmp	r3, #0
 1578 0086 E6DC     		bgt	.L105
 1579 0088 00E0     		b	.L104
 1580              	.L107:
1255:../FreeRTOS_Source/queue.c **** 			}
1256:../FreeRTOS_Source/queue.c **** 			else
1257:../FreeRTOS_Source/queue.c **** 			{
1258:../FreeRTOS_Source/queue.c **** 				break;
 1581              		.loc 1 1258 0
 1582 008a 00BF     		nop
 1583              	.L104:
1259:../FreeRTOS_Source/queue.c **** 			}
1260:../FreeRTOS_Source/queue.c **** 		}
1261:../FreeRTOS_Source/queue.c **** 
1262:../FreeRTOS_Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1584              		.loc 1 1262 0
 1585 008c 7B68     		ldr	r3, [r7, #4]
 1586 008e 4FF0FF32 		mov	r2, #-1
 1587 0092 5A64     		str	r2, [r3, #68]
1263:../FreeRTOS_Source/queue.c **** 	}
1264:../FreeRTOS_Source/queue.c **** 	taskEXIT_CRITICAL();
 1588              		.loc 1 1264 0
 1589 0094 FFF7FEFF 		bl	vPortExitCritical
1265:../FreeRTOS_Source/queue.c **** }
 1590              		.loc 1 1265 0
 1591 0098 07F10807 		add	r7, r7, #8
 1592 009c BD46     		mov	sp, r7
 1593 009e 80BD     		pop	{r7, pc}
 1594              		.cfi_endproc
 1595              	.LFE11:
 1597              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1598              		.align	2
 1599              		.thumb
 1600              		.thumb_func
 1602              	prvIsQueueEmpty:
 1603              	.LFB12:
1266:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1267:../FreeRTOS_Source/queue.c **** 
1268:../FreeRTOS_Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1269:../FreeRTOS_Source/queue.c **** {
 1604              		.loc 1 1269 0
 1605              		.cfi_startproc
 1606              		@ args = 0, pretend = 0, frame = 16
 1607              		@ frame_needed = 1, uses_anonymous_args = 0
 1608 0000 80B5     		push	{r7, lr}
 1609              	.LCFI36:
 1610              		.cfi_def_cfa_offset 8
 1611              		.cfi_offset 14, -4
 1612              		.cfi_offset 7, -8
 1613 0002 84B0     		sub	sp, sp, #16
 1614              	.LCFI37:
 1615              		.cfi_def_cfa_offset 24
 1616 0004 00AF     		add	r7, sp, #0
 1617              	.LCFI38:
 1618              		.cfi_def_cfa_register 7
 1619 0006 7860     		str	r0, [r7, #4]
1270:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1271:../FreeRTOS_Source/queue.c **** 
1272:../FreeRTOS_Source/queue.c **** 	taskENTER_CRITICAL();
 1620              		.loc 1 1272 0
 1621 0008 FFF7FEFF 		bl	vPortEnterCritical
1273:../FreeRTOS_Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1622              		.loc 1 1273 0
 1623 000c 7B68     		ldr	r3, [r7, #4]
 1624 000e 9B6B     		ldr	r3, [r3, #56]
 1625 0010 002B     		cmp	r3, #0
 1626 0012 14BF     		ite	ne
 1627 0014 0023     		movne	r3, #0
 1628 0016 0123     		moveq	r3, #1
 1629 0018 FB60     		str	r3, [r7, #12]
1274:../FreeRTOS_Source/queue.c **** 	taskEXIT_CRITICAL();
 1630              		.loc 1 1274 0
 1631 001a FFF7FEFF 		bl	vPortExitCritical
1275:../FreeRTOS_Source/queue.c **** 
1276:../FreeRTOS_Source/queue.c **** 	return xReturn;
 1632              		.loc 1 1276 0
 1633 001e FB68     		ldr	r3, [r7, #12]
1277:../FreeRTOS_Source/queue.c **** }
 1634              		.loc 1 1277 0
 1635 0020 1846     		mov	r0, r3
 1636 0022 07F11007 		add	r7, r7, #16
 1637 0026 BD46     		mov	sp, r7
 1638 0028 80BD     		pop	{r7, pc}
 1639              		.cfi_endproc
 1640              	.LFE12:
 1642 002a 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1643              		.align	2
 1644              		.global	xQueueIsQueueEmptyFromISR
 1645              		.thumb
 1646              		.thumb_func
 1648              	xQueueIsQueueEmptyFromISR:
 1649              	.LFB13:
1278:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1279:../FreeRTOS_Source/queue.c **** 
1280:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1281:../FreeRTOS_Source/queue.c **** {
 1650              		.loc 1 1281 0
 1651              		.cfi_startproc
 1652              		@ args = 0, pretend = 0, frame = 16
 1653              		@ frame_needed = 1, uses_anonymous_args = 0
 1654              		@ link register save eliminated.
 1655 0000 80B4     		push	{r7}
 1656              	.LCFI39:
 1657              		.cfi_def_cfa_offset 4
 1658              		.cfi_offset 7, -4
 1659 0002 85B0     		sub	sp, sp, #20
 1660              	.LCFI40:
 1661              		.cfi_def_cfa_offset 24
 1662 0004 00AF     		add	r7, sp, #0
 1663              	.LCFI41:
 1664              		.cfi_def_cfa_register 7
 1665 0006 7860     		str	r0, [r7, #4]
1282:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1283:../FreeRTOS_Source/queue.c **** 
1284:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 1666              		.loc 1 1284 0
 1667 0008 7B68     		ldr	r3, [r7, #4]
 1668 000a 002B     		cmp	r3, #0
 1669 000c 04D1     		bne	.L110
 1670              		.loc 1 1284 0 is_stmt 0 discriminator 1
 1671              	@ 1284 "../FreeRTOS_Source/queue.c" 1
 1672 000e 4FF05000 			mov r0, #80								
 1673 0012 80F31188 		msr basepri, r0							
 1674              	
 1675              	@ 0 "" 2
 1676              		.thumb
 1677              	.L111:
 1678              		.loc 1 1284 0 discriminator 2
 1679 0016 FEE7     		b	.L111
 1680              	.L110:
1285:../FreeRTOS_Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1681              		.loc 1 1285 0 is_stmt 1
 1682 0018 7B68     		ldr	r3, [r7, #4]
 1683 001a 9B6B     		ldr	r3, [r3, #56]
 1684 001c 002B     		cmp	r3, #0
 1685 001e 14BF     		ite	ne
 1686 0020 0023     		movne	r3, #0
 1687 0022 0123     		moveq	r3, #1
 1688 0024 FB60     		str	r3, [r7, #12]
1286:../FreeRTOS_Source/queue.c **** 
1287:../FreeRTOS_Source/queue.c **** 	return xReturn;
 1689              		.loc 1 1287 0
 1690 0026 FB68     		ldr	r3, [r7, #12]
1288:../FreeRTOS_Source/queue.c **** }
 1691              		.loc 1 1288 0
 1692 0028 1846     		mov	r0, r3
 1693 002a 07F11407 		add	r7, r7, #20
 1694 002e BD46     		mov	sp, r7
 1695 0030 80BC     		pop	{r7}
 1696 0032 7047     		bx	lr
 1697              		.cfi_endproc
 1698              	.LFE13:
 1700              		.section	.text.prvIsQueueFull,"ax",%progbits
 1701              		.align	2
 1702              		.thumb
 1703              		.thumb_func
 1705              	prvIsQueueFull:
 1706              	.LFB14:
1289:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1290:../FreeRTOS_Source/queue.c **** 
1291:../FreeRTOS_Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1292:../FreeRTOS_Source/queue.c **** {
 1707              		.loc 1 1292 0
 1708              		.cfi_startproc
 1709              		@ args = 0, pretend = 0, frame = 16
 1710              		@ frame_needed = 1, uses_anonymous_args = 0
 1711 0000 80B5     		push	{r7, lr}
 1712              	.LCFI42:
 1713              		.cfi_def_cfa_offset 8
 1714              		.cfi_offset 14, -4
 1715              		.cfi_offset 7, -8
 1716 0002 84B0     		sub	sp, sp, #16
 1717              	.LCFI43:
 1718              		.cfi_def_cfa_offset 24
 1719 0004 00AF     		add	r7, sp, #0
 1720              	.LCFI44:
 1721              		.cfi_def_cfa_register 7
 1722 0006 7860     		str	r0, [r7, #4]
1293:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1294:../FreeRTOS_Source/queue.c **** 
1295:../FreeRTOS_Source/queue.c **** 	taskENTER_CRITICAL();
 1723              		.loc 1 1295 0
 1724 0008 FFF7FEFF 		bl	vPortEnterCritical
1296:../FreeRTOS_Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1725              		.loc 1 1296 0
 1726 000c 7B68     		ldr	r3, [r7, #4]
 1727 000e 9A6B     		ldr	r2, [r3, #56]
 1728 0010 7B68     		ldr	r3, [r7, #4]
 1729 0012 DB6B     		ldr	r3, [r3, #60]
 1730 0014 9A42     		cmp	r2, r3
 1731 0016 14BF     		ite	ne
 1732 0018 0023     		movne	r3, #0
 1733 001a 0123     		moveq	r3, #1
 1734 001c FB60     		str	r3, [r7, #12]
1297:../FreeRTOS_Source/queue.c **** 	taskEXIT_CRITICAL();
 1735              		.loc 1 1297 0
 1736 001e FFF7FEFF 		bl	vPortExitCritical
1298:../FreeRTOS_Source/queue.c **** 
1299:../FreeRTOS_Source/queue.c **** 	return xReturn;
 1737              		.loc 1 1299 0
 1738 0022 FB68     		ldr	r3, [r7, #12]
1300:../FreeRTOS_Source/queue.c **** }
 1739              		.loc 1 1300 0
 1740 0024 1846     		mov	r0, r3
 1741 0026 07F11007 		add	r7, r7, #16
 1742 002a BD46     		mov	sp, r7
 1743 002c 80BD     		pop	{r7, pc}
 1744              		.cfi_endproc
 1745              	.LFE14:
 1747 002e 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1748              		.align	2
 1749              		.global	xQueueIsQueueFullFromISR
 1750              		.thumb
 1751              		.thumb_func
 1753              	xQueueIsQueueFullFromISR:
 1754              	.LFB15:
1301:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1302:../FreeRTOS_Source/queue.c **** 
1303:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1304:../FreeRTOS_Source/queue.c **** {
 1755              		.loc 1 1304 0
 1756              		.cfi_startproc
 1757              		@ args = 0, pretend = 0, frame = 16
 1758              		@ frame_needed = 1, uses_anonymous_args = 0
 1759              		@ link register save eliminated.
 1760 0000 80B4     		push	{r7}
 1761              	.LCFI45:
 1762              		.cfi_def_cfa_offset 4
 1763              		.cfi_offset 7, -4
 1764 0002 85B0     		sub	sp, sp, #20
 1765              	.LCFI46:
 1766              		.cfi_def_cfa_offset 24
 1767 0004 00AF     		add	r7, sp, #0
 1768              	.LCFI47:
 1769              		.cfi_def_cfa_register 7
 1770 0006 7860     		str	r0, [r7, #4]
1305:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1306:../FreeRTOS_Source/queue.c **** 
1307:../FreeRTOS_Source/queue.c **** 	configASSERT( pxQueue );
 1771              		.loc 1 1307 0
 1772 0008 7B68     		ldr	r3, [r7, #4]
 1773 000a 002B     		cmp	r3, #0
 1774 000c 04D1     		bne	.L114
 1775              		.loc 1 1307 0 is_stmt 0 discriminator 1
 1776              	@ 1307 "../FreeRTOS_Source/queue.c" 1
 1777 000e 4FF05000 			mov r0, #80								
 1778 0012 80F31188 		msr basepri, r0							
 1779              	
 1780              	@ 0 "" 2
 1781              		.thumb
 1782              	.L115:
 1783              		.loc 1 1307 0 discriminator 2
 1784 0016 FEE7     		b	.L115
 1785              	.L114:
1308:../FreeRTOS_Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1786              		.loc 1 1308 0 is_stmt 1
 1787 0018 7B68     		ldr	r3, [r7, #4]
 1788 001a 9A6B     		ldr	r2, [r3, #56]
 1789 001c 7B68     		ldr	r3, [r7, #4]
 1790 001e DB6B     		ldr	r3, [r3, #60]
 1791 0020 9A42     		cmp	r2, r3
 1792 0022 14BF     		ite	ne
 1793 0024 0023     		movne	r3, #0
 1794 0026 0123     		moveq	r3, #1
 1795 0028 FB60     		str	r3, [r7, #12]
1309:../FreeRTOS_Source/queue.c **** 
1310:../FreeRTOS_Source/queue.c **** 	return xReturn;
 1796              		.loc 1 1310 0
 1797 002a FB68     		ldr	r3, [r7, #12]
1311:../FreeRTOS_Source/queue.c **** }
 1798              		.loc 1 1311 0
 1799 002c 1846     		mov	r0, r3
 1800 002e 07F11407 		add	r7, r7, #20
 1801 0032 BD46     		mov	sp, r7
 1802 0034 80BC     		pop	{r7}
 1803 0036 7047     		bx	lr
 1804              		.cfi_endproc
 1805              	.LFE15:
 1807              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 1808              		.align	2
 1809              		.global	vQueueWaitForMessageRestricted
 1810              		.thumb
 1811              		.thumb_func
 1813              	vQueueWaitForMessageRestricted:
 1814              	.LFB16:
1312:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1313:../FreeRTOS_Source/queue.c **** 
1314:../FreeRTOS_Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1315:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xT
1316:../FreeRTOS_Source/queue.c **** {
1317:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1318:../FreeRTOS_Source/queue.c **** 
1319:../FreeRTOS_Source/queue.c **** 	/* If the queue is already full we may have to block.  A critical section
1320:../FreeRTOS_Source/queue.c **** 	is required to prevent an interrupt removing something from the queue
1321:../FreeRTOS_Source/queue.c **** 	between the check to see if the queue is full and blocking on the queue. */
1322:../FreeRTOS_Source/queue.c **** 	portDISABLE_INTERRUPTS();
1323:../FreeRTOS_Source/queue.c **** 	{
1324:../FreeRTOS_Source/queue.c **** 		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1325:../FreeRTOS_Source/queue.c **** 		{
1326:../FreeRTOS_Source/queue.c **** 			/* The queue is full - do we want to block or just leave without
1327:../FreeRTOS_Source/queue.c **** 			posting? */
1328:../FreeRTOS_Source/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1329:../FreeRTOS_Source/queue.c **** 			{
1330:../FreeRTOS_Source/queue.c **** 				/* As this is called from a coroutine we cannot block directly, but
1331:../FreeRTOS_Source/queue.c **** 				return indicating that we need to block. */
1332:../FreeRTOS_Source/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1333:../FreeRTOS_Source/queue.c **** 				portENABLE_INTERRUPTS();
1334:../FreeRTOS_Source/queue.c **** 				return errQUEUE_BLOCKED;
1335:../FreeRTOS_Source/queue.c **** 			}
1336:../FreeRTOS_Source/queue.c **** 			else
1337:../FreeRTOS_Source/queue.c **** 			{
1338:../FreeRTOS_Source/queue.c **** 				portENABLE_INTERRUPTS();
1339:../FreeRTOS_Source/queue.c **** 				return errQUEUE_FULL;
1340:../FreeRTOS_Source/queue.c **** 			}
1341:../FreeRTOS_Source/queue.c **** 		}
1342:../FreeRTOS_Source/queue.c **** 	}
1343:../FreeRTOS_Source/queue.c **** 	portENABLE_INTERRUPTS();
1344:../FreeRTOS_Source/queue.c **** 
1345:../FreeRTOS_Source/queue.c **** 	portNOP();
1346:../FreeRTOS_Source/queue.c **** 
1347:../FreeRTOS_Source/queue.c **** 	portDISABLE_INTERRUPTS();
1348:../FreeRTOS_Source/queue.c **** 	{
1349:../FreeRTOS_Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1350:../FreeRTOS_Source/queue.c **** 		{
1351:../FreeRTOS_Source/queue.c **** 			/* There is room in the queue, copy the data into the queue. */
1352:../FreeRTOS_Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1353:../FreeRTOS_Source/queue.c **** 			xReturn = pdPASS;
1354:../FreeRTOS_Source/queue.c **** 
1355:../FreeRTOS_Source/queue.c **** 			/* Were any co-routines waiting for data to become available? */
1356:../FreeRTOS_Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1357:../FreeRTOS_Source/queue.c **** 			{
1358:../FreeRTOS_Source/queue.c **** 				/* In this instance the co-routine could be placed directly
1359:../FreeRTOS_Source/queue.c **** 				into the ready list as we are within a critical section.
1360:../FreeRTOS_Source/queue.c **** 				Instead the same pending ready list mechanism is used as if
1361:../FreeRTOS_Source/queue.c **** 				the event were caused from within an interrupt. */
1362:../FreeRTOS_Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1363:../FreeRTOS_Source/queue.c **** 				{
1364:../FreeRTOS_Source/queue.c **** 					/* The co-routine waiting has a higher priority so record
1365:../FreeRTOS_Source/queue.c **** 					that a yield might be appropriate. */
1366:../FreeRTOS_Source/queue.c **** 					xReturn = errQUEUE_YIELD;
1367:../FreeRTOS_Source/queue.c **** 				}
1368:../FreeRTOS_Source/queue.c **** 			}
1369:../FreeRTOS_Source/queue.c **** 		}
1370:../FreeRTOS_Source/queue.c **** 		else
1371:../FreeRTOS_Source/queue.c **** 		{
1372:../FreeRTOS_Source/queue.c **** 			xReturn = errQUEUE_FULL;
1373:../FreeRTOS_Source/queue.c **** 		}
1374:../FreeRTOS_Source/queue.c **** 	}
1375:../FreeRTOS_Source/queue.c **** 	portENABLE_INTERRUPTS();
1376:../FreeRTOS_Source/queue.c **** 
1377:../FreeRTOS_Source/queue.c **** 	return xReturn;
1378:../FreeRTOS_Source/queue.c **** }
1379:../FreeRTOS_Source/queue.c **** #endif
1380:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1381:../FreeRTOS_Source/queue.c **** 
1382:../FreeRTOS_Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1383:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWa
1384:../FreeRTOS_Source/queue.c **** {
1385:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1386:../FreeRTOS_Source/queue.c **** 
1387:../FreeRTOS_Source/queue.c **** 	/* If the queue is already empty we may have to block.  A critical section
1388:../FreeRTOS_Source/queue.c **** 	is required to prevent an interrupt adding something to the queue
1389:../FreeRTOS_Source/queue.c **** 	between the check to see if the queue is empty and blocking on the queue. */
1390:../FreeRTOS_Source/queue.c **** 	portDISABLE_INTERRUPTS();
1391:../FreeRTOS_Source/queue.c **** 	{
1392:../FreeRTOS_Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1393:../FreeRTOS_Source/queue.c **** 		{
1394:../FreeRTOS_Source/queue.c **** 			/* There are no messages in the queue, do we want to block or just
1395:../FreeRTOS_Source/queue.c **** 			leave with nothing? */
1396:../FreeRTOS_Source/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1397:../FreeRTOS_Source/queue.c **** 			{
1398:../FreeRTOS_Source/queue.c **** 				/* As this is a co-routine we cannot block directly, but return
1399:../FreeRTOS_Source/queue.c **** 				indicating that we need to block. */
1400:../FreeRTOS_Source/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1401:../FreeRTOS_Source/queue.c **** 				portENABLE_INTERRUPTS();
1402:../FreeRTOS_Source/queue.c **** 				return errQUEUE_BLOCKED;
1403:../FreeRTOS_Source/queue.c **** 			}
1404:../FreeRTOS_Source/queue.c **** 			else
1405:../FreeRTOS_Source/queue.c **** 			{
1406:../FreeRTOS_Source/queue.c **** 				portENABLE_INTERRUPTS();
1407:../FreeRTOS_Source/queue.c **** 				return errQUEUE_FULL;
1408:../FreeRTOS_Source/queue.c **** 			}
1409:../FreeRTOS_Source/queue.c **** 		}
1410:../FreeRTOS_Source/queue.c **** 	}
1411:../FreeRTOS_Source/queue.c **** 	portENABLE_INTERRUPTS();
1412:../FreeRTOS_Source/queue.c **** 
1413:../FreeRTOS_Source/queue.c **** 	portNOP();
1414:../FreeRTOS_Source/queue.c **** 
1415:../FreeRTOS_Source/queue.c **** 	portDISABLE_INTERRUPTS();
1416:../FreeRTOS_Source/queue.c **** 	{
1417:../FreeRTOS_Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1418:../FreeRTOS_Source/queue.c **** 		{
1419:../FreeRTOS_Source/queue.c **** 			/* Data is available from the queue. */
1420:../FreeRTOS_Source/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1421:../FreeRTOS_Source/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1422:../FreeRTOS_Source/queue.c **** 			{
1423:../FreeRTOS_Source/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1424:../FreeRTOS_Source/queue.c **** 			}
1425:../FreeRTOS_Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1426:../FreeRTOS_Source/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1427:../FreeRTOS_Source/queue.c **** 
1428:../FreeRTOS_Source/queue.c **** 			xReturn = pdPASS;
1429:../FreeRTOS_Source/queue.c **** 
1430:../FreeRTOS_Source/queue.c **** 			/* Were any co-routines waiting for space to become available? */
1431:../FreeRTOS_Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1432:../FreeRTOS_Source/queue.c **** 			{
1433:../FreeRTOS_Source/queue.c **** 				/* In this instance the co-routine could be placed directly
1434:../FreeRTOS_Source/queue.c **** 				into the ready list as we are within a critical section.
1435:../FreeRTOS_Source/queue.c **** 				Instead the same pending ready list mechanism is used as if
1436:../FreeRTOS_Source/queue.c **** 				the event were caused from within an interrupt. */
1437:../FreeRTOS_Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1438:../FreeRTOS_Source/queue.c **** 				{
1439:../FreeRTOS_Source/queue.c **** 					xReturn = errQUEUE_YIELD;
1440:../FreeRTOS_Source/queue.c **** 				}
1441:../FreeRTOS_Source/queue.c **** 			}
1442:../FreeRTOS_Source/queue.c **** 		}
1443:../FreeRTOS_Source/queue.c **** 		else
1444:../FreeRTOS_Source/queue.c **** 		{
1445:../FreeRTOS_Source/queue.c **** 			xReturn = pdFAIL;
1446:../FreeRTOS_Source/queue.c **** 		}
1447:../FreeRTOS_Source/queue.c **** 	}
1448:../FreeRTOS_Source/queue.c **** 	portENABLE_INTERRUPTS();
1449:../FreeRTOS_Source/queue.c **** 
1450:../FreeRTOS_Source/queue.c **** 	return xReturn;
1451:../FreeRTOS_Source/queue.c **** }
1452:../FreeRTOS_Source/queue.c **** #endif
1453:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1454:../FreeRTOS_Source/queue.c **** 
1455:../FreeRTOS_Source/queue.c **** 
1456:../FreeRTOS_Source/queue.c **** 
1457:../FreeRTOS_Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1458:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed p
1459:../FreeRTOS_Source/queue.c **** {
1460:../FreeRTOS_Source/queue.c **** 	/* Cannot block within an ISR so if there is no space on the queue then
1461:../FreeRTOS_Source/queue.c **** 	exit without doing anything. */
1462:../FreeRTOS_Source/queue.c **** 	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1463:../FreeRTOS_Source/queue.c **** 	{
1464:../FreeRTOS_Source/queue.c **** 		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1465:../FreeRTOS_Source/queue.c **** 
1466:../FreeRTOS_Source/queue.c **** 		/* We only want to wake one co-routine per ISR, so check that a
1467:../FreeRTOS_Source/queue.c **** 		co-routine has not already been woken. */
1468:../FreeRTOS_Source/queue.c **** 		if( xCoRoutinePreviouslyWoken == pdFALSE )
1469:../FreeRTOS_Source/queue.c **** 		{
1470:../FreeRTOS_Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1471:../FreeRTOS_Source/queue.c **** 			{
1472:../FreeRTOS_Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1473:../FreeRTOS_Source/queue.c **** 				{
1474:../FreeRTOS_Source/queue.c **** 					return pdTRUE;
1475:../FreeRTOS_Source/queue.c **** 				}
1476:../FreeRTOS_Source/queue.c **** 			}
1477:../FreeRTOS_Source/queue.c **** 		}
1478:../FreeRTOS_Source/queue.c **** 	}
1479:../FreeRTOS_Source/queue.c **** 
1480:../FreeRTOS_Source/queue.c **** 	return xCoRoutinePreviouslyWoken;
1481:../FreeRTOS_Source/queue.c **** }
1482:../FreeRTOS_Source/queue.c **** #endif
1483:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1484:../FreeRTOS_Source/queue.c **** 
1485:../FreeRTOS_Source/queue.c **** #if configUSE_CO_ROUTINES == 1
1486:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_
1487:../FreeRTOS_Source/queue.c **** {
1488:../FreeRTOS_Source/queue.c **** signed portBASE_TYPE xReturn;
1489:../FreeRTOS_Source/queue.c **** 
1490:../FreeRTOS_Source/queue.c **** 	/* We cannot block from an ISR, so check there is data available. If
1491:../FreeRTOS_Source/queue.c **** 	not then just leave without doing anything. */
1492:../FreeRTOS_Source/queue.c **** 	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1493:../FreeRTOS_Source/queue.c **** 	{
1494:../FreeRTOS_Source/queue.c **** 		/* Copy the data from the queue. */
1495:../FreeRTOS_Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1496:../FreeRTOS_Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1497:../FreeRTOS_Source/queue.c **** 		{
1498:../FreeRTOS_Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1499:../FreeRTOS_Source/queue.c **** 		}
1500:../FreeRTOS_Source/queue.c **** 		--( pxQueue->uxMessagesWaiting );
1501:../FreeRTOS_Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1502:../FreeRTOS_Source/queue.c **** 
1503:../FreeRTOS_Source/queue.c **** 		if( ( *pxCoRoutineWoken ) == pdFALSE )
1504:../FreeRTOS_Source/queue.c **** 		{
1505:../FreeRTOS_Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1506:../FreeRTOS_Source/queue.c **** 			{
1507:../FreeRTOS_Source/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1508:../FreeRTOS_Source/queue.c **** 				{
1509:../FreeRTOS_Source/queue.c **** 					*pxCoRoutineWoken = pdTRUE;
1510:../FreeRTOS_Source/queue.c **** 				}
1511:../FreeRTOS_Source/queue.c **** 			}
1512:../FreeRTOS_Source/queue.c **** 		}
1513:../FreeRTOS_Source/queue.c **** 
1514:../FreeRTOS_Source/queue.c **** 		xReturn = pdPASS;
1515:../FreeRTOS_Source/queue.c **** 	}
1516:../FreeRTOS_Source/queue.c **** 	else
1517:../FreeRTOS_Source/queue.c **** 	{
1518:../FreeRTOS_Source/queue.c **** 		xReturn = pdFAIL;
1519:../FreeRTOS_Source/queue.c **** 	}
1520:../FreeRTOS_Source/queue.c **** 
1521:../FreeRTOS_Source/queue.c **** 	return xReturn;
1522:../FreeRTOS_Source/queue.c **** }
1523:../FreeRTOS_Source/queue.c **** #endif
1524:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1525:../FreeRTOS_Source/queue.c **** 
1526:../FreeRTOS_Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1527:../FreeRTOS_Source/queue.c **** 
1528:../FreeRTOS_Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1529:../FreeRTOS_Source/queue.c **** 	{
1530:../FreeRTOS_Source/queue.c **** 	unsigned portBASE_TYPE ux;
1531:../FreeRTOS_Source/queue.c **** 
1532:../FreeRTOS_Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1533:../FreeRTOS_Source/queue.c **** 		a free slot. */
1534:../FreeRTOS_Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
1535:../FreeRTOS_Source/queue.c **** 		{
1536:../FreeRTOS_Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
1537:../FreeRTOS_Source/queue.c **** 			{
1538:../FreeRTOS_Source/queue.c **** 				/* Store the information on this queue. */
1539:../FreeRTOS_Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
1540:../FreeRTOS_Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
1541:../FreeRTOS_Source/queue.c **** 				break;
1542:../FreeRTOS_Source/queue.c **** 			}
1543:../FreeRTOS_Source/queue.c **** 		}
1544:../FreeRTOS_Source/queue.c **** 	}
1545:../FreeRTOS_Source/queue.c **** 
1546:../FreeRTOS_Source/queue.c **** #endif
1547:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1548:../FreeRTOS_Source/queue.c **** 
1549:../FreeRTOS_Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1550:../FreeRTOS_Source/queue.c **** 
1551:../FreeRTOS_Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1552:../FreeRTOS_Source/queue.c **** 	{
1553:../FreeRTOS_Source/queue.c **** 	unsigned portBASE_TYPE ux;
1554:../FreeRTOS_Source/queue.c **** 
1555:../FreeRTOS_Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1556:../FreeRTOS_Source/queue.c **** 		registry. */
1557:../FreeRTOS_Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
1558:../FreeRTOS_Source/queue.c **** 		{
1559:../FreeRTOS_Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
1560:../FreeRTOS_Source/queue.c **** 			{
1561:../FreeRTOS_Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1562:../FreeRTOS_Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
1563:../FreeRTOS_Source/queue.c **** 				break;
1564:../FreeRTOS_Source/queue.c **** 			}
1565:../FreeRTOS_Source/queue.c **** 		}
1566:../FreeRTOS_Source/queue.c **** 
1567:../FreeRTOS_Source/queue.c **** 	}
1568:../FreeRTOS_Source/queue.c **** 
1569:../FreeRTOS_Source/queue.c **** #endif
1570:../FreeRTOS_Source/queue.c **** /*-----------------------------------------------------------*/
1571:../FreeRTOS_Source/queue.c **** 
1572:../FreeRTOS_Source/queue.c **** #if configUSE_TIMERS == 1
1573:../FreeRTOS_Source/queue.c **** 
1574:../FreeRTOS_Source/queue.c **** 	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
1575:../FreeRTOS_Source/queue.c **** 	{
 1815              		.loc 1 1575 0
 1816              		.cfi_startproc
 1817              		@ args = 0, pretend = 0, frame = 8
 1818              		@ frame_needed = 1, uses_anonymous_args = 0
 1819 0000 80B5     		push	{r7, lr}
 1820              	.LCFI48:
 1821              		.cfi_def_cfa_offset 8
 1822              		.cfi_offset 14, -4
 1823              		.cfi_offset 7, -8
 1824 0002 82B0     		sub	sp, sp, #8
 1825              	.LCFI49:
 1826              		.cfi_def_cfa_offset 16
 1827 0004 00AF     		add	r7, sp, #0
 1828              	.LCFI50:
 1829              		.cfi_def_cfa_register 7
 1830 0006 7860     		str	r0, [r7, #4]
 1831 0008 3960     		str	r1, [r7, #0]
1576:../FreeRTOS_Source/queue.c **** 		/* This function should not be called by application code hence the
1577:../FreeRTOS_Source/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1578:../FreeRTOS_Source/queue.c **** 		designed for use by kernel code, and has special calling requirements.
1579:../FreeRTOS_Source/queue.c **** 		It can result in vListInsert() being called on a list that can only
1580:../FreeRTOS_Source/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
1581:../FreeRTOS_Source/queue.c **** 		so it should be called with the scheduler locked and not from a critical
1582:../FreeRTOS_Source/queue.c **** 		section. */
1583:../FreeRTOS_Source/queue.c **** 
1584:../FreeRTOS_Source/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
1585:../FreeRTOS_Source/queue.c **** 		will not actually cause the task to block, just place it on a blocked
1586:../FreeRTOS_Source/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
1587:../FreeRTOS_Source/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
1588:../FreeRTOS_Source/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
1589:../FreeRTOS_Source/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
1590:../FreeRTOS_Source/queue.c **** 		prvLockQueue( pxQueue );
 1832              		.loc 1 1590 0
 1833 000a FFF7FEFF 		bl	vPortEnterCritical
 1834 000e 7B68     		ldr	r3, [r7, #4]
 1835 0010 5B6C     		ldr	r3, [r3, #68]
 1836 0012 B3F1FF3F 		cmp	r3, #-1
 1837 0016 03D1     		bne	.L117
 1838              		.loc 1 1590 0 is_stmt 0 discriminator 1
 1839 0018 7B68     		ldr	r3, [r7, #4]
 1840 001a 4FF00002 		mov	r2, #0
 1841 001e 5A64     		str	r2, [r3, #68]
 1842              	.L117:
 1843              		.loc 1 1590 0 discriminator 2
 1844 0020 7B68     		ldr	r3, [r7, #4]
 1845 0022 9B6C     		ldr	r3, [r3, #72]
 1846 0024 B3F1FF3F 		cmp	r3, #-1
 1847 0028 03D1     		bne	.L118
 1848              		.loc 1 1590 0 discriminator 3
 1849 002a 7B68     		ldr	r3, [r7, #4]
 1850 002c 4FF00002 		mov	r2, #0
 1851 0030 9A64     		str	r2, [r3, #72]
 1852              	.L118:
 1853              		.loc 1 1590 0 discriminator 4
 1854 0032 FFF7FEFF 		bl	vPortExitCritical
1591:../FreeRTOS_Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 1855              		.loc 1 1591 0 is_stmt 1 discriminator 4
 1856 0036 7B68     		ldr	r3, [r7, #4]
 1857 0038 9B6B     		ldr	r3, [r3, #56]
 1858 003a 002B     		cmp	r3, #0
 1859 003c 06D1     		bne	.L119
1592:../FreeRTOS_Source/queue.c **** 		{
1593:../FreeRTOS_Source/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
1594:../FreeRTOS_Source/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1860              		.loc 1 1594 0
 1861 003e 7B68     		ldr	r3, [r7, #4]
 1862 0040 03F12403 		add	r3, r3, #36
 1863 0044 1846     		mov	r0, r3
 1864 0046 3968     		ldr	r1, [r7, #0]
 1865 0048 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 1866              	.L119:
1595:../FreeRTOS_Source/queue.c **** 		}
1596:../FreeRTOS_Source/queue.c **** 		prvUnlockQueue( pxQueue );
 1867              		.loc 1 1596 0
 1868 004c 7868     		ldr	r0, [r7, #4]
 1869 004e FFF7FEFF 		bl	prvUnlockQueue
1597:../FreeRTOS_Source/queue.c **** 	}
 1870              		.loc 1 1597 0
 1871 0052 07F10807 		add	r7, r7, #8
 1872 0056 BD46     		mov	sp, r7
 1873 0058 80BD     		pop	{r7, pc}
 1874              		.cfi_endproc
 1875              	.LFE16:
 1877 005a 00BF     		.text
 1878              	.Letext0:
 1879              		.file 2 "c:\\tools\\codesourcery\\arm\\29-01-2012\\bin\\../lib/gcc/arm-none-eabi/4.6.1/include/std
 1880              		.file 3 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\portable\\GCC\\ARM_CM3/portmacro.
 1881              		.file 4 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/list.h"
 1882              		.file 5 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:19     .text.xQueueGenericCreate:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:24     .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:167    .text.xQueueCreateMutex:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:172    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:283    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:278    .text.xQueueGenericSend:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1285   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1705   .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1484   .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:501    .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:506    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:667    .text.xQueueGenericReceive:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:672    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1416   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1602   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:948    .text.xQueueReceiveFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:953    .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1116   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1121   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1173   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1178   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1227   .text.vQueueDelete:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1232   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1281   .text.prvCopyDataToQueue:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1412   .text.prvCopyDataFromQueue:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1480   .text.prvUnlockQueue:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1598   .text.prvIsQueueEmpty:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1643   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1648   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1701   .text.prvIsQueueFull:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1748   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1753   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1808   .text.vQueueWaitForMessageRestricted:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccP98Eep.s:1813   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vListInitialise
vPortFree
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
