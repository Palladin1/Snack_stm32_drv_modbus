   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"timers.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.bss.xActiveTimerList1,"aw",%nobits
  19              		.align	2
  22              	xActiveTimerList1:
  23 0000 00000000 		.space	20
  23      00000000 
  23      00000000 
  23      00000000 
  23      00000000 
  24              		.section	.bss.xActiveTimerList2,"aw",%nobits
  25              		.align	2
  28              	xActiveTimerList2:
  29 0000 00000000 		.space	20
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.section	.bss.pxCurrentTimerList,"aw",%nobits
  31              		.align	2
  34              	pxCurrentTimerList:
  35 0000 00000000 		.space	4
  36              		.section	.bss.pxOverflowTimerList,"aw",%nobits
  37              		.align	2
  40              	pxOverflowTimerList:
  41 0000 00000000 		.space	4
  42              		.section	.bss.xTimerQueue,"aw",%nobits
  43              		.align	2
  46              	xTimerQueue:
  47 0000 00000000 		.space	4
  48              		.section	.rodata
  49              		.align	2
  50              	.LC0:
  51 0000 546D7220 		.ascii	"Tmr Svc\000"
  51      53766300 
  52              		.section	.text.xTimerCreateTimerTask,"ax",%progbits
  53              		.align	2
  54              		.global	xTimerCreateTimerTask
  55              		.thumb
  56              		.thumb_func
  58              	xTimerCreateTimerTask:
  59              	.LFB0:
  60              		.file 1 "../FreeRTOS_Source/timers.c"
   1:../FreeRTOS_Source/timers.c **** /*
   2:../FreeRTOS_Source/timers.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS_Source/timers.c **** 
   4:../FreeRTOS_Source/timers.c **** 
   5:../FreeRTOS_Source/timers.c ****     ***************************************************************************
   6:../FreeRTOS_Source/timers.c ****      *                                                                       *
   7:../FreeRTOS_Source/timers.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS_Source/timers.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS_Source/timers.c ****      *    available.                                                         *
  10:../FreeRTOS_Source/timers.c ****      *                                                                       *
  11:../FreeRTOS_Source/timers.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS_Source/timers.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS_Source/timers.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS_Source/timers.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS_Source/timers.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS_Source/timers.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS_Source/timers.c ****      *                                                                       *
  18:../FreeRTOS_Source/timers.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS_Source/timers.c ****      *                                                                       *
  20:../FreeRTOS_Source/timers.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS_Source/timers.c ****      *                                                                       *
  22:../FreeRTOS_Source/timers.c ****     ***************************************************************************
  23:../FreeRTOS_Source/timers.c **** 
  24:../FreeRTOS_Source/timers.c **** 
  25:../FreeRTOS_Source/timers.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS_Source/timers.c **** 
  27:../FreeRTOS_Source/timers.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS_Source/timers.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS_Source/timers.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS_Source/timers.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS_Source/timers.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS_Source/timers.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS_Source/timers.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS_Source/timers.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS_Source/timers.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS_Source/timers.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS_Source/timers.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS_Source/timers.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS_Source/timers.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS_Source/timers.c ****     FreeRTOS WEB site.
  41:../FreeRTOS_Source/timers.c **** 
  42:../FreeRTOS_Source/timers.c ****     1 tab == 4 spaces!
  43:../FreeRTOS_Source/timers.c **** 
  44:../FreeRTOS_Source/timers.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS_Source/timers.c ****     contact details.
  46:../FreeRTOS_Source/timers.c **** 
  47:../FreeRTOS_Source/timers.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS_Source/timers.c ****     critical systems.
  49:../FreeRTOS_Source/timers.c **** 
  50:../FreeRTOS_Source/timers.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS_Source/timers.c ****     licensing and training services.
  52:../FreeRTOS_Source/timers.c **** */
  53:../FreeRTOS_Source/timers.c **** 
  54:../FreeRTOS_Source/timers.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  55:../FreeRTOS_Source/timers.c **** all the API functions to use the MPU wrappers.  That should only be done when
  56:../FreeRTOS_Source/timers.c **** task.h is included from an application file. */
  57:../FreeRTOS_Source/timers.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  58:../FreeRTOS_Source/timers.c **** 
  59:../FreeRTOS_Source/timers.c **** #include "FreeRTOS.h"
  60:../FreeRTOS_Source/timers.c **** #include "task.h"
  61:../FreeRTOS_Source/timers.c **** #include "queue.h"
  62:../FreeRTOS_Source/timers.c **** #include "timers.h"
  63:../FreeRTOS_Source/timers.c **** 
  64:../FreeRTOS_Source/timers.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  65:../FreeRTOS_Source/timers.c **** 
  66:../FreeRTOS_Source/timers.c **** /* This entire source file will be skipped if the application is not configured
  67:../FreeRTOS_Source/timers.c **** to include software timer functionality.  This #if is closed at the very bottom
  68:../FreeRTOS_Source/timers.c **** of this file.  If you want to include software timer functionality then ensure
  69:../FreeRTOS_Source/timers.c **** configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
  70:../FreeRTOS_Source/timers.c **** #if ( configUSE_TIMERS == 1 )
  71:../FreeRTOS_Source/timers.c **** 
  72:../FreeRTOS_Source/timers.c **** /* Misc definitions. */
  73:../FreeRTOS_Source/timers.c **** #define tmrNO_DELAY		( portTickType ) 0U
  74:../FreeRTOS_Source/timers.c **** 
  75:../FreeRTOS_Source/timers.c **** /* The definition of the timers themselves. */
  76:../FreeRTOS_Source/timers.c **** typedef struct tmrTimerControl
  77:../FreeRTOS_Source/timers.c **** {
  78:../FreeRTOS_Source/timers.c **** 	const signed char		*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included 
  79:../FreeRTOS_Source/timers.c **** 	xListItem				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for ev
  80:../FreeRTOS_Source/timers.c **** 	portTickType			xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
  81:../FreeRTOS_Source/timers.c **** 	unsigned portBASE_TYPE	uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically rest
  82:../FreeRTOS_Source/timers.c **** 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified 
  83:../FreeRTOS_Source/timers.c **** 	tmrTIMER_CALLBACK		pxCallbackFunction;	/*<< The function that will be called when the timer expire
  84:../FreeRTOS_Source/timers.c **** } xTIMER;
  85:../FreeRTOS_Source/timers.c **** 
  86:../FreeRTOS_Source/timers.c **** /* The definition of messages that can be sent and received on the timer
  87:../FreeRTOS_Source/timers.c **** queue. */
  88:../FreeRTOS_Source/timers.c **** typedef struct tmrTimerQueueMessage
  89:../FreeRTOS_Source/timers.c **** {
  90:../FreeRTOS_Source/timers.c **** 	portBASE_TYPE			xMessageID;			/*<< The command being sent to the timer service task. */
  91:../FreeRTOS_Source/timers.c **** 	portTickType			xMessageValue;		/*<< An optional value used by a subset of commands, for example, w
  92:../FreeRTOS_Source/timers.c **** 	xTIMER *				pxTimer;			/*<< The timer to which the command will be applied. */
  93:../FreeRTOS_Source/timers.c **** } xTIMER_MESSAGE;
  94:../FreeRTOS_Source/timers.c **** 
  95:../FreeRTOS_Source/timers.c **** 
  96:../FreeRTOS_Source/timers.c **** /* The list in which active timers are stored.  Timers are referenced in expire
  97:../FreeRTOS_Source/timers.c **** time order, with the nearest expiry time at the front of the list.  Only the
  98:../FreeRTOS_Source/timers.c **** timer service task is allowed to access xActiveTimerList. */
  99:../FreeRTOS_Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList1;
 100:../FreeRTOS_Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList2;
 101:../FreeRTOS_Source/timers.c **** PRIVILEGED_DATA static xList *pxCurrentTimerList;
 102:../FreeRTOS_Source/timers.c **** PRIVILEGED_DATA static xList *pxOverflowTimerList;
 103:../FreeRTOS_Source/timers.c **** 
 104:../FreeRTOS_Source/timers.c **** /* A queue that is used to send commands to the timer service task. */
 105:../FreeRTOS_Source/timers.c **** PRIVILEGED_DATA static xQueueHandle xTimerQueue = NULL;
 106:../FreeRTOS_Source/timers.c **** 
 107:../FreeRTOS_Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 108:../FreeRTOS_Source/timers.c **** 	
 109:../FreeRTOS_Source/timers.c **** 	PRIVILEGED_DATA static xTaskHandle xTimerTaskHandle = NULL;
 110:../FreeRTOS_Source/timers.c **** 	
 111:../FreeRTOS_Source/timers.c **** #endif
 112:../FreeRTOS_Source/timers.c **** 
 113:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 114:../FreeRTOS_Source/timers.c **** 
 115:../FreeRTOS_Source/timers.c **** /*
 116:../FreeRTOS_Source/timers.c ****  * Initialise the infrastructure used by the timer service task if it has not
 117:../FreeRTOS_Source/timers.c ****  * been initialised already.
 118:../FreeRTOS_Source/timers.c ****  */
 119:../FreeRTOS_Source/timers.c **** static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
 120:../FreeRTOS_Source/timers.c **** 
 121:../FreeRTOS_Source/timers.c **** /*
 122:../FreeRTOS_Source/timers.c ****  * The timer service task (daemon).  Timer functionality is controlled by this
 123:../FreeRTOS_Source/timers.c ****  * task.  Other tasks communicate with the timer service task using the
 124:../FreeRTOS_Source/timers.c ****  * xTimerQueue queue.
 125:../FreeRTOS_Source/timers.c ****  */
 126:../FreeRTOS_Source/timers.c **** static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
 127:../FreeRTOS_Source/timers.c **** 
 128:../FreeRTOS_Source/timers.c **** /*
 129:../FreeRTOS_Source/timers.c ****  * Called by the timer service task to interpret and process a command it
 130:../FreeRTOS_Source/timers.c ****  * received on the timer queue.
 131:../FreeRTOS_Source/timers.c ****  */
 132:../FreeRTOS_Source/timers.c **** static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
 133:../FreeRTOS_Source/timers.c **** 
 134:../FreeRTOS_Source/timers.c **** /*
 135:../FreeRTOS_Source/timers.c ****  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 136:../FreeRTOS_Source/timers.c ****  * depending on if the expire time causes a timer counter overflow.
 137:../FreeRTOS_Source/timers.c ****  */
 138:../FreeRTOS_Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 139:../FreeRTOS_Source/timers.c **** 
 140:../FreeRTOS_Source/timers.c **** /*
 141:../FreeRTOS_Source/timers.c ****  * An active timer has reached its expire time.  Reload the timer if it is an
 142:../FreeRTOS_Source/timers.c ****  * auto reload timer, then call its callback.
 143:../FreeRTOS_Source/timers.c ****  */
 144:../FreeRTOS_Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow ) PRIVILEGE
 145:../FreeRTOS_Source/timers.c **** 
 146:../FreeRTOS_Source/timers.c **** /*
 147:../FreeRTOS_Source/timers.c ****  * The tick count has overflowed.  Switch the timer lists after ensuring the
 148:../FreeRTOS_Source/timers.c ****  * current timer list does not still reference some timers.
 149:../FreeRTOS_Source/timers.c ****  */
 150:../FreeRTOS_Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime ) PRIVILEGED_FUNCTION;
 151:../FreeRTOS_Source/timers.c **** 
 152:../FreeRTOS_Source/timers.c **** /*
 153:../FreeRTOS_Source/timers.c ****  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 154:../FreeRTOS_Source/timers.c ****  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 155:../FreeRTOS_Source/timers.c ****  */
 156:../FreeRTOS_Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION
 157:../FreeRTOS_Source/timers.c **** 
 158:../FreeRTOS_Source/timers.c **** /*
 159:../FreeRTOS_Source/timers.c ****  * If the timer list contains any active timers then return the expire time of
 160:../FreeRTOS_Source/timers.c ****  * the timer that will expire first and set *pxListWasEmpty to false.  If the
 161:../FreeRTOS_Source/timers.c ****  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 162:../FreeRTOS_Source/timers.c ****  * to pdTRUE.
 163:../FreeRTOS_Source/timers.c ****  */
 164:../FreeRTOS_Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty ) PRIVILEGED_FUNCTION;
 165:../FreeRTOS_Source/timers.c **** 
 166:../FreeRTOS_Source/timers.c **** /*
 167:../FreeRTOS_Source/timers.c ****  * If a timer has expired, process it.  Otherwise, block the timer service task
 168:../FreeRTOS_Source/timers.c ****  * until either a timer does expire or a command is received.
 169:../FreeRTOS_Source/timers.c ****  */
 170:../FreeRTOS_Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 171:../FreeRTOS_Source/timers.c **** 
 172:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 173:../FreeRTOS_Source/timers.c **** 
 174:../FreeRTOS_Source/timers.c **** portBASE_TYPE xTimerCreateTimerTask( void )
 175:../FreeRTOS_Source/timers.c **** {
  61              		.loc 1 175 0
  62              		.cfi_startproc
  63              		@ args = 0, pretend = 0, frame = 8
  64              		@ frame_needed = 1, uses_anonymous_args = 0
  65 0000 80B5     		push	{r7, lr}
  66              	.LCFI0:
  67              		.cfi_def_cfa_offset 8
  68              		.cfi_offset 14, -4
  69              		.cfi_offset 7, -8
  70 0002 86B0     		sub	sp, sp, #24
  71              	.LCFI1:
  72              		.cfi_def_cfa_offset 32
  73 0004 04AF     		add	r7, sp, #16
  74              	.LCFI2:
  75              		.cfi_def_cfa 7, 16
 176:../FreeRTOS_Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
  76              		.loc 1 176 0
  77 0006 4FF00003 		mov	r3, #0
  78 000a 7B60     		str	r3, [r7, #4]
 177:../FreeRTOS_Source/timers.c **** 
 178:../FreeRTOS_Source/timers.c **** 	/* This function is called when the scheduler is started if
 179:../FreeRTOS_Source/timers.c **** 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
 180:../FreeRTOS_Source/timers.c **** 	timer service task has been created/initialised.  If timers have already
 181:../FreeRTOS_Source/timers.c **** 	been created then the initialisation will already have been performed. */
 182:../FreeRTOS_Source/timers.c **** 	prvCheckForValidListAndQueue();
  79              		.loc 1 182 0
  80 000c FFF7FEFF 		bl	prvCheckForValidListAndQueue
 183:../FreeRTOS_Source/timers.c **** 
 184:../FreeRTOS_Source/timers.c **** 	if( xTimerQueue != NULL )
  81              		.loc 1 184 0
  82 0010 40F20003 		movw	r3, #:lower16:xTimerQueue
  83 0014 C0F20003 		movt	r3, #:upper16:xTimerQueue
  84 0018 1B68     		ldr	r3, [r3, #0]
  85 001a 002B     		cmp	r3, #0
  86 001c 1AD0     		beq	.L2
 185:../FreeRTOS_Source/timers.c **** 	{
 186:../FreeRTOS_Source/timers.c **** 		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 187:../FreeRTOS_Source/timers.c **** 		{
 188:../FreeRTOS_Source/timers.c **** 			/* Create the timer task, storing its handle in xTimerTaskHandle so
 189:../FreeRTOS_Source/timers.c **** 			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
 190:../FreeRTOS_Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
 191:../FreeRTOS_Source/timers.c **** 		}
 192:../FreeRTOS_Source/timers.c **** 		#else
 193:../FreeRTOS_Source/timers.c **** 		{
 194:../FreeRTOS_Source/timers.c **** 			/* Create the timer task without storing its handle. */
 195:../FreeRTOS_Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
  87              		.loc 1 195 0
  88 001e 4FF00303 		mov	r3, #3
  89 0022 0093     		str	r3, [sp, #0]
  90 0024 4FF00003 		mov	r3, #0
  91 0028 0193     		str	r3, [sp, #4]
  92 002a 4FF00003 		mov	r3, #0
  93 002e 0293     		str	r3, [sp, #8]
  94 0030 4FF00003 		mov	r3, #0
  95 0034 0393     		str	r3, [sp, #12]
  96 0036 40F20000 		movw	r0, #:lower16:prvTimerTask
  97 003a C0F20000 		movt	r0, #:upper16:prvTimerTask
  98 003e 40F20001 		movw	r1, #:lower16:.LC0
  99 0042 C0F20001 		movt	r1, #:upper16:.LC0
 100 0046 4FF04602 		mov	r2, #70
 101 004a 4FF00003 		mov	r3, #0
 102 004e FFF7FEFF 		bl	xTaskGenericCreate
 103 0052 7860     		str	r0, [r7, #4]
 104              	.L2:
 196:../FreeRTOS_Source/timers.c **** 		}
 197:../FreeRTOS_Source/timers.c **** 		#endif
 198:../FreeRTOS_Source/timers.c **** 	}
 199:../FreeRTOS_Source/timers.c **** 
 200:../FreeRTOS_Source/timers.c **** 	configASSERT( xReturn );
 105              		.loc 1 200 0
 106 0054 7B68     		ldr	r3, [r7, #4]
 107 0056 002B     		cmp	r3, #0
 108 0058 04D1     		bne	.L3
 109              		.loc 1 200 0 is_stmt 0 discriminator 1
 110              	@ 200 "../FreeRTOS_Source/timers.c" 1
 111 005a 4FF05000 			mov r0, #80								
 112 005e 80F31188 		msr basepri, r0							
 113              	
 114              	@ 0 "" 2
 115              		.thumb
 116              	.L4:
 117              		.loc 1 200 0 discriminator 2
 118 0062 FEE7     		b	.L4
 119              	.L3:
 201:../FreeRTOS_Source/timers.c **** 	return xReturn;
 120              		.loc 1 201 0 is_stmt 1
 121 0064 7B68     		ldr	r3, [r7, #4]
 202:../FreeRTOS_Source/timers.c **** }
 122              		.loc 1 202 0
 123 0066 1846     		mov	r0, r3
 124 0068 07F10807 		add	r7, r7, #8
 125 006c BD46     		mov	sp, r7
 126 006e 80BD     		pop	{r7, pc}
 127              		.cfi_endproc
 128              	.LFE0:
 130              		.section	.text.xTimerCreate,"ax",%progbits
 131              		.align	2
 132              		.global	xTimerCreate
 133              		.thumb
 134              		.thumb_func
 136              	xTimerCreate:
 137              	.LFB1:
 203:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 204:../FreeRTOS_Source/timers.c **** 
 205:../FreeRTOS_Source/timers.c **** xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsign
 206:../FreeRTOS_Source/timers.c **** {
 138              		.loc 1 206 0
 139              		.cfi_startproc
 140              		@ args = 4, pretend = 0, frame = 24
 141              		@ frame_needed = 1, uses_anonymous_args = 0
 142 0000 80B5     		push	{r7, lr}
 143              	.LCFI3:
 144              		.cfi_def_cfa_offset 8
 145              		.cfi_offset 14, -4
 146              		.cfi_offset 7, -8
 147 0002 86B0     		sub	sp, sp, #24
 148              	.LCFI4:
 149              		.cfi_def_cfa_offset 32
 150 0004 00AF     		add	r7, sp, #0
 151              	.LCFI5:
 152              		.cfi_def_cfa_register 7
 153 0006 F860     		str	r0, [r7, #12]
 154 0008 B960     		str	r1, [r7, #8]
 155 000a 7A60     		str	r2, [r7, #4]
 156 000c 3B60     		str	r3, [r7, #0]
 207:../FreeRTOS_Source/timers.c **** xTIMER *pxNewTimer;
 208:../FreeRTOS_Source/timers.c **** 
 209:../FreeRTOS_Source/timers.c **** 	/* Allocate the timer structure. */
 210:../FreeRTOS_Source/timers.c **** 	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 157              		.loc 1 210 0
 158 000e BB68     		ldr	r3, [r7, #8]
 159 0010 002B     		cmp	r3, #0
 160 0012 0AD1     		bne	.L6
 211:../FreeRTOS_Source/timers.c **** 	{
 212:../FreeRTOS_Source/timers.c **** 		pxNewTimer = NULL;
 161              		.loc 1 212 0
 162 0014 4FF00003 		mov	r3, #0
 163 0018 7B61     		str	r3, [r7, #20]
 213:../FreeRTOS_Source/timers.c **** 		configASSERT( ( xTimerPeriodInTicks > 0 ) );
 164              		.loc 1 213 0
 165 001a BB68     		ldr	r3, [r7, #8]
 166 001c 002B     		cmp	r3, #0
 167 001e 23D1     		bne	.L7
 168              		.loc 1 213 0 is_stmt 0 discriminator 1
 169              	@ 213 "../FreeRTOS_Source/timers.c" 1
 170 0020 4FF05000 			mov r0, #80								
 171 0024 80F31188 		msr basepri, r0							
 172              	
 173              	@ 0 "" 2
 174              		.thumb
 175              	.L8:
 176              		.loc 1 213 0 discriminator 2
 177 0028 FEE7     		b	.L8
 178              	.L6:
 214:../FreeRTOS_Source/timers.c **** 	}
 215:../FreeRTOS_Source/timers.c **** 	else
 216:../FreeRTOS_Source/timers.c **** 	{
 217:../FreeRTOS_Source/timers.c **** 		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 179              		.loc 1 217 0 is_stmt 1
 180 002a 4FF02800 		mov	r0, #40
 181 002e FFF7FEFF 		bl	pvPortMalloc
 182 0032 7861     		str	r0, [r7, #20]
 218:../FreeRTOS_Source/timers.c **** 		if( pxNewTimer != NULL )
 183              		.loc 1 218 0
 184 0034 7B69     		ldr	r3, [r7, #20]
 185 0036 002B     		cmp	r3, #0
 186 0038 16D0     		beq	.L7
 219:../FreeRTOS_Source/timers.c **** 		{
 220:../FreeRTOS_Source/timers.c **** 			/* Ensure the infrastructure used by the timer service task has been
 221:../FreeRTOS_Source/timers.c **** 			created/initialised. */
 222:../FreeRTOS_Source/timers.c **** 			prvCheckForValidListAndQueue();
 187              		.loc 1 222 0
 188 003a FFF7FEFF 		bl	prvCheckForValidListAndQueue
 223:../FreeRTOS_Source/timers.c **** 	
 224:../FreeRTOS_Source/timers.c **** 			/* Initialise the timer structure members using the function parameters. */
 225:../FreeRTOS_Source/timers.c **** 			pxNewTimer->pcTimerName = pcTimerName;
 189              		.loc 1 225 0
 190 003e 7B69     		ldr	r3, [r7, #20]
 191 0040 FA68     		ldr	r2, [r7, #12]
 192 0042 1A60     		str	r2, [r3, #0]
 226:../FreeRTOS_Source/timers.c **** 			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 193              		.loc 1 226 0
 194 0044 7B69     		ldr	r3, [r7, #20]
 195 0046 BA68     		ldr	r2, [r7, #8]
 196 0048 9A61     		str	r2, [r3, #24]
 227:../FreeRTOS_Source/timers.c **** 			pxNewTimer->uxAutoReload = uxAutoReload;
 197              		.loc 1 227 0
 198 004a 7B69     		ldr	r3, [r7, #20]
 199 004c 7A68     		ldr	r2, [r7, #4]
 200 004e DA61     		str	r2, [r3, #28]
 228:../FreeRTOS_Source/timers.c **** 			pxNewTimer->pvTimerID = pvTimerID;
 201              		.loc 1 228 0
 202 0050 7B69     		ldr	r3, [r7, #20]
 203 0052 3A68     		ldr	r2, [r7, #0]
 204 0054 1A62     		str	r2, [r3, #32]
 229:../FreeRTOS_Source/timers.c **** 			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 205              		.loc 1 229 0
 206 0056 7B69     		ldr	r3, [r7, #20]
 207 0058 3A6A     		ldr	r2, [r7, #32]
 208 005a 5A62     		str	r2, [r3, #36]
 230:../FreeRTOS_Source/timers.c **** 			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 209              		.loc 1 230 0
 210 005c 7B69     		ldr	r3, [r7, #20]
 211 005e 03F10403 		add	r3, r3, #4
 212 0062 1846     		mov	r0, r3
 213 0064 FFF7FEFF 		bl	vListInitialiseItem
 214              	.L7:
 231:../FreeRTOS_Source/timers.c **** 			
 232:../FreeRTOS_Source/timers.c **** 			traceTIMER_CREATE( pxNewTimer );
 233:../FreeRTOS_Source/timers.c **** 		}
 234:../FreeRTOS_Source/timers.c **** 		else
 235:../FreeRTOS_Source/timers.c **** 		{
 236:../FreeRTOS_Source/timers.c **** 			traceTIMER_CREATE_FAILED();
 237:../FreeRTOS_Source/timers.c **** 		}
 238:../FreeRTOS_Source/timers.c **** 	}
 239:../FreeRTOS_Source/timers.c **** 	
 240:../FreeRTOS_Source/timers.c **** 	return ( xTimerHandle ) pxNewTimer;
 215              		.loc 1 240 0
 216 0068 7B69     		ldr	r3, [r7, #20]
 241:../FreeRTOS_Source/timers.c **** }
 217              		.loc 1 241 0
 218 006a 1846     		mov	r0, r3
 219 006c 07F11807 		add	r7, r7, #24
 220 0070 BD46     		mov	sp, r7
 221 0072 80BD     		pop	{r7, pc}
 222              		.cfi_endproc
 223              	.LFE1:
 225              		.section	.text.xTimerGenericCommand,"ax",%progbits
 226              		.align	2
 227              		.global	xTimerGenericCommand
 228              		.thumb
 229              		.thumb_func
 231              	xTimerGenericCommand:
 232              	.LFB2:
 242:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 243:../FreeRTOS_Source/timers.c **** 
 244:../FreeRTOS_Source/timers.c **** portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOp
 245:../FreeRTOS_Source/timers.c **** {
 233              		.loc 1 245 0
 234              		.cfi_startproc
 235              		@ args = 4, pretend = 0, frame = 32
 236              		@ frame_needed = 1, uses_anonymous_args = 0
 237 0000 80B5     		push	{r7, lr}
 238              	.LCFI6:
 239              		.cfi_def_cfa_offset 8
 240              		.cfi_offset 14, -4
 241              		.cfi_offset 7, -8
 242 0002 88B0     		sub	sp, sp, #32
 243              	.LCFI7:
 244              		.cfi_def_cfa_offset 40
 245 0004 00AF     		add	r7, sp, #0
 246              	.LCFI8:
 247              		.cfi_def_cfa_register 7
 248 0006 F860     		str	r0, [r7, #12]
 249 0008 B960     		str	r1, [r7, #8]
 250 000a 7A60     		str	r2, [r7, #4]
 251 000c 3B60     		str	r3, [r7, #0]
 246:../FreeRTOS_Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
 252              		.loc 1 246 0
 253 000e 4FF00003 		mov	r3, #0
 254 0012 FB61     		str	r3, [r7, #28]
 247:../FreeRTOS_Source/timers.c **** xTIMER_MESSAGE xMessage;
 248:../FreeRTOS_Source/timers.c **** 
 249:../FreeRTOS_Source/timers.c **** 	/* Send a message to the timer service task to perform a particular action
 250:../FreeRTOS_Source/timers.c **** 	on a particular timer definition. */
 251:../FreeRTOS_Source/timers.c **** 	if( xTimerQueue != NULL )
 255              		.loc 1 251 0
 256 0014 40F20003 		movw	r3, #:lower16:xTimerQueue
 257 0018 C0F20003 		movt	r3, #:upper16:xTimerQueue
 258 001c 1B68     		ldr	r3, [r3, #0]
 259 001e 002B     		cmp	r3, #0
 260 0020 3DD0     		beq	.L10
 252:../FreeRTOS_Source/timers.c **** 	{
 253:../FreeRTOS_Source/timers.c **** 		/* Send a command to the timer service task to start the xTimer timer. */
 254:../FreeRTOS_Source/timers.c **** 		xMessage.xMessageID = xCommandID;
 261              		.loc 1 254 0
 262 0022 BB68     		ldr	r3, [r7, #8]
 263 0024 3B61     		str	r3, [r7, #16]
 255:../FreeRTOS_Source/timers.c **** 		xMessage.xMessageValue = xOptionalValue;
 264              		.loc 1 255 0
 265 0026 7B68     		ldr	r3, [r7, #4]
 266 0028 7B61     		str	r3, [r7, #20]
 256:../FreeRTOS_Source/timers.c **** 		xMessage.pxTimer = ( xTIMER * ) xTimer;
 267              		.loc 1 256 0
 268 002a FB68     		ldr	r3, [r7, #12]
 269 002c BB61     		str	r3, [r7, #24]
 257:../FreeRTOS_Source/timers.c **** 
 258:../FreeRTOS_Source/timers.c **** 		if( pxHigherPriorityTaskWoken == NULL )
 270              		.loc 1 258 0
 271 002e 3B68     		ldr	r3, [r7, #0]
 272 0030 002B     		cmp	r3, #0
 273 0032 25D1     		bne	.L11
 259:../FreeRTOS_Source/timers.c **** 		{
 260:../FreeRTOS_Source/timers.c **** 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 274              		.loc 1 260 0
 275 0034 FFF7FEFF 		bl	xTaskGetSchedulerState
 276 0038 0346     		mov	r3, r0
 277 003a 012B     		cmp	r3, #1
 278 003c 0FD1     		bne	.L12
 261:../FreeRTOS_Source/timers.c **** 			{
 262:../FreeRTOS_Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 279              		.loc 1 262 0
 280 003e 40F20003 		movw	r3, #:lower16:xTimerQueue
 281 0042 C0F20003 		movt	r3, #:upper16:xTimerQueue
 282 0046 1A68     		ldr	r2, [r3, #0]
 283 0048 07F11003 		add	r3, r7, #16
 284 004c 1046     		mov	r0, r2
 285 004e 1946     		mov	r1, r3
 286 0050 BA6A     		ldr	r2, [r7, #40]
 287 0052 4FF00003 		mov	r3, #0
 288 0056 FFF7FEFF 		bl	xQueueGenericSend
 289 005a F861     		str	r0, [r7, #28]
 290 005c 1FE0     		b	.L10
 291              	.L12:
 263:../FreeRTOS_Source/timers.c **** 			}
 264:../FreeRTOS_Source/timers.c **** 			else
 265:../FreeRTOS_Source/timers.c **** 			{
 266:../FreeRTOS_Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 292              		.loc 1 266 0
 293 005e 40F20003 		movw	r3, #:lower16:xTimerQueue
 294 0062 C0F20003 		movt	r3, #:upper16:xTimerQueue
 295 0066 1A68     		ldr	r2, [r3, #0]
 296 0068 07F11003 		add	r3, r7, #16
 297 006c 1046     		mov	r0, r2
 298 006e 1946     		mov	r1, r3
 299 0070 4FF00002 		mov	r2, #0
 300 0074 4FF00003 		mov	r3, #0
 301 0078 FFF7FEFF 		bl	xQueueGenericSend
 302 007c F861     		str	r0, [r7, #28]
 303 007e 0EE0     		b	.L10
 304              	.L11:
 267:../FreeRTOS_Source/timers.c **** 			}
 268:../FreeRTOS_Source/timers.c **** 		}
 269:../FreeRTOS_Source/timers.c **** 		else
 270:../FreeRTOS_Source/timers.c **** 		{
 271:../FreeRTOS_Source/timers.c **** 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 305              		.loc 1 271 0
 306 0080 40F20003 		movw	r3, #:lower16:xTimerQueue
 307 0084 C0F20003 		movt	r3, #:upper16:xTimerQueue
 308 0088 1A68     		ldr	r2, [r3, #0]
 309 008a 07F11003 		add	r3, r7, #16
 310 008e 1046     		mov	r0, r2
 311 0090 1946     		mov	r1, r3
 312 0092 3A68     		ldr	r2, [r7, #0]
 313 0094 4FF00003 		mov	r3, #0
 314 0098 FFF7FEFF 		bl	xQueueGenericSendFromISR
 315 009c F861     		str	r0, [r7, #28]
 316              	.L10:
 272:../FreeRTOS_Source/timers.c **** 		}
 273:../FreeRTOS_Source/timers.c **** 		
 274:../FreeRTOS_Source/timers.c **** 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
 275:../FreeRTOS_Source/timers.c **** 	}
 276:../FreeRTOS_Source/timers.c **** 	
 277:../FreeRTOS_Source/timers.c **** 	return xReturn;
 317              		.loc 1 277 0
 318 009e FB69     		ldr	r3, [r7, #28]
 278:../FreeRTOS_Source/timers.c **** }
 319              		.loc 1 278 0
 320 00a0 1846     		mov	r0, r3
 321 00a2 07F12007 		add	r7, r7, #32
 322 00a6 BD46     		mov	sp, r7
 323 00a8 80BD     		pop	{r7, pc}
 324              		.cfi_endproc
 325              	.LFE2:
 327 00aa 00BF     		.section	.text.prvProcessExpiredTimer,"ax",%progbits
 328              		.align	2
 329              		.thumb
 330              		.thumb_func
 332              	prvProcessExpiredTimer:
 333              	.LFB3:
 279:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 280:../FreeRTOS_Source/timers.c **** 
 281:../FreeRTOS_Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 282:../FreeRTOS_Source/timers.c **** 
 283:../FreeRTOS_Source/timers.c **** 	xTaskHandle xTimerGetTimerDaemonTaskHandle( void )
 284:../FreeRTOS_Source/timers.c **** 	{
 285:../FreeRTOS_Source/timers.c **** 		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 286:../FreeRTOS_Source/timers.c **** 		started, then xTimerTaskHandle will be NULL. */
 287:../FreeRTOS_Source/timers.c **** 		configASSERT( ( xTimerTaskHandle != NULL ) );
 288:../FreeRTOS_Source/timers.c **** 		return xTimerTaskHandle;
 289:../FreeRTOS_Source/timers.c **** 	}
 290:../FreeRTOS_Source/timers.c **** 	
 291:../FreeRTOS_Source/timers.c **** #endif
 292:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 293:../FreeRTOS_Source/timers.c **** 
 294:../FreeRTOS_Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
 295:../FreeRTOS_Source/timers.c **** {
 334              		.loc 1 295 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 16
 337              		@ frame_needed = 1, uses_anonymous_args = 0
 338 0000 80B5     		push	{r7, lr}
 339              	.LCFI9:
 340              		.cfi_def_cfa_offset 8
 341              		.cfi_offset 14, -4
 342              		.cfi_offset 7, -8
 343 0002 86B0     		sub	sp, sp, #24
 344              	.LCFI10:
 345              		.cfi_def_cfa_offset 32
 346 0004 02AF     		add	r7, sp, #8
 347              	.LCFI11:
 348              		.cfi_def_cfa 7, 24
 349 0006 7860     		str	r0, [r7, #4]
 350 0008 3960     		str	r1, [r7, #0]
 296:../FreeRTOS_Source/timers.c **** xTIMER *pxTimer;
 297:../FreeRTOS_Source/timers.c **** portBASE_TYPE xResult;
 298:../FreeRTOS_Source/timers.c **** 
 299:../FreeRTOS_Source/timers.c **** 	/* Remove the timer from the list of active timers.  A check has already
 300:../FreeRTOS_Source/timers.c **** 	been performed to ensure the list is not empty. */
 301:../FreeRTOS_Source/timers.c **** 	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 351              		.loc 1 301 0
 352 000a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 353 000e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 354 0012 1B68     		ldr	r3, [r3, #0]
 355 0014 DB68     		ldr	r3, [r3, #12]
 356 0016 DB68     		ldr	r3, [r3, #12]
 357 0018 FB60     		str	r3, [r7, #12]
 302:../FreeRTOS_Source/timers.c **** 	vListRemove( &( pxTimer->xTimerListItem ) );
 358              		.loc 1 302 0
 359 001a FB68     		ldr	r3, [r7, #12]
 360 001c 03F10403 		add	r3, r3, #4
 361 0020 1846     		mov	r0, r3
 362 0022 FFF7FEFF 		bl	vListRemove
 303:../FreeRTOS_Source/timers.c **** 	traceTIMER_EXPIRED( pxTimer );
 304:../FreeRTOS_Source/timers.c **** 
 305:../FreeRTOS_Source/timers.c **** 	/* If the timer is an auto reload timer then calculate the next
 306:../FreeRTOS_Source/timers.c **** 	expiry time and re-insert the timer in the list of active timers. */
 307:../FreeRTOS_Source/timers.c **** 	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 363              		.loc 1 307 0
 364 0026 FB68     		ldr	r3, [r7, #12]
 365 0028 DB69     		ldr	r3, [r3, #28]
 366 002a 012B     		cmp	r3, #1
 367 002c 20D1     		bne	.L14
 308:../FreeRTOS_Source/timers.c **** 	{
 309:../FreeRTOS_Source/timers.c **** 		/* This is the only time a timer is inserted into a list using
 310:../FreeRTOS_Source/timers.c **** 		a time relative to anything other than the current time.  It
 311:../FreeRTOS_Source/timers.c **** 		will therefore be inserted into the correct list relative to
 312:../FreeRTOS_Source/timers.c **** 		the time this task thinks it is now, even if a command to
 313:../FreeRTOS_Source/timers.c **** 		switch lists due to a tick count overflow is already waiting in
 314:../FreeRTOS_Source/timers.c **** 		the timer queue. */
 315:../FreeRTOS_Source/timers.c **** 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTim
 368              		.loc 1 315 0
 369 002e FB68     		ldr	r3, [r7, #12]
 370 0030 9A69     		ldr	r2, [r3, #24]
 371 0032 7B68     		ldr	r3, [r7, #4]
 372 0034 D318     		adds	r3, r2, r3
 373 0036 F868     		ldr	r0, [r7, #12]
 374 0038 1946     		mov	r1, r3
 375 003a 3A68     		ldr	r2, [r7, #0]
 376 003c 7B68     		ldr	r3, [r7, #4]
 377 003e FFF7FEFF 		bl	prvInsertTimerInActiveList
 378 0042 0346     		mov	r3, r0
 379 0044 012B     		cmp	r3, #1
 380 0046 13D1     		bne	.L14
 316:../FreeRTOS_Source/timers.c **** 		{
 317:../FreeRTOS_Source/timers.c **** 			/* The timer expired before it was added to the active timer
 318:../FreeRTOS_Source/timers.c **** 			list.  Reload it now.  */
 319:../FreeRTOS_Source/timers.c **** 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 381              		.loc 1 319 0
 382 0048 4FF00003 		mov	r3, #0
 383 004c 0093     		str	r3, [sp, #0]
 384 004e F868     		ldr	r0, [r7, #12]
 385 0050 4FF00001 		mov	r1, #0
 386 0054 7A68     		ldr	r2, [r7, #4]
 387 0056 4FF00003 		mov	r3, #0
 388 005a FFF7FEFF 		bl	xTimerGenericCommand
 389 005e B860     		str	r0, [r7, #8]
 320:../FreeRTOS_Source/timers.c **** 			configASSERT( xResult );
 390              		.loc 1 320 0
 391 0060 BB68     		ldr	r3, [r7, #8]
 392 0062 002B     		cmp	r3, #0
 393 0064 04D1     		bne	.L14
 394              		.loc 1 320 0 is_stmt 0 discriminator 1
 395              	@ 320 "../FreeRTOS_Source/timers.c" 1
 396 0066 4FF05000 			mov r0, #80								
 397 006a 80F31188 		msr basepri, r0							
 398              	
 399              	@ 0 "" 2
 400              		.thumb
 401              	.L15:
 402              		.loc 1 320 0 discriminator 2
 403 006e FEE7     		b	.L15
 404              	.L14:
 321:../FreeRTOS_Source/timers.c **** 			( void ) xResult;
 322:../FreeRTOS_Source/timers.c **** 		}
 323:../FreeRTOS_Source/timers.c **** 	}
 324:../FreeRTOS_Source/timers.c **** 
 325:../FreeRTOS_Source/timers.c **** 	/* Call the timer callback. */
 326:../FreeRTOS_Source/timers.c **** 	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 405              		.loc 1 326 0 is_stmt 1
 406 0070 FB68     		ldr	r3, [r7, #12]
 407 0072 5B6A     		ldr	r3, [r3, #36]
 408 0074 F868     		ldr	r0, [r7, #12]
 409 0076 9847     		blx	r3
 327:../FreeRTOS_Source/timers.c **** }
 410              		.loc 1 327 0
 411 0078 07F11007 		add	r7, r7, #16
 412 007c BD46     		mov	sp, r7
 413 007e 80BD     		pop	{r7, pc}
 414              		.cfi_endproc
 415              	.LFE3:
 417              		.section	.text.prvTimerTask,"ax",%progbits
 418              		.align	2
 419              		.thumb
 420              		.thumb_func
 422              	prvTimerTask:
 423              	.LFB4:
 328:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 329:../FreeRTOS_Source/timers.c **** 
 330:../FreeRTOS_Source/timers.c **** static void prvTimerTask( void *pvParameters )
 331:../FreeRTOS_Source/timers.c **** {
 424              		.loc 1 331 0
 425              		.cfi_startproc
 426              		@ args = 0, pretend = 0, frame = 16
 427              		@ frame_needed = 1, uses_anonymous_args = 0
 428 0000 80B5     		push	{r7, lr}
 429              	.LCFI12:
 430              		.cfi_def_cfa_offset 8
 431              		.cfi_offset 14, -4
 432              		.cfi_offset 7, -8
 433 0002 84B0     		sub	sp, sp, #16
 434              	.LCFI13:
 435              		.cfi_def_cfa_offset 24
 436 0004 00AF     		add	r7, sp, #0
 437              	.LCFI14:
 438              		.cfi_def_cfa_register 7
 439 0006 7860     		str	r0, [r7, #4]
 440              	.L17:
 332:../FreeRTOS_Source/timers.c **** portTickType xNextExpireTime;
 333:../FreeRTOS_Source/timers.c **** portBASE_TYPE xListWasEmpty;
 334:../FreeRTOS_Source/timers.c **** 
 335:../FreeRTOS_Source/timers.c **** 	/* Just to avoid compiler warnings. */
 336:../FreeRTOS_Source/timers.c **** 	( void ) pvParameters;
 337:../FreeRTOS_Source/timers.c **** 
 338:../FreeRTOS_Source/timers.c **** 	for( ;; )
 339:../FreeRTOS_Source/timers.c **** 	{
 340:../FreeRTOS_Source/timers.c **** 		/* Query the timers list to see if it contains any timers, and if so,
 341:../FreeRTOS_Source/timers.c **** 		obtain the time at which the next timer will expire. */
 342:../FreeRTOS_Source/timers.c **** 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 441              		.loc 1 342 0 discriminator 1
 442 0008 07F10803 		add	r3, r7, #8
 443 000c 1846     		mov	r0, r3
 444 000e FFF7FEFF 		bl	prvGetNextExpireTime
 445 0012 F860     		str	r0, [r7, #12]
 343:../FreeRTOS_Source/timers.c **** 
 344:../FreeRTOS_Source/timers.c **** 		/* If a timer has expired, process it.  Otherwise, block this task
 345:../FreeRTOS_Source/timers.c **** 		until either a timer does expire, or a command is received. */
 346:../FreeRTOS_Source/timers.c **** 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 446              		.loc 1 346 0 discriminator 1
 447 0014 BB68     		ldr	r3, [r7, #8]
 448 0016 F868     		ldr	r0, [r7, #12]
 449 0018 1946     		mov	r1, r3
 450 001a FFF7FEFF 		bl	prvProcessTimerOrBlockTask
 347:../FreeRTOS_Source/timers.c **** 		
 348:../FreeRTOS_Source/timers.c **** 		/* Empty the command queue. */
 349:../FreeRTOS_Source/timers.c **** 		prvProcessReceivedCommands();		
 451              		.loc 1 349 0 discriminator 1
 452 001e FFF7FEFF 		bl	prvProcessReceivedCommands
 350:../FreeRTOS_Source/timers.c **** 	}
 453              		.loc 1 350 0 discriminator 1
 454 0022 F1E7     		b	.L17
 455              		.cfi_endproc
 456              	.LFE4:
 458              		.section	.text.prvProcessTimerOrBlockTask,"ax",%progbits
 459              		.align	2
 460              		.thumb
 461              		.thumb_func
 463              	prvProcessTimerOrBlockTask:
 464              	.LFB5:
 351:../FreeRTOS_Source/timers.c **** }
 352:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 353:../FreeRTOS_Source/timers.c **** 
 354:../FreeRTOS_Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 355:../FreeRTOS_Source/timers.c **** {
 465              		.loc 1 355 0
 466              		.cfi_startproc
 467              		@ args = 0, pretend = 0, frame = 16
 468              		@ frame_needed = 1, uses_anonymous_args = 0
 469 0000 80B5     		push	{r7, lr}
 470              	.LCFI15:
 471              		.cfi_def_cfa_offset 8
 472              		.cfi_offset 14, -4
 473              		.cfi_offset 7, -8
 474 0002 84B0     		sub	sp, sp, #16
 475              	.LCFI16:
 476              		.cfi_def_cfa_offset 24
 477 0004 00AF     		add	r7, sp, #0
 478              	.LCFI17:
 479              		.cfi_def_cfa_register 7
 480 0006 7860     		str	r0, [r7, #4]
 481 0008 3960     		str	r1, [r7, #0]
 356:../FreeRTOS_Source/timers.c **** portTickType xTimeNow;
 357:../FreeRTOS_Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched;
 358:../FreeRTOS_Source/timers.c **** 
 359:../FreeRTOS_Source/timers.c **** 	vTaskSuspendAll();
 482              		.loc 1 359 0
 483 000a FFF7FEFF 		bl	vTaskSuspendAll
 360:../FreeRTOS_Source/timers.c **** 	{
 361:../FreeRTOS_Source/timers.c **** 		/* Obtain the time now to make an assessment as to whether the timer
 362:../FreeRTOS_Source/timers.c **** 		has expired or not.  If obtaining the time causes the lists to switch
 363:../FreeRTOS_Source/timers.c **** 		then don't process this timer as any timers that remained in the list
 364:../FreeRTOS_Source/timers.c **** 		when the lists were switched will have been processed within the
 365:../FreeRTOS_Source/timers.c **** 		prvSampelTimeNow() function. */
 366:../FreeRTOS_Source/timers.c **** 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 484              		.loc 1 366 0
 485 000e 07F10803 		add	r3, r7, #8
 486 0012 1846     		mov	r0, r3
 487 0014 FFF7FEFF 		bl	prvSampleTimeNow
 488 0018 F860     		str	r0, [r7, #12]
 367:../FreeRTOS_Source/timers.c **** 		if( xTimerListsWereSwitched == pdFALSE )
 489              		.loc 1 367 0
 490 001a BB68     		ldr	r3, [r7, #8]
 491 001c 002B     		cmp	r3, #0
 492 001e 21D1     		bne	.L19
 368:../FreeRTOS_Source/timers.c **** 		{
 369:../FreeRTOS_Source/timers.c **** 			/* The tick count has not overflowed, has the timer expired? */
 370:../FreeRTOS_Source/timers.c **** 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 493              		.loc 1 370 0
 494 0020 3B68     		ldr	r3, [r7, #0]
 495 0022 002B     		cmp	r3, #0
 496 0024 0AD1     		bne	.L20
 497              		.loc 1 370 0 is_stmt 0 discriminator 1
 498 0026 7A68     		ldr	r2, [r7, #4]
 499 0028 FB68     		ldr	r3, [r7, #12]
 500 002a 9A42     		cmp	r2, r3
 501 002c 06D8     		bhi	.L20
 371:../FreeRTOS_Source/timers.c **** 			{
 372:../FreeRTOS_Source/timers.c **** 				xTaskResumeAll();
 502              		.loc 1 372 0 is_stmt 1
 503 002e FFF7FEFF 		bl	xTaskResumeAll
 373:../FreeRTOS_Source/timers.c **** 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 504              		.loc 1 373 0
 505 0032 7868     		ldr	r0, [r7, #4]
 506 0034 F968     		ldr	r1, [r7, #12]
 507 0036 FFF7FEFF 		bl	prvProcessExpiredTimer
 508 003a 17E0     		b	.L18
 509              	.L20:
 374:../FreeRTOS_Source/timers.c **** 			}
 375:../FreeRTOS_Source/timers.c **** 			else
 376:../FreeRTOS_Source/timers.c **** 			{
 377:../FreeRTOS_Source/timers.c **** 				/* The tick count has not overflowed, and the next expire
 378:../FreeRTOS_Source/timers.c **** 				time has not been reached yet.  This task should therefore
 379:../FreeRTOS_Source/timers.c **** 				block to wait for the next expire time or a command to be
 380:../FreeRTOS_Source/timers.c **** 				received - whichever comes first.  The following line cannot
 381:../FreeRTOS_Source/timers.c **** 				be reached unless xNextExpireTime > xTimeNow, except in the
 382:../FreeRTOS_Source/timers.c **** 				case when the current timer list is empty. */
 383:../FreeRTOS_Source/timers.c **** 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 510              		.loc 1 383 0
 511 003c 40F20003 		movw	r3, #:lower16:xTimerQueue
 512 0040 C0F20003 		movt	r3, #:upper16:xTimerQueue
 513 0044 1A68     		ldr	r2, [r3, #0]
 514 0046 7968     		ldr	r1, [r7, #4]
 515 0048 FB68     		ldr	r3, [r7, #12]
 516 004a CB1A     		subs	r3, r1, r3
 517 004c 1046     		mov	r0, r2
 518 004e 1946     		mov	r1, r3
 519 0050 FFF7FEFF 		bl	vQueueWaitForMessageRestricted
 384:../FreeRTOS_Source/timers.c **** 
 385:../FreeRTOS_Source/timers.c **** 				if( xTaskResumeAll() == pdFALSE )
 520              		.loc 1 385 0
 521 0054 FFF7FEFF 		bl	xTaskResumeAll
 522 0058 0346     		mov	r3, r0
 523 005a 002B     		cmp	r3, #0
 524 005c 05D1     		bne	.L23
 386:../FreeRTOS_Source/timers.c **** 				{
 387:../FreeRTOS_Source/timers.c **** 					/* Yield to wait for either a command to arrive, or the block time
 388:../FreeRTOS_Source/timers.c **** 					to expire.  If a command arrived between the critical section being
 389:../FreeRTOS_Source/timers.c **** 					exited and this yield then the yield will not cause the task
 390:../FreeRTOS_Source/timers.c **** 					to block. */
 391:../FreeRTOS_Source/timers.c **** 					portYIELD_WITHIN_API();
 525              		.loc 1 391 0
 526 005e FFF7FEFF 		bl	vPortYieldFromISR
 527 0062 02E0     		b	.L23
 528              	.L19:
 392:../FreeRTOS_Source/timers.c **** 				}
 393:../FreeRTOS_Source/timers.c **** 			}
 394:../FreeRTOS_Source/timers.c **** 		}
 395:../FreeRTOS_Source/timers.c **** 		else
 396:../FreeRTOS_Source/timers.c **** 		{
 397:../FreeRTOS_Source/timers.c **** 			xTaskResumeAll();
 529              		.loc 1 397 0
 530 0064 FFF7FEFF 		bl	xTaskResumeAll
 531 0068 00E0     		b	.L18
 532              	.L23:
 391:../FreeRTOS_Source/timers.c **** 					portYIELD_WITHIN_API();
 533              		.loc 1 391 0
 534 006a 00BF     		nop
 535              	.L18:
 398:../FreeRTOS_Source/timers.c **** 		}
 399:../FreeRTOS_Source/timers.c **** 	}
 400:../FreeRTOS_Source/timers.c **** }
 536              		.loc 1 400 0
 537 006c 07F11007 		add	r7, r7, #16
 538 0070 BD46     		mov	sp, r7
 539 0072 80BD     		pop	{r7, pc}
 540              		.cfi_endproc
 541              	.LFE5:
 543              		.section	.text.prvGetNextExpireTime,"ax",%progbits
 544              		.align	2
 545              		.thumb
 546              		.thumb_func
 548              	prvGetNextExpireTime:
 549              	.LFB6:
 401:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 402:../FreeRTOS_Source/timers.c **** 
 403:../FreeRTOS_Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
 404:../FreeRTOS_Source/timers.c **** {
 550              		.loc 1 404 0
 551              		.cfi_startproc
 552              		@ args = 0, pretend = 0, frame = 16
 553              		@ frame_needed = 1, uses_anonymous_args = 0
 554              		@ link register save eliminated.
 555 0000 80B4     		push	{r7}
 556              	.LCFI18:
 557              		.cfi_def_cfa_offset 4
 558              		.cfi_offset 7, -4
 559 0002 85B0     		sub	sp, sp, #20
 560              	.LCFI19:
 561              		.cfi_def_cfa_offset 24
 562 0004 00AF     		add	r7, sp, #0
 563              	.LCFI20:
 564              		.cfi_def_cfa_register 7
 565 0006 7860     		str	r0, [r7, #4]
 405:../FreeRTOS_Source/timers.c **** portTickType xNextExpireTime;
 406:../FreeRTOS_Source/timers.c **** 
 407:../FreeRTOS_Source/timers.c **** 	/* Timers are listed in expiry time order, with the head of the list
 408:../FreeRTOS_Source/timers.c **** 	referencing the task that will expire first.  Obtain the time at which
 409:../FreeRTOS_Source/timers.c **** 	the timer with the nearest expiry time will expire.  If there are no
 410:../FreeRTOS_Source/timers.c **** 	active timers then just set the next expire time to 0.  That will cause
 411:../FreeRTOS_Source/timers.c **** 	this task to unblock when the tick count overflows, at which point the
 412:../FreeRTOS_Source/timers.c **** 	timer lists will be switched and the next expiry time can be
 413:../FreeRTOS_Source/timers.c **** 	re-assessed.  */
 414:../FreeRTOS_Source/timers.c **** 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 566              		.loc 1 414 0
 567 0008 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 568 000c C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 569 0010 1B68     		ldr	r3, [r3, #0]
 570 0012 1B68     		ldr	r3, [r3, #0]
 571 0014 002B     		cmp	r3, #0
 572 0016 14BF     		ite	ne
 573 0018 0022     		movne	r2, #0
 574 001a 0122     		moveq	r2, #1
 575 001c 7B68     		ldr	r3, [r7, #4]
 576 001e 1A60     		str	r2, [r3, #0]
 415:../FreeRTOS_Source/timers.c **** 	if( *pxListWasEmpty == pdFALSE )
 577              		.loc 1 415 0
 578 0020 7B68     		ldr	r3, [r7, #4]
 579 0022 1B68     		ldr	r3, [r3, #0]
 580 0024 002B     		cmp	r3, #0
 581 0026 08D1     		bne	.L25
 416:../FreeRTOS_Source/timers.c **** 	{
 417:../FreeRTOS_Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 582              		.loc 1 417 0
 583 0028 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 584 002c C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 585 0030 1B68     		ldr	r3, [r3, #0]
 586 0032 DB68     		ldr	r3, [r3, #12]
 587 0034 1B68     		ldr	r3, [r3, #0]
 588 0036 FB60     		str	r3, [r7, #12]
 589 0038 02E0     		b	.L26
 590              	.L25:
 418:../FreeRTOS_Source/timers.c **** 	}
 419:../FreeRTOS_Source/timers.c **** 	else
 420:../FreeRTOS_Source/timers.c **** 	{
 421:../FreeRTOS_Source/timers.c **** 		/* Ensure the task unblocks when the tick count rolls over. */
 422:../FreeRTOS_Source/timers.c **** 		xNextExpireTime = ( portTickType ) 0U;
 591              		.loc 1 422 0
 592 003a 4FF00003 		mov	r3, #0
 593 003e FB60     		str	r3, [r7, #12]
 594              	.L26:
 423:../FreeRTOS_Source/timers.c **** 	}
 424:../FreeRTOS_Source/timers.c **** 
 425:../FreeRTOS_Source/timers.c **** 	return xNextExpireTime;
 595              		.loc 1 425 0
 596 0040 FB68     		ldr	r3, [r7, #12]
 426:../FreeRTOS_Source/timers.c **** }
 597              		.loc 1 426 0
 598 0042 1846     		mov	r0, r3
 599 0044 07F11407 		add	r7, r7, #20
 600 0048 BD46     		mov	sp, r7
 601 004a 80BC     		pop	{r7}
 602 004c 7047     		bx	lr
 603              		.cfi_endproc
 604              	.LFE6:
 606 004e 00BF     		.section	.text.prvSampleTimeNow,"ax",%progbits
 607              		.align	2
 608              		.thumb
 609              		.thumb_func
 611              	prvSampleTimeNow:
 612              	.LFB7:
 427:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 428:../FreeRTOS_Source/timers.c **** 
 429:../FreeRTOS_Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
 430:../FreeRTOS_Source/timers.c **** {
 613              		.loc 1 430 0
 614              		.cfi_startproc
 615              		@ args = 0, pretend = 0, frame = 16
 616              		@ frame_needed = 1, uses_anonymous_args = 0
 617 0000 80B5     		push	{r7, lr}
 618              	.LCFI21:
 619              		.cfi_def_cfa_offset 8
 620              		.cfi_offset 14, -4
 621              		.cfi_offset 7, -8
 622 0002 84B0     		sub	sp, sp, #16
 623              	.LCFI22:
 624              		.cfi_def_cfa_offset 24
 625 0004 00AF     		add	r7, sp, #0
 626              	.LCFI23:
 627              		.cfi_def_cfa_register 7
 628 0006 7860     		str	r0, [r7, #4]
 431:../FreeRTOS_Source/timers.c **** portTickType xTimeNow;
 432:../FreeRTOS_Source/timers.c **** static portTickType xLastTime = ( portTickType ) 0U;
 433:../FreeRTOS_Source/timers.c **** 
 434:../FreeRTOS_Source/timers.c **** 	xTimeNow = xTaskGetTickCount();
 629              		.loc 1 434 0
 630 0008 FFF7FEFF 		bl	xTaskGetTickCount
 631 000c F860     		str	r0, [r7, #12]
 435:../FreeRTOS_Source/timers.c **** 	
 436:../FreeRTOS_Source/timers.c **** 	if( xTimeNow < xLastTime )
 632              		.loc 1 436 0
 633 000e 40F20003 		movw	r3, #:lower16:xLastTime.4289
 634 0012 C0F20003 		movt	r3, #:upper16:xLastTime.4289
 635 0016 1B68     		ldr	r3, [r3, #0]
 636 0018 FA68     		ldr	r2, [r7, #12]
 637 001a 9A42     		cmp	r2, r3
 638 001c 0CD2     		bcs	.L28
 437:../FreeRTOS_Source/timers.c **** 	{
 438:../FreeRTOS_Source/timers.c **** 		prvSwitchTimerLists( xLastTime );
 639              		.loc 1 438 0
 640 001e 40F20003 		movw	r3, #:lower16:xLastTime.4289
 641 0022 C0F20003 		movt	r3, #:upper16:xLastTime.4289
 642 0026 1B68     		ldr	r3, [r3, #0]
 643 0028 1846     		mov	r0, r3
 644 002a FFF7FEFF 		bl	prvSwitchTimerLists
 439:../FreeRTOS_Source/timers.c **** 		*pxTimerListsWereSwitched = pdTRUE;
 645              		.loc 1 439 0
 646 002e 7B68     		ldr	r3, [r7, #4]
 647 0030 4FF00102 		mov	r2, #1
 648 0034 1A60     		str	r2, [r3, #0]
 649 0036 03E0     		b	.L29
 650              	.L28:
 440:../FreeRTOS_Source/timers.c **** 	}
 441:../FreeRTOS_Source/timers.c **** 	else
 442:../FreeRTOS_Source/timers.c **** 	{
 443:../FreeRTOS_Source/timers.c **** 		*pxTimerListsWereSwitched = pdFALSE;
 651              		.loc 1 443 0
 652 0038 7B68     		ldr	r3, [r7, #4]
 653 003a 4FF00002 		mov	r2, #0
 654 003e 1A60     		str	r2, [r3, #0]
 655              	.L29:
 444:../FreeRTOS_Source/timers.c **** 	}
 445:../FreeRTOS_Source/timers.c **** 	
 446:../FreeRTOS_Source/timers.c **** 	xLastTime = xTimeNow;
 656              		.loc 1 446 0
 657 0040 40F20003 		movw	r3, #:lower16:xLastTime.4289
 658 0044 C0F20003 		movt	r3, #:upper16:xLastTime.4289
 659 0048 FA68     		ldr	r2, [r7, #12]
 660 004a 1A60     		str	r2, [r3, #0]
 447:../FreeRTOS_Source/timers.c **** 	
 448:../FreeRTOS_Source/timers.c **** 	return xTimeNow;
 661              		.loc 1 448 0
 662 004c FB68     		ldr	r3, [r7, #12]
 449:../FreeRTOS_Source/timers.c **** }
 663              		.loc 1 449 0
 664 004e 1846     		mov	r0, r3
 665 0050 07F11007 		add	r7, r7, #16
 666 0054 BD46     		mov	sp, r7
 667 0056 80BD     		pop	{r7, pc}
 668              		.cfi_endproc
 669              	.LFE7:
 671              		.section	.text.prvInsertTimerInActiveList,"ax",%progbits
 672              		.align	2
 673              		.thumb
 674              		.thumb_func
 676              	prvInsertTimerInActiveList:
 677              	.LFB8:
 450:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 451:../FreeRTOS_Source/timers.c **** 
 452:../FreeRTOS_Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 453:../FreeRTOS_Source/timers.c **** {
 678              		.loc 1 453 0
 679              		.cfi_startproc
 680              		@ args = 0, pretend = 0, frame = 24
 681              		@ frame_needed = 1, uses_anonymous_args = 0
 682 0000 80B5     		push	{r7, lr}
 683              	.LCFI24:
 684              		.cfi_def_cfa_offset 8
 685              		.cfi_offset 14, -4
 686              		.cfi_offset 7, -8
 687 0002 86B0     		sub	sp, sp, #24
 688              	.LCFI25:
 689              		.cfi_def_cfa_offset 32
 690 0004 00AF     		add	r7, sp, #0
 691              	.LCFI26:
 692              		.cfi_def_cfa_register 7
 693 0006 F860     		str	r0, [r7, #12]
 694 0008 B960     		str	r1, [r7, #8]
 695 000a 7A60     		str	r2, [r7, #4]
 696 000c 3B60     		str	r3, [r7, #0]
 454:../FreeRTOS_Source/timers.c **** portBASE_TYPE xProcessTimerNow = pdFALSE;
 697              		.loc 1 454 0
 698 000e 4FF00003 		mov	r3, #0
 699 0012 7B61     		str	r3, [r7, #20]
 455:../FreeRTOS_Source/timers.c **** 
 456:../FreeRTOS_Source/timers.c **** 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 700              		.loc 1 456 0
 701 0014 FB68     		ldr	r3, [r7, #12]
 702 0016 BA68     		ldr	r2, [r7, #8]
 703 0018 5A60     		str	r2, [r3, #4]
 457:../FreeRTOS_Source/timers.c **** 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 704              		.loc 1 457 0
 705 001a FB68     		ldr	r3, [r7, #12]
 706 001c FA68     		ldr	r2, [r7, #12]
 707 001e 1A61     		str	r2, [r3, #16]
 458:../FreeRTOS_Source/timers.c **** 	
 459:../FreeRTOS_Source/timers.c **** 	if( xNextExpiryTime <= xTimeNow )
 708              		.loc 1 459 0
 709 0020 BA68     		ldr	r2, [r7, #8]
 710 0022 7B68     		ldr	r3, [r7, #4]
 711 0024 9A42     		cmp	r2, r3
 712 0026 17D8     		bhi	.L31
 460:../FreeRTOS_Source/timers.c **** 	{
 461:../FreeRTOS_Source/timers.c **** 		/* Has the expiry time elapsed between the command to start/reset a
 462:../FreeRTOS_Source/timers.c **** 		timer was issued, and the time the command was processed? */
 463:../FreeRTOS_Source/timers.c **** 		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 713              		.loc 1 463 0
 714 0028 7A68     		ldr	r2, [r7, #4]
 715 002a 3B68     		ldr	r3, [r7, #0]
 716 002c D21A     		subs	r2, r2, r3
 717 002e FB68     		ldr	r3, [r7, #12]
 718 0030 9B69     		ldr	r3, [r3, #24]
 719 0032 9A42     		cmp	r2, r3
 720 0034 03D3     		bcc	.L32
 464:../FreeRTOS_Source/timers.c **** 		{
 465:../FreeRTOS_Source/timers.c **** 			/* The time between a command being issued and the command being
 466:../FreeRTOS_Source/timers.c **** 			processed actually exceeds the timers period.  */
 467:../FreeRTOS_Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 721              		.loc 1 467 0
 722 0036 4FF00103 		mov	r3, #1
 723 003a 7B61     		str	r3, [r7, #20]
 724 003c 24E0     		b	.L33
 725              	.L32:
 468:../FreeRTOS_Source/timers.c **** 		}
 469:../FreeRTOS_Source/timers.c **** 		else
 470:../FreeRTOS_Source/timers.c **** 		{
 471:../FreeRTOS_Source/timers.c **** 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 726              		.loc 1 471 0
 727 003e 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 728 0042 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 729 0046 1A68     		ldr	r2, [r3, #0]
 730 0048 FB68     		ldr	r3, [r7, #12]
 731 004a 03F10403 		add	r3, r3, #4
 732 004e 1046     		mov	r0, r2
 733 0050 1946     		mov	r1, r3
 734 0052 FFF7FEFF 		bl	vListInsert
 735 0056 17E0     		b	.L33
 736              	.L31:
 472:../FreeRTOS_Source/timers.c **** 		}
 473:../FreeRTOS_Source/timers.c **** 	}
 474:../FreeRTOS_Source/timers.c **** 	else
 475:../FreeRTOS_Source/timers.c **** 	{
 476:../FreeRTOS_Source/timers.c **** 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 737              		.loc 1 476 0
 738 0058 7A68     		ldr	r2, [r7, #4]
 739 005a 3B68     		ldr	r3, [r7, #0]
 740 005c 9A42     		cmp	r2, r3
 741 005e 07D2     		bcs	.L34
 742              		.loc 1 476 0 is_stmt 0 discriminator 1
 743 0060 BA68     		ldr	r2, [r7, #8]
 744 0062 3B68     		ldr	r3, [r7, #0]
 745 0064 9A42     		cmp	r2, r3
 746 0066 03D3     		bcc	.L34
 477:../FreeRTOS_Source/timers.c **** 		{
 478:../FreeRTOS_Source/timers.c **** 			/* If, since the command was issued, the tick count has overflowed
 479:../FreeRTOS_Source/timers.c **** 			but the expiry time has not, then the timer must have already passed
 480:../FreeRTOS_Source/timers.c **** 			its expiry time and should be processed immediately. */
 481:../FreeRTOS_Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 747              		.loc 1 481 0 is_stmt 1
 748 0068 4FF00103 		mov	r3, #1
 749 006c 7B61     		str	r3, [r7, #20]
 750 006e 0BE0     		b	.L33
 751              	.L34:
 482:../FreeRTOS_Source/timers.c **** 		}
 483:../FreeRTOS_Source/timers.c **** 		else
 484:../FreeRTOS_Source/timers.c **** 		{
 485:../FreeRTOS_Source/timers.c **** 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 752              		.loc 1 485 0
 753 0070 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 754 0074 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 755 0078 1A68     		ldr	r2, [r3, #0]
 756 007a FB68     		ldr	r3, [r7, #12]
 757 007c 03F10403 		add	r3, r3, #4
 758 0080 1046     		mov	r0, r2
 759 0082 1946     		mov	r1, r3
 760 0084 FFF7FEFF 		bl	vListInsert
 761              	.L33:
 486:../FreeRTOS_Source/timers.c **** 		}
 487:../FreeRTOS_Source/timers.c **** 	}
 488:../FreeRTOS_Source/timers.c **** 
 489:../FreeRTOS_Source/timers.c **** 	return xProcessTimerNow;
 762              		.loc 1 489 0
 763 0088 7B69     		ldr	r3, [r7, #20]
 490:../FreeRTOS_Source/timers.c **** }
 764              		.loc 1 490 0
 765 008a 1846     		mov	r0, r3
 766 008c 07F11807 		add	r7, r7, #24
 767 0090 BD46     		mov	sp, r7
 768 0092 80BD     		pop	{r7, pc}
 769              		.cfi_endproc
 770              	.LFE8:
 772              		.section	.text.prvProcessReceivedCommands,"ax",%progbits
 773              		.align	2
 774              		.thumb
 775              		.thumb_func
 777              	prvProcessReceivedCommands:
 778              	.LFB9:
 491:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 492:../FreeRTOS_Source/timers.c **** 
 493:../FreeRTOS_Source/timers.c **** static void	prvProcessReceivedCommands( void )
 494:../FreeRTOS_Source/timers.c **** {
 779              		.loc 1 494 0
 780              		.cfi_startproc
 781              		@ args = 0, pretend = 0, frame = 32
 782              		@ frame_needed = 1, uses_anonymous_args = 0
 783 0000 80B5     		push	{r7, lr}
 784              	.LCFI27:
 785              		.cfi_def_cfa_offset 8
 786              		.cfi_offset 14, -4
 787              		.cfi_offset 7, -8
 788 0002 8AB0     		sub	sp, sp, #40
 789              	.LCFI28:
 790              		.cfi_def_cfa_offset 48
 791 0004 02AF     		add	r7, sp, #8
 792              	.LCFI29:
 793              		.cfi_def_cfa 7, 40
 495:../FreeRTOS_Source/timers.c **** xTIMER_MESSAGE xMessage;
 496:../FreeRTOS_Source/timers.c **** xTIMER *pxTimer;
 497:../FreeRTOS_Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched, xResult;
 498:../FreeRTOS_Source/timers.c **** portTickType xTimeNow;
 499:../FreeRTOS_Source/timers.c **** 
 500:../FreeRTOS_Source/timers.c **** 	/* In this case the xTimerListsWereSwitched parameter is not used, but it
 501:../FreeRTOS_Source/timers.c **** 	must be present in the function call. */
 502:../FreeRTOS_Source/timers.c **** 	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 794              		.loc 1 502 0
 795 0006 07F10403 		add	r3, r7, #4
 796 000a 1846     		mov	r0, r3
 797 000c FFF7FEFF 		bl	prvSampleTimeNow
 798 0010 F861     		str	r0, [r7, #28]
 503:../FreeRTOS_Source/timers.c **** 
 504:../FreeRTOS_Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 799              		.loc 1 504 0
 800 0012 68E0     		b	.L36
 801              	.L48:
 505:../FreeRTOS_Source/timers.c **** 	{
 506:../FreeRTOS_Source/timers.c **** 		pxTimer = xMessage.pxTimer;
 802              		.loc 1 506 0
 803 0014 3B69     		ldr	r3, [r7, #16]
 804 0016 BB61     		str	r3, [r7, #24]
 507:../FreeRTOS_Source/timers.c **** 
 508:../FreeRTOS_Source/timers.c **** 		/* Is the timer already in a list of active timers?  When the command
 509:../FreeRTOS_Source/timers.c **** 		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
 510:../FreeRTOS_Source/timers.c **** 		command is to the task rather than to an individual timer. */
 511:../FreeRTOS_Source/timers.c **** 		if( pxTimer != NULL )
 805              		.loc 1 511 0
 806 0018 BB69     		ldr	r3, [r7, #24]
 807 001a 002B     		cmp	r3, #0
 808 001c 09D0     		beq	.L37
 512:../FreeRTOS_Source/timers.c **** 		{
 513:../FreeRTOS_Source/timers.c **** 			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 809              		.loc 1 513 0
 810 001e BB69     		ldr	r3, [r7, #24]
 811 0020 5B69     		ldr	r3, [r3, #20]
 812 0022 002B     		cmp	r3, #0
 813 0024 05D0     		beq	.L37
 514:../FreeRTOS_Source/timers.c **** 			{
 515:../FreeRTOS_Source/timers.c **** 				/* The timer is in a list, remove it. */
 516:../FreeRTOS_Source/timers.c **** 				vListRemove( &( pxTimer->xTimerListItem ) );
 814              		.loc 1 516 0
 815 0026 BB69     		ldr	r3, [r7, #24]
 816 0028 03F10403 		add	r3, r3, #4
 817 002c 1846     		mov	r0, r3
 818 002e FFF7FEFF 		bl	vListRemove
 819              	.L37:
 517:../FreeRTOS_Source/timers.c **** 			}
 518:../FreeRTOS_Source/timers.c **** 		}
 519:../FreeRTOS_Source/timers.c **** 
 520:../FreeRTOS_Source/timers.c **** 		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
 521:../FreeRTOS_Source/timers.c **** 		
 522:../FreeRTOS_Source/timers.c **** 		switch( xMessage.xMessageID )
 820              		.loc 1 522 0
 821 0032 BB68     		ldr	r3, [r7, #8]
 822 0034 032B     		cmp	r3, #3
 823 0036 53D8     		bhi	.L49
 824 0038 01A2     		adr	r2, .L43
 825 003a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 826 003e 00BF     		.align	2
 827              	.L43:
 828 0040 51000000 		.word	.L39+1
 829 0044 E1000000 		.word	.L49+1
 830 0048 AB000000 		.word	.L41+1
 831 004c D9000000 		.word	.L42+1
 832              	.L39:
 523:../FreeRTOS_Source/timers.c **** 		{
 524:../FreeRTOS_Source/timers.c **** 			case tmrCOMMAND_START :	
 525:../FreeRTOS_Source/timers.c **** 				/* Start or restart a timer. */
 526:../FreeRTOS_Source/timers.c **** 				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks
 833              		.loc 1 526 0
 834 0050 FA68     		ldr	r2, [r7, #12]
 835 0052 BB69     		ldr	r3, [r7, #24]
 836 0054 9B69     		ldr	r3, [r3, #24]
 837 0056 D218     		adds	r2, r2, r3
 838 0058 FB68     		ldr	r3, [r7, #12]
 839 005a B869     		ldr	r0, [r7, #24]
 840 005c 1146     		mov	r1, r2
 841 005e FA69     		ldr	r2, [r7, #28]
 842 0060 FFF7FEFF 		bl	prvInsertTimerInActiveList
 843 0064 0346     		mov	r3, r0
 844 0066 012B     		cmp	r3, #1
 845 0068 3CD1     		bne	.L50
 527:../FreeRTOS_Source/timers.c **** 				{
 528:../FreeRTOS_Source/timers.c **** 					/* The timer expired before it was added to the active timer
 529:../FreeRTOS_Source/timers.c **** 					list.  Process it now. */
 530:../FreeRTOS_Source/timers.c **** 					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 846              		.loc 1 530 0
 847 006a BB69     		ldr	r3, [r7, #24]
 848 006c 5B6A     		ldr	r3, [r3, #36]
 849 006e B869     		ldr	r0, [r7, #24]
 850 0070 9847     		blx	r3
 531:../FreeRTOS_Source/timers.c **** 
 532:../FreeRTOS_Source/timers.c **** 					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 851              		.loc 1 532 0
 852 0072 BB69     		ldr	r3, [r7, #24]
 853 0074 DB69     		ldr	r3, [r3, #28]
 854 0076 012B     		cmp	r3, #1
 855 0078 34D1     		bne	.L50
 533:../FreeRTOS_Source/timers.c **** 					{
 534:../FreeRTOS_Source/timers.c **** 						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->
 856              		.loc 1 534 0
 857 007a FA68     		ldr	r2, [r7, #12]
 858 007c BB69     		ldr	r3, [r7, #24]
 859 007e 9B69     		ldr	r3, [r3, #24]
 860 0080 D318     		adds	r3, r2, r3
 861 0082 4FF00002 		mov	r2, #0
 862 0086 0092     		str	r2, [sp, #0]
 863 0088 B869     		ldr	r0, [r7, #24]
 864 008a 4FF00001 		mov	r1, #0
 865 008e 1A46     		mov	r2, r3
 866 0090 4FF00003 		mov	r3, #0
 867 0094 FFF7FEFF 		bl	xTimerGenericCommand
 868 0098 7861     		str	r0, [r7, #20]
 535:../FreeRTOS_Source/timers.c **** 						configASSERT( xResult );
 869              		.loc 1 535 0
 870 009a 7B69     		ldr	r3, [r7, #20]
 871 009c 002B     		cmp	r3, #0
 872 009e 21D1     		bne	.L50
 873              		.loc 1 535 0 is_stmt 0 discriminator 1
 874              	@ 535 "../FreeRTOS_Source/timers.c" 1
 875 00a0 4FF05000 			mov r0, #80								
 876 00a4 80F31188 		msr basepri, r0							
 877              	
 878              	@ 0 "" 2
 879              		.thumb
 880              	.L45:
 881              		.loc 1 535 0 discriminator 2
 882 00a8 FEE7     		b	.L45
 883              	.L41:
 536:../FreeRTOS_Source/timers.c **** 						( void ) xResult;
 537:../FreeRTOS_Source/timers.c **** 					}
 538:../FreeRTOS_Source/timers.c **** 				}
 539:../FreeRTOS_Source/timers.c **** 				break;
 540:../FreeRTOS_Source/timers.c **** 
 541:../FreeRTOS_Source/timers.c **** 			case tmrCOMMAND_STOP :	
 542:../FreeRTOS_Source/timers.c **** 				/* The timer has already been removed from the active list.
 543:../FreeRTOS_Source/timers.c **** 				There is nothing to do here. */
 544:../FreeRTOS_Source/timers.c **** 				break;
 545:../FreeRTOS_Source/timers.c **** 
 546:../FreeRTOS_Source/timers.c **** 			case tmrCOMMAND_CHANGE_PERIOD :
 547:../FreeRTOS_Source/timers.c **** 				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 884              		.loc 1 547 0 is_stmt 1
 885 00aa FA68     		ldr	r2, [r7, #12]
 886 00ac BB69     		ldr	r3, [r7, #24]
 887 00ae 9A61     		str	r2, [r3, #24]
 548:../FreeRTOS_Source/timers.c **** 				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 888              		.loc 1 548 0
 889 00b0 BB69     		ldr	r3, [r7, #24]
 890 00b2 9B69     		ldr	r3, [r3, #24]
 891 00b4 002B     		cmp	r3, #0
 892 00b6 04D1     		bne	.L46
 893              		.loc 1 548 0 is_stmt 0 discriminator 1
 894              	@ 548 "../FreeRTOS_Source/timers.c" 1
 895 00b8 4FF05000 			mov r0, #80								
 896 00bc 80F31188 		msr basepri, r0							
 897              	
 898              	@ 0 "" 2
 899              		.thumb
 900              	.L47:
 901              		.loc 1 548 0 discriminator 2
 902 00c0 FEE7     		b	.L47
 903              	.L46:
 549:../FreeRTOS_Source/timers.c **** 				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTi
 904              		.loc 1 549 0 is_stmt 1
 905 00c2 BB69     		ldr	r3, [r7, #24]
 906 00c4 9A69     		ldr	r2, [r3, #24]
 907 00c6 FB69     		ldr	r3, [r7, #28]
 908 00c8 D318     		adds	r3, r2, r3
 909 00ca B869     		ldr	r0, [r7, #24]
 910 00cc 1946     		mov	r1, r3
 911 00ce FA69     		ldr	r2, [r7, #28]
 912 00d0 FB69     		ldr	r3, [r7, #28]
 913 00d2 FFF7FEFF 		bl	prvInsertTimerInActiveList
 550:../FreeRTOS_Source/timers.c **** 				break;
 914              		.loc 1 550 0
 915 00d6 06E0     		b	.L36
 916              	.L42:
 551:../FreeRTOS_Source/timers.c **** 
 552:../FreeRTOS_Source/timers.c **** 			case tmrCOMMAND_DELETE :
 553:../FreeRTOS_Source/timers.c **** 				/* The timer has already been removed from the active list,
 554:../FreeRTOS_Source/timers.c **** 				just free up the memory. */
 555:../FreeRTOS_Source/timers.c **** 				vPortFree( pxTimer );
 917              		.loc 1 555 0
 918 00d8 B869     		ldr	r0, [r7, #24]
 919 00da FFF7FEFF 		bl	vPortFree
 556:../FreeRTOS_Source/timers.c **** 				break;
 920              		.loc 1 556 0
 921 00de 02E0     		b	.L36
 922              	.L49:
 557:../FreeRTOS_Source/timers.c **** 
 558:../FreeRTOS_Source/timers.c **** 			default	:			
 559:../FreeRTOS_Source/timers.c **** 				/* Don't expect to get here. */
 560:../FreeRTOS_Source/timers.c **** 				break;
 923              		.loc 1 560 0
 924 00e0 00BF     		nop
 925 00e2 00E0     		b	.L36
 926              	.L50:
 539:../FreeRTOS_Source/timers.c **** 				break;
 927              		.loc 1 539 0
 928 00e4 00BF     		nop
 929              	.L36:
 504:../FreeRTOS_Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 930              		.loc 1 504 0 discriminator 1
 931 00e6 40F20003 		movw	r3, #:lower16:xTimerQueue
 932 00ea C0F20003 		movt	r3, #:upper16:xTimerQueue
 933 00ee 1A68     		ldr	r2, [r3, #0]
 934 00f0 07F10803 		add	r3, r7, #8
 935 00f4 1046     		mov	r0, r2
 936 00f6 1946     		mov	r1, r3
 937 00f8 4FF00002 		mov	r2, #0
 938 00fc 4FF00003 		mov	r3, #0
 939 0100 FFF7FEFF 		bl	xQueueGenericReceive
 940 0104 0346     		mov	r3, r0
 941 0106 002B     		cmp	r3, #0
 942 0108 84D1     		bne	.L48
 561:../FreeRTOS_Source/timers.c **** 		}
 562:../FreeRTOS_Source/timers.c **** 	}
 563:../FreeRTOS_Source/timers.c **** }
 943              		.loc 1 563 0
 944 010a 07F12007 		add	r7, r7, #32
 945 010e BD46     		mov	sp, r7
 946 0110 80BD     		pop	{r7, pc}
 947              		.cfi_endproc
 948              	.LFE9:
 950 0112 00BF     		.section	.text.prvSwitchTimerLists,"ax",%progbits
 951              		.align	2
 952              		.thumb
 953              		.thumb_func
 955              	prvSwitchTimerLists:
 956              	.LFB10:
 564:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 565:../FreeRTOS_Source/timers.c **** 
 566:../FreeRTOS_Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime )
 567:../FreeRTOS_Source/timers.c **** {
 957              		.loc 1 567 0
 958              		.cfi_startproc
 959              		@ args = 0, pretend = 0, frame = 32
 960              		@ frame_needed = 1, uses_anonymous_args = 0
 961 0000 80B5     		push	{r7, lr}
 962              	.LCFI30:
 963              		.cfi_def_cfa_offset 8
 964              		.cfi_offset 14, -4
 965              		.cfi_offset 7, -8
 966 0002 8AB0     		sub	sp, sp, #40
 967              	.LCFI31:
 968              		.cfi_def_cfa_offset 48
 969 0004 02AF     		add	r7, sp, #8
 970              	.LCFI32:
 971              		.cfi_def_cfa 7, 40
 972 0006 7860     		str	r0, [r7, #4]
 568:../FreeRTOS_Source/timers.c **** portTickType xNextExpireTime, xReloadTime;
 569:../FreeRTOS_Source/timers.c **** xList *pxTemp;
 570:../FreeRTOS_Source/timers.c **** xTIMER *pxTimer;
 571:../FreeRTOS_Source/timers.c **** portBASE_TYPE xResult;
 572:../FreeRTOS_Source/timers.c **** 
 573:../FreeRTOS_Source/timers.c **** 	/* Remove compiler warnings if configASSERT() is not defined. */
 574:../FreeRTOS_Source/timers.c **** 	( void ) xLastTime;
 575:../FreeRTOS_Source/timers.c **** 	
 576:../FreeRTOS_Source/timers.c **** 	/* The tick count has overflowed.  The timer lists must be switched.
 577:../FreeRTOS_Source/timers.c **** 	If there are any timers still referenced from the current timer list
 578:../FreeRTOS_Source/timers.c **** 	then they must have expired and should be processed before the lists
 579:../FreeRTOS_Source/timers.c **** 	are switched. */
 580:../FreeRTOS_Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 973              		.loc 1 580 0
 974 0008 4DE0     		b	.L52
 975              	.L55:
 581:../FreeRTOS_Source/timers.c **** 	{
 582:../FreeRTOS_Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 976              		.loc 1 582 0
 977 000a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 978 000e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 979 0012 1B68     		ldr	r3, [r3, #0]
 980 0014 DB68     		ldr	r3, [r3, #12]
 981 0016 1B68     		ldr	r3, [r3, #0]
 982 0018 FB61     		str	r3, [r7, #28]
 583:../FreeRTOS_Source/timers.c **** 
 584:../FreeRTOS_Source/timers.c **** 		/* Remove the timer from the list. */
 585:../FreeRTOS_Source/timers.c **** 		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 983              		.loc 1 585 0
 984 001a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 985 001e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 986 0022 1B68     		ldr	r3, [r3, #0]
 987 0024 DB68     		ldr	r3, [r3, #12]
 988 0026 DB68     		ldr	r3, [r3, #12]
 989 0028 BB61     		str	r3, [r7, #24]
 586:../FreeRTOS_Source/timers.c **** 		vListRemove( &( pxTimer->xTimerListItem ) );
 990              		.loc 1 586 0
 991 002a BB69     		ldr	r3, [r7, #24]
 992 002c 03F10403 		add	r3, r3, #4
 993 0030 1846     		mov	r0, r3
 994 0032 FFF7FEFF 		bl	vListRemove
 587:../FreeRTOS_Source/timers.c **** 
 588:../FreeRTOS_Source/timers.c **** 		/* Execute its callback, then send a command to restart the timer if
 589:../FreeRTOS_Source/timers.c **** 		it is an auto-reload timer.  It cannot be restarted here as the lists
 590:../FreeRTOS_Source/timers.c **** 		have not yet been switched. */
 591:../FreeRTOS_Source/timers.c **** 		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 995              		.loc 1 591 0
 996 0036 BB69     		ldr	r3, [r7, #24]
 997 0038 5B6A     		ldr	r3, [r3, #36]
 998 003a B869     		ldr	r0, [r7, #24]
 999 003c 9847     		blx	r3
 592:../FreeRTOS_Source/timers.c **** 
 593:../FreeRTOS_Source/timers.c **** 		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 1000              		.loc 1 593 0
 1001 003e BB69     		ldr	r3, [r7, #24]
 1002 0040 DB69     		ldr	r3, [r3, #28]
 1003 0042 012B     		cmp	r3, #1
 1004 0044 2FD1     		bne	.L52
 594:../FreeRTOS_Source/timers.c **** 		{
 595:../FreeRTOS_Source/timers.c **** 			/* Calculate the reload value, and if the reload value results in
 596:../FreeRTOS_Source/timers.c **** 			the timer going into the same timer list then it has already expired
 597:../FreeRTOS_Source/timers.c **** 			and the timer should be re-inserted into the current list so it is
 598:../FreeRTOS_Source/timers.c **** 			processed again within this loop.  Otherwise a command should be sent
 599:../FreeRTOS_Source/timers.c **** 			to restart the timer to ensure it is only inserted into a list after
 600:../FreeRTOS_Source/timers.c **** 			the lists have been swapped. */
 601:../FreeRTOS_Source/timers.c **** 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 1005              		.loc 1 601 0
 1006 0046 BB69     		ldr	r3, [r7, #24]
 1007 0048 9A69     		ldr	r2, [r3, #24]
 1008 004a FB69     		ldr	r3, [r7, #28]
 1009 004c D318     		adds	r3, r2, r3
 1010 004e 7B61     		str	r3, [r7, #20]
 602:../FreeRTOS_Source/timers.c **** 			if( xReloadTime > xNextExpireTime )
 1011              		.loc 1 602 0
 1012 0050 7A69     		ldr	r2, [r7, #20]
 1013 0052 FB69     		ldr	r3, [r7, #28]
 1014 0054 9A42     		cmp	r2, r3
 1015 0056 12D9     		bls	.L53
 603:../FreeRTOS_Source/timers.c **** 			{
 604:../FreeRTOS_Source/timers.c **** 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 1016              		.loc 1 604 0
 1017 0058 BB69     		ldr	r3, [r7, #24]
 1018 005a 7A69     		ldr	r2, [r7, #20]
 1019 005c 5A60     		str	r2, [r3, #4]
 605:../FreeRTOS_Source/timers.c **** 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 1020              		.loc 1 605 0
 1021 005e BB69     		ldr	r3, [r7, #24]
 1022 0060 BA69     		ldr	r2, [r7, #24]
 1023 0062 1A61     		str	r2, [r3, #16]
 606:../FreeRTOS_Source/timers.c **** 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 1024              		.loc 1 606 0
 1025 0064 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1026 0068 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1027 006c 1A68     		ldr	r2, [r3, #0]
 1028 006e BB69     		ldr	r3, [r7, #24]
 1029 0070 03F10403 		add	r3, r3, #4
 1030 0074 1046     		mov	r0, r2
 1031 0076 1946     		mov	r1, r3
 1032 0078 FFF7FEFF 		bl	vListInsert
 1033 007c 13E0     		b	.L52
 1034              	.L53:
 607:../FreeRTOS_Source/timers.c **** 			}
 608:../FreeRTOS_Source/timers.c **** 			else
 609:../FreeRTOS_Source/timers.c **** 			{
 610:../FreeRTOS_Source/timers.c **** 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY )
 1035              		.loc 1 610 0
 1036 007e 4FF00003 		mov	r3, #0
 1037 0082 0093     		str	r3, [sp, #0]
 1038 0084 B869     		ldr	r0, [r7, #24]
 1039 0086 4FF00001 		mov	r1, #0
 1040 008a FA69     		ldr	r2, [r7, #28]
 1041 008c 4FF00003 		mov	r3, #0
 1042 0090 FFF7FEFF 		bl	xTimerGenericCommand
 1043 0094 3861     		str	r0, [r7, #16]
 611:../FreeRTOS_Source/timers.c **** 				configASSERT( xResult );
 1044              		.loc 1 611 0
 1045 0096 3B69     		ldr	r3, [r7, #16]
 1046 0098 002B     		cmp	r3, #0
 1047 009a 04D1     		bne	.L52
 1048              		.loc 1 611 0 is_stmt 0 discriminator 1
 1049              	@ 611 "../FreeRTOS_Source/timers.c" 1
 1050 009c 4FF05000 			mov r0, #80								
 1051 00a0 80F31188 		msr basepri, r0							
 1052              	
 1053              	@ 0 "" 2
 1054              		.thumb
 1055              	.L54:
 1056              		.loc 1 611 0 discriminator 2
 1057 00a4 FEE7     		b	.L54
 1058              	.L52:
 580:../FreeRTOS_Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 1059              		.loc 1 580 0 is_stmt 1 discriminator 1
 1060 00a6 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1061 00aa C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1062 00ae 1B68     		ldr	r3, [r3, #0]
 1063 00b0 1B68     		ldr	r3, [r3, #0]
 1064 00b2 002B     		cmp	r3, #0
 1065 00b4 A9D1     		bne	.L55
 612:../FreeRTOS_Source/timers.c **** 				( void ) xResult;
 613:../FreeRTOS_Source/timers.c **** 			}
 614:../FreeRTOS_Source/timers.c **** 		}
 615:../FreeRTOS_Source/timers.c **** 	}
 616:../FreeRTOS_Source/timers.c **** 
 617:../FreeRTOS_Source/timers.c **** 	pxTemp = pxCurrentTimerList;
 1066              		.loc 1 617 0
 1067 00b6 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1068 00ba C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1069 00be 1B68     		ldr	r3, [r3, #0]
 1070 00c0 FB60     		str	r3, [r7, #12]
 618:../FreeRTOS_Source/timers.c **** 	pxCurrentTimerList = pxOverflowTimerList;
 1071              		.loc 1 618 0
 1072 00c2 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1073 00c6 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1074 00ca 1A68     		ldr	r2, [r3, #0]
 1075 00cc 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1076 00d0 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1077 00d4 1A60     		str	r2, [r3, #0]
 619:../FreeRTOS_Source/timers.c **** 	pxOverflowTimerList = pxTemp;
 1078              		.loc 1 619 0
 1079 00d6 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1080 00da C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1081 00de FA68     		ldr	r2, [r7, #12]
 1082 00e0 1A60     		str	r2, [r3, #0]
 620:../FreeRTOS_Source/timers.c **** }
 1083              		.loc 1 620 0
 1084 00e2 07F12007 		add	r7, r7, #32
 1085 00e6 BD46     		mov	sp, r7
 1086 00e8 80BD     		pop	{r7, pc}
 1087              		.cfi_endproc
 1088              	.LFE10:
 1090 00ea 00BF     		.section	.text.prvCheckForValidListAndQueue,"ax",%progbits
 1091              		.align	2
 1092              		.thumb
 1093              		.thumb_func
 1095              	prvCheckForValidListAndQueue:
 1096              	.LFB11:
 621:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 622:../FreeRTOS_Source/timers.c **** 
 623:../FreeRTOS_Source/timers.c **** static void prvCheckForValidListAndQueue( void )
 624:../FreeRTOS_Source/timers.c **** {
 1097              		.loc 1 624 0
 1098              		.cfi_startproc
 1099              		@ args = 0, pretend = 0, frame = 0
 1100              		@ frame_needed = 1, uses_anonymous_args = 0
 1101 0000 80B5     		push	{r7, lr}
 1102              	.LCFI33:
 1103              		.cfi_def_cfa_offset 8
 1104              		.cfi_offset 14, -4
 1105              		.cfi_offset 7, -8
 1106 0002 00AF     		add	r7, sp, #0
 1107              	.LCFI34:
 1108              		.cfi_def_cfa_register 7
 625:../FreeRTOS_Source/timers.c **** 	/* Check that the list from which active timers are referenced, and the
 626:../FreeRTOS_Source/timers.c **** 	queue used to communicate with the timer service, have been
 627:../FreeRTOS_Source/timers.c **** 	initialised. */
 628:../FreeRTOS_Source/timers.c **** 	taskENTER_CRITICAL();
 1109              		.loc 1 628 0
 1110 0004 FFF7FEFF 		bl	vPortEnterCritical
 629:../FreeRTOS_Source/timers.c **** 	{
 630:../FreeRTOS_Source/timers.c **** 		if( xTimerQueue == NULL )
 1111              		.loc 1 630 0
 1112 0008 40F20003 		movw	r3, #:lower16:xTimerQueue
 1113 000c C0F20003 		movt	r3, #:upper16:xTimerQueue
 1114 0010 1B68     		ldr	r3, [r3, #0]
 1115 0012 002B     		cmp	r3, #0
 1116 0014 2BD1     		bne	.L57
 631:../FreeRTOS_Source/timers.c **** 		{
 632:../FreeRTOS_Source/timers.c **** 			vListInitialise( &xActiveTimerList1 );
 1117              		.loc 1 632 0
 1118 0016 40F20000 		movw	r0, #:lower16:xActiveTimerList1
 1119 001a C0F20000 		movt	r0, #:upper16:xActiveTimerList1
 1120 001e FFF7FEFF 		bl	vListInitialise
 633:../FreeRTOS_Source/timers.c **** 			vListInitialise( &xActiveTimerList2 );
 1121              		.loc 1 633 0
 1122 0022 40F20000 		movw	r0, #:lower16:xActiveTimerList2
 1123 0026 C0F20000 		movt	r0, #:upper16:xActiveTimerList2
 1124 002a FFF7FEFF 		bl	vListInitialise
 634:../FreeRTOS_Source/timers.c **** 			pxCurrentTimerList = &xActiveTimerList1;
 1125              		.loc 1 634 0
 1126 002e 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1127 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1128 0036 40F20002 		movw	r2, #:lower16:xActiveTimerList1
 1129 003a C0F20002 		movt	r2, #:upper16:xActiveTimerList1
 1130 003e 1A60     		str	r2, [r3, #0]
 635:../FreeRTOS_Source/timers.c **** 			pxOverflowTimerList = &xActiveTimerList2;
 1131              		.loc 1 635 0
 1132 0040 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1133 0044 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1134 0048 40F20002 		movw	r2, #:lower16:xActiveTimerList2
 1135 004c C0F20002 		movt	r2, #:upper16:xActiveTimerList2
 1136 0050 1A60     		str	r2, [r3, #0]
 636:../FreeRTOS_Source/timers.c **** 			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_
 1137              		.loc 1 636 0
 1138 0052 4FF00500 		mov	r0, #5
 1139 0056 4FF00C01 		mov	r1, #12
 1140 005a 4FF00002 		mov	r2, #0
 1141 005e FFF7FEFF 		bl	xQueueGenericCreate
 1142 0062 0246     		mov	r2, r0
 1143 0064 40F20003 		movw	r3, #:lower16:xTimerQueue
 1144 0068 C0F20003 		movt	r3, #:upper16:xTimerQueue
 1145 006c 1A60     		str	r2, [r3, #0]
 1146              	.L57:
 637:../FreeRTOS_Source/timers.c **** 		}
 638:../FreeRTOS_Source/timers.c **** 	}
 639:../FreeRTOS_Source/timers.c **** 	taskEXIT_CRITICAL();
 1147              		.loc 1 639 0
 1148 006e FFF7FEFF 		bl	vPortExitCritical
 640:../FreeRTOS_Source/timers.c **** }
 1149              		.loc 1 640 0
 1150 0072 80BD     		pop	{r7, pc}
 1151              		.cfi_endproc
 1152              	.LFE11:
 1154              		.section	.text.xTimerIsTimerActive,"ax",%progbits
 1155              		.align	2
 1156              		.global	xTimerIsTimerActive
 1157              		.thumb
 1158              		.thumb_func
 1160              	xTimerIsTimerActive:
 1161              	.LFB12:
 641:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 642:../FreeRTOS_Source/timers.c **** 
 643:../FreeRTOS_Source/timers.c **** portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
 644:../FreeRTOS_Source/timers.c **** {
 1162              		.loc 1 644 0
 1163              		.cfi_startproc
 1164              		@ args = 0, pretend = 0, frame = 16
 1165              		@ frame_needed = 1, uses_anonymous_args = 0
 1166 0000 80B5     		push	{r7, lr}
 1167              	.LCFI35:
 1168              		.cfi_def_cfa_offset 8
 1169              		.cfi_offset 14, -4
 1170              		.cfi_offset 7, -8
 1171 0002 84B0     		sub	sp, sp, #16
 1172              	.LCFI36:
 1173              		.cfi_def_cfa_offset 24
 1174 0004 00AF     		add	r7, sp, #0
 1175              	.LCFI37:
 1176              		.cfi_def_cfa_register 7
 1177 0006 7860     		str	r0, [r7, #4]
 645:../FreeRTOS_Source/timers.c **** portBASE_TYPE xTimerIsInActiveList;
 646:../FreeRTOS_Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1178              		.loc 1 646 0
 1179 0008 7B68     		ldr	r3, [r7, #4]
 1180 000a FB60     		str	r3, [r7, #12]
 647:../FreeRTOS_Source/timers.c **** 
 648:../FreeRTOS_Source/timers.c **** 	/* Is the timer in the list of active timers? */
 649:../FreeRTOS_Source/timers.c **** 	taskENTER_CRITICAL();
 1181              		.loc 1 649 0
 1182 000c FFF7FEFF 		bl	vPortEnterCritical
 650:../FreeRTOS_Source/timers.c **** 	{
 651:../FreeRTOS_Source/timers.c **** 		/* Checking to see if it is in the NULL list in effect checks to see if
 652:../FreeRTOS_Source/timers.c **** 		it is referenced from either the current or the overflow timer lists in
 653:../FreeRTOS_Source/timers.c **** 		one go, but the logic has to be reversed, hence the '!'. */
 654:../FreeRTOS_Source/timers.c **** 		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 1183              		.loc 1 654 0
 1184 0010 FB68     		ldr	r3, [r7, #12]
 1185 0012 5B69     		ldr	r3, [r3, #20]
 1186 0014 002B     		cmp	r3, #0
 1187 0016 0CBF     		ite	eq
 1188 0018 0023     		moveq	r3, #0
 1189 001a 0123     		movne	r3, #1
 1190 001c BB60     		str	r3, [r7, #8]
 655:../FreeRTOS_Source/timers.c **** 	}
 656:../FreeRTOS_Source/timers.c **** 	taskEXIT_CRITICAL();
 1191              		.loc 1 656 0
 1192 001e FFF7FEFF 		bl	vPortExitCritical
 657:../FreeRTOS_Source/timers.c **** 
 658:../FreeRTOS_Source/timers.c **** 	return xTimerIsInActiveList;
 1193              		.loc 1 658 0
 1194 0022 BB68     		ldr	r3, [r7, #8]
 659:../FreeRTOS_Source/timers.c **** }
 1195              		.loc 1 659 0
 1196 0024 1846     		mov	r0, r3
 1197 0026 07F11007 		add	r7, r7, #16
 1198 002a BD46     		mov	sp, r7
 1199 002c 80BD     		pop	{r7, pc}
 1200              		.cfi_endproc
 1201              	.LFE12:
 1203 002e 00BF     		.section	.text.pvTimerGetTimerID,"ax",%progbits
 1204              		.align	2
 1205              		.global	pvTimerGetTimerID
 1206              		.thumb
 1207              		.thumb_func
 1209              	pvTimerGetTimerID:
 1210              	.LFB13:
 660:../FreeRTOS_Source/timers.c **** /*-----------------------------------------------------------*/
 661:../FreeRTOS_Source/timers.c **** 
 662:../FreeRTOS_Source/timers.c **** void *pvTimerGetTimerID( xTimerHandle xTimer )
 663:../FreeRTOS_Source/timers.c **** {
 1211              		.loc 1 663 0
 1212              		.cfi_startproc
 1213              		@ args = 0, pretend = 0, frame = 16
 1214              		@ frame_needed = 1, uses_anonymous_args = 0
 1215              		@ link register save eliminated.
 1216 0000 80B4     		push	{r7}
 1217              	.LCFI38:
 1218              		.cfi_def_cfa_offset 4
 1219              		.cfi_offset 7, -4
 1220 0002 85B0     		sub	sp, sp, #20
 1221              	.LCFI39:
 1222              		.cfi_def_cfa_offset 24
 1223 0004 00AF     		add	r7, sp, #0
 1224              	.LCFI40:
 1225              		.cfi_def_cfa_register 7
 1226 0006 7860     		str	r0, [r7, #4]
 664:../FreeRTOS_Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1227              		.loc 1 664 0
 1228 0008 7B68     		ldr	r3, [r7, #4]
 1229 000a FB60     		str	r3, [r7, #12]
 665:../FreeRTOS_Source/timers.c **** 
 666:../FreeRTOS_Source/timers.c **** 	return pxTimer->pvTimerID;
 1230              		.loc 1 666 0
 1231 000c FB68     		ldr	r3, [r7, #12]
 1232 000e 1B6A     		ldr	r3, [r3, #32]
 667:../FreeRTOS_Source/timers.c **** }
 1233              		.loc 1 667 0
 1234 0010 1846     		mov	r0, r3
 1235 0012 07F11407 		add	r7, r7, #20
 1236 0016 BD46     		mov	sp, r7
 1237 0018 80BC     		pop	{r7}
 1238 001a 7047     		bx	lr
 1239              		.cfi_endproc
 1240              	.LFE13:
 1242              		.section	.bss.xLastTime.4289,"aw",%nobits
 1243              		.align	2
 1246              	xLastTime.4289:
 1247 0000 00000000 		.space	4
 1248              		.text
 1249              	.Letext0:
 1250              		.file 2 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/list.h"
 1251              		.file 3 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\portable\\GCC\\ARM_CM3/portmacro.
 1252              		.file 4 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/queue.h"
 1253              		.file 5 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/timers.h"
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:19     .bss.xActiveTimerList1:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:22     .bss.xActiveTimerList1:00000000 xActiveTimerList1
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:25     .bss.xActiveTimerList2:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:28     .bss.xActiveTimerList2:00000000 xActiveTimerList2
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:31     .bss.pxCurrentTimerList:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:34     .bss.pxCurrentTimerList:00000000 pxCurrentTimerList
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:37     .bss.pxOverflowTimerList:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:40     .bss.pxOverflowTimerList:00000000 pxOverflowTimerList
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:43     .bss.xTimerQueue:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:46     .bss.xTimerQueue:00000000 xTimerQueue
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:49     .rodata:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:50     .rodata:00000000 .LC0
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:53     .text.xTimerCreateTimerTask:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:58     .text.xTimerCreateTimerTask:00000000 xTimerCreateTimerTask
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1095   .text.prvCheckForValidListAndQueue:00000000 prvCheckForValidListAndQueue
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:422    .text.prvTimerTask:00000000 prvTimerTask
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:131    .text.xTimerCreate:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:136    .text.xTimerCreate:00000000 xTimerCreate
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:226    .text.xTimerGenericCommand:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:231    .text.xTimerGenericCommand:00000000 xTimerGenericCommand
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:328    .text.prvProcessExpiredTimer:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:332    .text.prvProcessExpiredTimer:00000000 prvProcessExpiredTimer
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:676    .text.prvInsertTimerInActiveList:00000000 prvInsertTimerInActiveList
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:418    .text.prvTimerTask:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:548    .text.prvGetNextExpireTime:00000000 prvGetNextExpireTime
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:463    .text.prvProcessTimerOrBlockTask:00000000 prvProcessTimerOrBlockTask
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:777    .text.prvProcessReceivedCommands:00000000 prvProcessReceivedCommands
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:459    .text.prvProcessTimerOrBlockTask:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:611    .text.prvSampleTimeNow:00000000 prvSampleTimeNow
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:544    .text.prvGetNextExpireTime:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:607    .text.prvSampleTimeNow:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1246   .bss.xLastTime.4289:00000000 xLastTime.4289
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:955    .text.prvSwitchTimerLists:00000000 prvSwitchTimerLists
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:672    .text.prvInsertTimerInActiveList:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:773    .text.prvProcessReceivedCommands:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:828    .text.prvProcessReceivedCommands:00000040 $d
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:834    .text.prvProcessReceivedCommands:00000050 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:951    .text.prvSwitchTimerLists:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1091   .text.prvCheckForValidListAndQueue:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1155   .text.xTimerIsTimerActive:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1160   .text.xTimerIsTimerActive:00000000 xTimerIsTimerActive
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1204   .text.pvTimerGetTimerID:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1209   .text.pvTimerGetTimerID:00000000 pvTimerGetTimerID
C:\Users\Palladin\AppData\Local\Temp\ccqxmdfJ.s:1243   .bss.xLastTime.4289:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xTaskGenericCreate
pvPortMalloc
vListInitialiseItem
xTaskGetSchedulerState
xQueueGenericSend
xQueueGenericSendFromISR
vListRemove
vTaskSuspendAll
xTaskResumeAll
vQueueWaitForMessageRestricted
vPortYieldFromISR
xTaskGetTickCount
vListInsert
vPortFree
xQueueGenericReceive
vPortEnterCritical
vListInitialise
xQueueGenericCreate
vPortExitCritical
