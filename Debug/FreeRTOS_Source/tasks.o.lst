   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.section	.bss.pxCurrentTCB,"aw",%nobits
  20              		.align	2
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  26              		.align	2
  29              	pxReadyTasksLists:
  30 0000 00000000 		.space	40
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  32              		.align	2
  35              	xDelayedTaskList1:
  36 0000 00000000 		.space	20
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  38              		.align	2
  41              	xDelayedTaskList2:
  42 0000 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  44              		.align	2
  47              	pxDelayedTaskList:
  48 0000 00000000 		.space	4
  49              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  50              		.align	2
  53              	pxOverflowDelayedTaskList:
  54 0000 00000000 		.space	4
  55              		.section	.bss.xPendingReadyList,"aw",%nobits
  56              		.align	2
  59              	xPendingReadyList:
  60 0000 00000000 		.space	20
  60      00000000 
  60      00000000 
  60      00000000 
  60      00000000 
  61              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  62              		.align	2
  65              	xTasksWaitingTermination:
  66 0000 00000000 		.space	20
  66      00000000 
  66      00000000 
  66      00000000 
  66      00000000 
  67              		.section	.bss.uxTasksDeleted,"aw",%nobits
  68              		.align	2
  71              	uxTasksDeleted:
  72 0000 00000000 		.space	4
  73              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  74              		.align	2
  77              	xSuspendedTaskList:
  78 0000 00000000 		.space	20
  78      00000000 
  78      00000000 
  78      00000000 
  78      00000000 
  79              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  80              		.align	2
  83              	uxCurrentNumberOfTasks:
  84 0000 00000000 		.space	4
  85              		.section	.bss.xTickCount,"aw",%nobits
  86              		.align	2
  89              	xTickCount:
  90 0000 00000000 		.space	4
  91              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  92              		.align	2
  95              	uxTopUsedPriority:
  96 0000 00000000 		.space	4
  97              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  98              		.align	2
 101              	uxTopReadyPriority:
 102 0000 00000000 		.space	4
 103              		.section	.bss.xSchedulerRunning,"aw",%nobits
 104              		.align	2
 107              	xSchedulerRunning:
 108 0000 00000000 		.space	4
 109              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 110              		.align	2
 113              	uxSchedulerSuspended:
 114 0000 00000000 		.space	4
 115              		.section	.bss.uxMissedTicks,"aw",%nobits
 116              		.align	2
 119              	uxMissedTicks:
 120 0000 00000000 		.space	4
 121              		.section	.bss.xMissedYield,"aw",%nobits
 122              		.align	2
 125              	xMissedYield:
 126 0000 00000000 		.space	4
 127              		.section	.bss.xNumOfOverflows,"aw",%nobits
 128              		.align	2
 131              	xNumOfOverflows:
 132 0000 00000000 		.space	4
 133              		.section	.bss.uxTCBNumber,"aw",%nobits
 134              		.align	2
 137              	uxTCBNumber:
 138 0000 00000000 		.space	4
 139              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 140              		.align	2
 143              	xNextTaskUnblockTime:
 144 0000 FFFFFFFF 		.word	-1
 145              		.section	.text.xTaskGenericCreate,"ax",%progbits
 146              		.align	2
 147              		.global	xTaskGenericCreate
 148              		.thumb
 149              		.thumb_func
 151              	xTaskGenericCreate:
 152              	.LFB0:
 153              		.file 1 "../FreeRTOS_Source/tasks.c"
   1:../FreeRTOS_Source/tasks.c **** /*
   2:../FreeRTOS_Source/tasks.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS_Source/tasks.c **** 	
   4:../FreeRTOS_Source/tasks.c **** 
   5:../FreeRTOS_Source/tasks.c ****     ***************************************************************************
   6:../FreeRTOS_Source/tasks.c ****      *                                                                       *
   7:../FreeRTOS_Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS_Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS_Source/tasks.c ****      *    available.                                                         *
  10:../FreeRTOS_Source/tasks.c ****      *                                                                       *
  11:../FreeRTOS_Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS_Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS_Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS_Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS_Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS_Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS_Source/tasks.c ****      *                                                                       *
  18:../FreeRTOS_Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS_Source/tasks.c ****      *                                                                       *
  20:../FreeRTOS_Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS_Source/tasks.c ****      *                                                                       *
  22:../FreeRTOS_Source/tasks.c ****     ***************************************************************************
  23:../FreeRTOS_Source/tasks.c **** 
  24:../FreeRTOS_Source/tasks.c **** 
  25:../FreeRTOS_Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS_Source/tasks.c **** 
  27:../FreeRTOS_Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS_Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS_Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS_Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS_Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS_Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS_Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS_Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS_Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS_Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS_Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS_Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS_Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS_Source/tasks.c ****     FreeRTOS WEB site.
  41:../FreeRTOS_Source/tasks.c **** 
  42:../FreeRTOS_Source/tasks.c ****     1 tab == 4 spaces!
  43:../FreeRTOS_Source/tasks.c **** 
  44:../FreeRTOS_Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS_Source/tasks.c ****     contact details.
  46:../FreeRTOS_Source/tasks.c **** 
  47:../FreeRTOS_Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS_Source/tasks.c ****     critical systems.
  49:../FreeRTOS_Source/tasks.c **** 
  50:../FreeRTOS_Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS_Source/tasks.c ****     licensing and training services.
  52:../FreeRTOS_Source/tasks.c **** */
  53:../FreeRTOS_Source/tasks.c **** 
  54:../FreeRTOS_Source/tasks.c **** 
  55:../FreeRTOS_Source/tasks.c **** #include <stdio.h>
  56:../FreeRTOS_Source/tasks.c **** #include <stdlib.h>
  57:../FreeRTOS_Source/tasks.c **** #include <string.h>
  58:../FreeRTOS_Source/tasks.c **** 
  59:../FreeRTOS_Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../FreeRTOS_Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../FreeRTOS_Source/tasks.c **** task.h is included from an application file. */
  62:../FreeRTOS_Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../FreeRTOS_Source/tasks.c **** 
  64:../FreeRTOS_Source/tasks.c **** #include "FreeRTOS.h"
  65:../FreeRTOS_Source/tasks.c **** #include "task.h"
  66:../FreeRTOS_Source/tasks.c **** #include "timers.h"
  67:../FreeRTOS_Source/tasks.c **** #include "StackMacros.h"
  68:../FreeRTOS_Source/tasks.c **** 
  69:../FreeRTOS_Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS_Source/tasks.c **** 
  71:../FreeRTOS_Source/tasks.c **** /*
  72:../FreeRTOS_Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../FreeRTOS_Source/tasks.c ****  */
  74:../FreeRTOS_Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../FreeRTOS_Source/tasks.c **** 
  76:../FreeRTOS_Source/tasks.c **** /*
  77:../FreeRTOS_Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../FreeRTOS_Source/tasks.c ****  * and stores the context of the task.
  79:../FreeRTOS_Source/tasks.c ****  */
  80:../FreeRTOS_Source/tasks.c **** typedef struct tskTaskControlBlock
  81:../FreeRTOS_Source/tasks.c **** {
  82:../FreeRTOS_Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../FreeRTOS_Source/tasks.c **** 
  84:../FreeRTOS_Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../FreeRTOS_Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../FreeRTOS_Source/tasks.c **** 	#endif	
  87:../FreeRTOS_Source/tasks.c **** 	
  88:../FreeRTOS_Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../FreeRTOS_Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../FreeRTOS_Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../FreeRTOS_Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../FreeRTOS_Source/tasks.c **** 
  94:../FreeRTOS_Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../FreeRTOS_Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../FreeRTOS_Source/tasks.c **** 	#endif
  97:../FreeRTOS_Source/tasks.c **** 
  98:../FreeRTOS_Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../FreeRTOS_Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../FreeRTOS_Source/tasks.c **** 	#endif
 101:../FreeRTOS_Source/tasks.c **** 
 102:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../FreeRTOS_Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 104:../FreeRTOS_Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 105:../FreeRTOS_Source/tasks.c **** 	#endif
 106:../FreeRTOS_Source/tasks.c **** 
 107:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:../FreeRTOS_Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:../FreeRTOS_Source/tasks.c **** 	#endif
 110:../FreeRTOS_Source/tasks.c **** 
 111:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:../FreeRTOS_Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:../FreeRTOS_Source/tasks.c **** 	#endif
 114:../FreeRTOS_Source/tasks.c **** 
 115:../FreeRTOS_Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:../FreeRTOS_Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:../FreeRTOS_Source/tasks.c **** 	#endif
 118:../FreeRTOS_Source/tasks.c **** 
 119:../FreeRTOS_Source/tasks.c **** } tskTCB;
 120:../FreeRTOS_Source/tasks.c **** 
 121:../FreeRTOS_Source/tasks.c **** 
 122:../FreeRTOS_Source/tasks.c **** /*
 123:../FreeRTOS_Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:../FreeRTOS_Source/tasks.c ****  * than file scope.
 125:../FreeRTOS_Source/tasks.c ****  */
 126:../FreeRTOS_Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:../FreeRTOS_Source/tasks.c **** 	#define static
 128:../FreeRTOS_Source/tasks.c **** #endif
 129:../FreeRTOS_Source/tasks.c **** 
 130:../FreeRTOS_Source/tasks.c **** /*lint -e956 */
 131:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:../FreeRTOS_Source/tasks.c **** 
 133:../FreeRTOS_Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:../FreeRTOS_Source/tasks.c **** 
 135:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:../FreeRTOS_Source/tasks.c **** 
 142:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:../FreeRTOS_Source/tasks.c **** 
 144:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 145:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:../FreeRTOS_Source/tasks.c **** 
 147:../FreeRTOS_Source/tasks.c **** #endif
 148:../FreeRTOS_Source/tasks.c **** 
 149:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:../FreeRTOS_Source/tasks.c **** 
 151:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:../FreeRTOS_Source/tasks.c **** 
 153:../FreeRTOS_Source/tasks.c **** #endif
 154:../FreeRTOS_Source/tasks.c **** 
 155:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 156:../FreeRTOS_Source/tasks.c **** 	
 157:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 158:../FreeRTOS_Source/tasks.c **** 	
 159:../FreeRTOS_Source/tasks.c **** #endif
 160:../FreeRTOS_Source/tasks.c **** 
 161:../FreeRTOS_Source/tasks.c **** /* File private variables. --------------------------------*/
 162:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 163:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 164:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 165:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 166:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 167:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 168:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 169:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 170:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 171:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
 172:../FreeRTOS_Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 173:../FreeRTOS_Source/tasks.c **** 
 174:../FreeRTOS_Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 175:../FreeRTOS_Source/tasks.c **** 
 176:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 177:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 178:../FreeRTOS_Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 179:../FreeRTOS_Source/tasks.c **** 
 180:../FreeRTOS_Source/tasks.c **** #endif
 181:../FreeRTOS_Source/tasks.c **** 
 182:../FreeRTOS_Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 183:../FreeRTOS_Source/tasks.c **** 
 184:../FreeRTOS_Source/tasks.c **** /*
 185:../FreeRTOS_Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 186:../FreeRTOS_Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 187:../FreeRTOS_Source/tasks.c ****  */
 188:../FreeRTOS_Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 189:../FreeRTOS_Source/tasks.c **** 
 190:../FreeRTOS_Source/tasks.c **** /*
 191:../FreeRTOS_Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 192:../FreeRTOS_Source/tasks.c ****  */
 193:../FreeRTOS_Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 194:../FreeRTOS_Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 195:../FreeRTOS_Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 196:../FreeRTOS_Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 197:../FreeRTOS_Source/tasks.c **** 
 198:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 199:../FreeRTOS_Source/tasks.c **** 
 200:../FreeRTOS_Source/tasks.c **** /*
 201:../FreeRTOS_Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 202:../FreeRTOS_Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 203:../FreeRTOS_Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 204:../FreeRTOS_Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 205:../FreeRTOS_Source/tasks.c ****  * executing task has been rescheduled.
 206:../FreeRTOS_Source/tasks.c ****  */
 207:../FreeRTOS_Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 208:../FreeRTOS_Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 209:../FreeRTOS_Source/tasks.c **** 	{																													\
 210:../FreeRTOS_Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 211:../FreeRTOS_Source/tasks.c **** 	}																													\
 212:../FreeRTOS_Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 213:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 214:../FreeRTOS_Source/tasks.c **** 
 215:../FreeRTOS_Source/tasks.c **** /*
 216:../FreeRTOS_Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 217:../FreeRTOS_Source/tasks.c ****  * any require waking.
 218:../FreeRTOS_Source/tasks.c ****  *
 219:../FreeRTOS_Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 220:../FreeRTOS_Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 221:../FreeRTOS_Source/tasks.c ****  * any further down the list.
 222:../FreeRTOS_Source/tasks.c ****  */
 223:../FreeRTOS_Source/tasks.c **** #define prvCheckDelayedTasks()															\
 224:../FreeRTOS_Source/tasks.c **** {																						\
 225:../FreeRTOS_Source/tasks.c **** portTickType xItemValue;																\
 226:../FreeRTOS_Source/tasks.c **** 																						\
 227:../FreeRTOS_Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 228:../FreeRTOS_Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 229:../FreeRTOS_Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 230:../FreeRTOS_Source/tasks.c **** 	{																					\
 231:../FreeRTOS_Source/tasks.c **** 		for( ;; )																		\
 232:../FreeRTOS_Source/tasks.c **** 		{																				\
 233:../FreeRTOS_Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 234:../FreeRTOS_Source/tasks.c **** 			{																			\
 235:../FreeRTOS_Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 236:../FreeRTOS_Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 237:../FreeRTOS_Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 238:../FreeRTOS_Source/tasks.c **** 				time through. */														\
 239:../FreeRTOS_Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 240:../FreeRTOS_Source/tasks.c **** 				break;																	\
 241:../FreeRTOS_Source/tasks.c **** 			}																			\
 242:../FreeRTOS_Source/tasks.c **** 			else																		\
 243:../FreeRTOS_Source/tasks.c **** 			{																			\
 244:../FreeRTOS_Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 245:../FreeRTOS_Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 246:../FreeRTOS_Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 247:../FreeRTOS_Source/tasks.c **** 				the Blocked state. */													\
 248:../FreeRTOS_Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 249:../FreeRTOS_Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 250:../FreeRTOS_Source/tasks.c **** 																						\
 251:../FreeRTOS_Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 252:../FreeRTOS_Source/tasks.c **** 				{																		\
 253:../FreeRTOS_Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 254:../FreeRTOS_Source/tasks.c **** 					value is the time at which the task at the head of the				\
 255:../FreeRTOS_Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 256:../FreeRTOS_Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 257:../FreeRTOS_Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 258:../FreeRTOS_Source/tasks.c **** 					break;																\
 259:../FreeRTOS_Source/tasks.c **** 				}																		\
 260:../FreeRTOS_Source/tasks.c **** 																						\
 261:../FreeRTOS_Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 262:../FreeRTOS_Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 263:../FreeRTOS_Source/tasks.c **** 																						\
 264:../FreeRTOS_Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 265:../FreeRTOS_Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 266:../FreeRTOS_Source/tasks.c **** 				{																		\
 267:../FreeRTOS_Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 268:../FreeRTOS_Source/tasks.c **** 				}																		\
 269:../FreeRTOS_Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 270:../FreeRTOS_Source/tasks.c **** 			}																			\
 271:../FreeRTOS_Source/tasks.c **** 		}																				\
 272:../FreeRTOS_Source/tasks.c **** 	}																					\
 273:../FreeRTOS_Source/tasks.c **** }
 274:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 275:../FreeRTOS_Source/tasks.c **** 
 276:../FreeRTOS_Source/tasks.c **** /*
 277:../FreeRTOS_Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 278:../FreeRTOS_Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 279:../FreeRTOS_Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 280:../FreeRTOS_Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 281:../FreeRTOS_Source/tasks.c ****  */
 282:../FreeRTOS_Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 283:../FreeRTOS_Source/tasks.c **** 
 284:../FreeRTOS_Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 285:../FreeRTOS_Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 286:../FreeRTOS_Source/tasks.c **** extern void vApplicationTickHook( void );
 287:../FreeRTOS_Source/tasks.c **** 		
 288:../FreeRTOS_Source/tasks.c **** /* File private functions. --------------------------------*/
 289:../FreeRTOS_Source/tasks.c **** 
 290:../FreeRTOS_Source/tasks.c **** /*
 291:../FreeRTOS_Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 292:../FreeRTOS_Source/tasks.c ****  * into the TCB structure.
 293:../FreeRTOS_Source/tasks.c ****  */
 294:../FreeRTOS_Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 295:../FreeRTOS_Source/tasks.c **** 
 296:../FreeRTOS_Source/tasks.c **** /*
 297:../FreeRTOS_Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 298:../FreeRTOS_Source/tasks.c ****  * automatically upon the creation of the first task.
 299:../FreeRTOS_Source/tasks.c ****  */
 300:../FreeRTOS_Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 301:../FreeRTOS_Source/tasks.c **** 
 302:../FreeRTOS_Source/tasks.c **** /*
 303:../FreeRTOS_Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 304:../FreeRTOS_Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 305:../FreeRTOS_Source/tasks.c ****  * creation of the first user task.
 306:../FreeRTOS_Source/tasks.c ****  *
 307:../FreeRTOS_Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 308:../FreeRTOS_Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 309:../FreeRTOS_Source/tasks.c ****  *
 310:../FreeRTOS_Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 311:../FreeRTOS_Source/tasks.c ****  *
 312:../FreeRTOS_Source/tasks.c ****  */
 313:../FreeRTOS_Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 314:../FreeRTOS_Source/tasks.c **** 
 315:../FreeRTOS_Source/tasks.c **** /*
 316:../FreeRTOS_Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 317:../FreeRTOS_Source/tasks.c ****  * including the stack pointed to by the TCB.
 318:../FreeRTOS_Source/tasks.c ****  *
 319:../FreeRTOS_Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 320:../FreeRTOS_Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 321:../FreeRTOS_Source/tasks.c ****  */
 322:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 323:../FreeRTOS_Source/tasks.c **** 
 324:../FreeRTOS_Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 325:../FreeRTOS_Source/tasks.c **** 
 326:../FreeRTOS_Source/tasks.c **** #endif
 327:../FreeRTOS_Source/tasks.c **** 
 328:../FreeRTOS_Source/tasks.c **** /*
 329:../FreeRTOS_Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 330:../FreeRTOS_Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 331:../FreeRTOS_Source/tasks.c ****  * and its TCB deleted.
 332:../FreeRTOS_Source/tasks.c ****  */
 333:../FreeRTOS_Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 334:../FreeRTOS_Source/tasks.c **** 
 335:../FreeRTOS_Source/tasks.c **** /*
 336:../FreeRTOS_Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 337:../FreeRTOS_Source/tasks.c ****  * either the current or the overflow delayed task list.
 338:../FreeRTOS_Source/tasks.c ****  */
 339:../FreeRTOS_Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 340:../FreeRTOS_Source/tasks.c **** 
 341:../FreeRTOS_Source/tasks.c **** /*
 342:../FreeRTOS_Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 343:../FreeRTOS_Source/tasks.c ****  * allocation was successful.
 344:../FreeRTOS_Source/tasks.c ****  */
 345:../FreeRTOS_Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 346:../FreeRTOS_Source/tasks.c **** 
 347:../FreeRTOS_Source/tasks.c **** /*
 348:../FreeRTOS_Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 349:../FreeRTOS_Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 350:../FreeRTOS_Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 351:../FreeRTOS_Source/tasks.c ****  * within just that list.
 352:../FreeRTOS_Source/tasks.c ****  *
 353:../FreeRTOS_Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 354:../FreeRTOS_Source/tasks.c ****  * NORMAL APPLICATION CODE.
 355:../FreeRTOS_Source/tasks.c ****  */
 356:../FreeRTOS_Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 357:../FreeRTOS_Source/tasks.c **** 
 358:../FreeRTOS_Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 359:../FreeRTOS_Source/tasks.c **** 
 360:../FreeRTOS_Source/tasks.c **** #endif
 361:../FreeRTOS_Source/tasks.c **** 
 362:../FreeRTOS_Source/tasks.c **** /*
 363:../FreeRTOS_Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 364:../FreeRTOS_Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 365:../FreeRTOS_Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 366:../FreeRTOS_Source/tasks.c ****  */
 367:../FreeRTOS_Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 368:../FreeRTOS_Source/tasks.c **** 
 369:../FreeRTOS_Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 370:../FreeRTOS_Source/tasks.c **** 
 371:../FreeRTOS_Source/tasks.c **** #endif
 372:../FreeRTOS_Source/tasks.c **** 
 373:../FreeRTOS_Source/tasks.c **** 
 374:../FreeRTOS_Source/tasks.c **** /*lint +e956 */
 375:../FreeRTOS_Source/tasks.c **** 
 376:../FreeRTOS_Source/tasks.c **** 
 377:../FreeRTOS_Source/tasks.c **** 
 378:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------
 379:../FreeRTOS_Source/tasks.c ****  * TASK CREATION API documented in task.h
 380:../FreeRTOS_Source/tasks.c ****  *----------------------------------------------------------*/
 381:../FreeRTOS_Source/tasks.c **** 
 382:../FreeRTOS_Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 383:../FreeRTOS_Source/tasks.c **** {
 154              		.loc 1 383 0
 155              		.cfi_startproc
 156              		@ args = 16, pretend = 0, frame = 32
 157              		@ frame_needed = 1, uses_anonymous_args = 0
 158 0000 80B5     		push	{r7, lr}
 159              	.LCFI0:
 160              		.cfi_def_cfa_offset 8
 161              		.cfi_offset 14, -4
 162              		.cfi_offset 7, -8
 163 0002 8AB0     		sub	sp, sp, #40
 164              	.LCFI1:
 165              		.cfi_def_cfa_offset 48
 166 0004 02AF     		add	r7, sp, #8
 167              	.LCFI2:
 168              		.cfi_def_cfa 7, 40
 169 0006 F860     		str	r0, [r7, #12]
 170 0008 B960     		str	r1, [r7, #8]
 171 000a 3B60     		str	r3, [r7, #0]
 172 000c 1346     		mov	r3, r2	@ movhi
 173 000e FB80     		strh	r3, [r7, #6]	@ movhi
 384:../FreeRTOS_Source/tasks.c **** signed portBASE_TYPE xReturn;
 385:../FreeRTOS_Source/tasks.c **** tskTCB * pxNewTCB;
 386:../FreeRTOS_Source/tasks.c **** 
 387:../FreeRTOS_Source/tasks.c **** 	configASSERT( pxTaskCode );
 174              		.loc 1 387 0
 175 0010 FB68     		ldr	r3, [r7, #12]
 176 0012 002B     		cmp	r3, #0
 177 0014 04D1     		bne	.L2
 178              		.loc 1 387 0 is_stmt 0 discriminator 1
 179              	@ 387 "../FreeRTOS_Source/tasks.c" 1
 180 0016 4FF05000 			mov r0, #80								
 181 001a 80F31188 		msr basepri, r0							
 182              	
 183              	@ 0 "" 2
 184              		.thumb
 185              	.L3:
 186              		.loc 1 387 0 discriminator 2
 187 001e FEE7     		b	.L3
 188              	.L2:
 388:../FreeRTOS_Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 189              		.loc 1 388 0 is_stmt 1
 190 0020 BB6A     		ldr	r3, [r7, #40]
 191 0022 012B     		cmp	r3, #1
 192 0024 04D9     		bls	.L4
 193              		.loc 1 388 0 is_stmt 0 discriminator 1
 194              	@ 388 "../FreeRTOS_Source/tasks.c" 1
 195 0026 4FF05000 			mov r0, #80								
 196 002a 80F31188 		msr basepri, r0							
 197              	
 198              	@ 0 "" 2
 199              		.thumb
 200              	.L5:
 201              		.loc 1 388 0 discriminator 2
 202 002e FEE7     		b	.L5
 203              	.L4:
 389:../FreeRTOS_Source/tasks.c **** 
 390:../FreeRTOS_Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 391:../FreeRTOS_Source/tasks.c **** 	checking that the allocation was successful. */
 392:../FreeRTOS_Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 204              		.loc 1 392 0 is_stmt 1
 205 0030 FB88     		ldrh	r3, [r7, #6]
 206 0032 1846     		mov	r0, r3
 207 0034 396B     		ldr	r1, [r7, #48]
 208 0036 FFF7FEFF 		bl	prvAllocateTCBAndStack
 209 003a B861     		str	r0, [r7, #24]
 393:../FreeRTOS_Source/tasks.c **** 
 394:../FreeRTOS_Source/tasks.c **** 	if( pxNewTCB != NULL )
 210              		.loc 1 394 0
 211 003c BB69     		ldr	r3, [r7, #24]
 212 003e 002B     		cmp	r3, #0
 213 0040 00F0BA80 		beq	.L6
 214              	.LBB2:
 395:../FreeRTOS_Source/tasks.c **** 	{
 396:../FreeRTOS_Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 397:../FreeRTOS_Source/tasks.c **** 
 398:../FreeRTOS_Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 399:../FreeRTOS_Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 400:../FreeRTOS_Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 401:../FreeRTOS_Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 402:../FreeRTOS_Source/tasks.c **** 			{
 403:../FreeRTOS_Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 404:../FreeRTOS_Source/tasks.c **** 			}
 405:../FreeRTOS_Source/tasks.c **** 			else
 406:../FreeRTOS_Source/tasks.c **** 			{
 407:../FreeRTOS_Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 408:../FreeRTOS_Source/tasks.c **** 			}
 409:../FreeRTOS_Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 410:../FreeRTOS_Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 411:../FreeRTOS_Source/tasks.c **** 
 412:../FreeRTOS_Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 413:../FreeRTOS_Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 414:../FreeRTOS_Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 415:../FreeRTOS_Source/tasks.c **** 		required by the port. */
 416:../FreeRTOS_Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 417:../FreeRTOS_Source/tasks.c **** 		{
 418:../FreeRTOS_Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 215              		.loc 1 418 0
 216 0044 BB69     		ldr	r3, [r7, #24]
 217 0046 1A6B     		ldr	r2, [r3, #48]
 218 0048 FB88     		ldrh	r3, [r7, #6]
 219 004a 03F1FF33 		add	r3, r3, #-1
 220 004e 4FEA8303 		lsl	r3, r3, #2
 221 0052 D318     		adds	r3, r2, r3
 222 0054 7B61     		str	r3, [r7, #20]
 419:../FreeRTOS_Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 223              		.loc 1 419 0
 224 0056 7B69     		ldr	r3, [r7, #20]
 225 0058 23F00703 		bic	r3, r3, #7
 226 005c 7B61     		str	r3, [r7, #20]
 420:../FreeRTOS_Source/tasks.c **** 
 421:../FreeRTOS_Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 422:../FreeRTOS_Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 227              		.loc 1 422 0
 228 005e 7B69     		ldr	r3, [r7, #20]
 229 0060 03F00703 		and	r3, r3, #7
 230 0064 002B     		cmp	r3, #0
 231 0066 04D0     		beq	.L7
 232              		.loc 1 422 0 is_stmt 0 discriminator 1
 233              	@ 422 "../FreeRTOS_Source/tasks.c" 1
 234 0068 4FF05000 			mov r0, #80								
 235 006c 80F31188 		msr basepri, r0							
 236              	
 237              	@ 0 "" 2
 238              		.thumb
 239              	.L8:
 240              		.loc 1 422 0 discriminator 2
 241 0070 FEE7     		b	.L8
 242              	.L7:
 423:../FreeRTOS_Source/tasks.c **** 		}
 424:../FreeRTOS_Source/tasks.c **** 		#else
 425:../FreeRTOS_Source/tasks.c **** 		{
 426:../FreeRTOS_Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:../FreeRTOS_Source/tasks.c **** 			
 428:../FreeRTOS_Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 429:../FreeRTOS_Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 430:../FreeRTOS_Source/tasks.c **** 
 431:../FreeRTOS_Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 432:../FreeRTOS_Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 433:../FreeRTOS_Source/tasks.c **** 			other extreme of the stack space. */
 434:../FreeRTOS_Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 435:../FreeRTOS_Source/tasks.c **** 		}
 436:../FreeRTOS_Source/tasks.c **** 		#endif
 437:../FreeRTOS_Source/tasks.c **** 
 438:../FreeRTOS_Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 439:../FreeRTOS_Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 243              		.loc 1 439 0 is_stmt 1
 244 0072 FB88     		ldrh	r3, [r7, #6]
 245 0074 0093     		str	r3, [sp, #0]
 246 0076 B869     		ldr	r0, [r7, #24]
 247 0078 B968     		ldr	r1, [r7, #8]
 248 007a BA6A     		ldr	r2, [r7, #40]
 249 007c 7B6B     		ldr	r3, [r7, #52]
 250 007e FFF7FEFF 		bl	prvInitialiseTCBVariables
 440:../FreeRTOS_Source/tasks.c **** 
 441:../FreeRTOS_Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 442:../FreeRTOS_Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 443:../FreeRTOS_Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 444:../FreeRTOS_Source/tasks.c **** 		the	top of stack variable is updated. */
 445:../FreeRTOS_Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 446:../FreeRTOS_Source/tasks.c **** 		{
 447:../FreeRTOS_Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 448:../FreeRTOS_Source/tasks.c **** 		}
 449:../FreeRTOS_Source/tasks.c **** 		#else
 450:../FreeRTOS_Source/tasks.c **** 		{
 451:../FreeRTOS_Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 251              		.loc 1 451 0
 252 0082 7869     		ldr	r0, [r7, #20]
 253 0084 F968     		ldr	r1, [r7, #12]
 254 0086 3A68     		ldr	r2, [r7, #0]
 255 0088 FFF7FEFF 		bl	pxPortInitialiseStack
 256 008c 0246     		mov	r2, r0
 257 008e BB69     		ldr	r3, [r7, #24]
 258 0090 1A60     		str	r2, [r3, #0]
 452:../FreeRTOS_Source/tasks.c **** 		}
 453:../FreeRTOS_Source/tasks.c **** 		#endif
 454:../FreeRTOS_Source/tasks.c **** 
 455:../FreeRTOS_Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 456:../FreeRTOS_Source/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 259              		.loc 1 456 0
 260 0092 BB69     		ldr	r3, [r7, #24]
 261 0094 1B68     		ldr	r3, [r3, #0]
 262 0096 03F00703 		and	r3, r3, #7
 263 009a 002B     		cmp	r3, #0
 264 009c 04D0     		beq	.L9
 265              		.loc 1 456 0 is_stmt 0 discriminator 1
 266              	@ 456 "../FreeRTOS_Source/tasks.c" 1
 267 009e 4FF05000 			mov r0, #80								
 268 00a2 80F31188 		msr basepri, r0							
 269              	
 270              	@ 0 "" 2
 271              		.thumb
 272              	.L10:
 273              		.loc 1 456 0 discriminator 2
 274 00a6 FEE7     		b	.L10
 275              	.L9:
 457:../FreeRTOS_Source/tasks.c **** 
 458:../FreeRTOS_Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 276              		.loc 1 458 0 is_stmt 1
 277 00a8 FB6A     		ldr	r3, [r7, #44]
 278 00aa 002B     		cmp	r3, #0
 279 00ac 02D0     		beq	.L11
 459:../FreeRTOS_Source/tasks.c **** 		{
 460:../FreeRTOS_Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 461:../FreeRTOS_Source/tasks.c **** 			task can use this as a handle to delete the task later if
 462:../FreeRTOS_Source/tasks.c **** 			required.*/
 463:../FreeRTOS_Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 280              		.loc 1 463 0
 281 00ae FB6A     		ldr	r3, [r7, #44]
 282 00b0 BA69     		ldr	r2, [r7, #24]
 283 00b2 1A60     		str	r2, [r3, #0]
 284              	.L11:
 464:../FreeRTOS_Source/tasks.c **** 		}
 465:../FreeRTOS_Source/tasks.c **** 		
 466:../FreeRTOS_Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 467:../FreeRTOS_Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 468:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
 285              		.loc 1 468 0
 286 00b4 FFF7FEFF 		bl	vPortEnterCritical
 469:../FreeRTOS_Source/tasks.c **** 		{
 470:../FreeRTOS_Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 287              		.loc 1 470 0
 288 00b8 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 289 00bc C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 290 00c0 1B68     		ldr	r3, [r3, #0]
 291 00c2 03F10102 		add	r2, r3, #1
 292 00c6 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 293 00ca C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 294 00ce 1A60     		str	r2, [r3, #0]
 471:../FreeRTOS_Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 295              		.loc 1 471 0
 296 00d0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 297 00d4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 298 00d8 1B68     		ldr	r3, [r3, #0]
 299 00da 002B     		cmp	r3, #0
 300 00dc 0FD1     		bne	.L12
 472:../FreeRTOS_Source/tasks.c **** 			{
 473:../FreeRTOS_Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 474:../FreeRTOS_Source/tasks.c **** 				the suspended state - make this the current task. */
 475:../FreeRTOS_Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 301              		.loc 1 475 0
 302 00de 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 303 00e2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 304 00e6 BA69     		ldr	r2, [r7, #24]
 305 00e8 1A60     		str	r2, [r3, #0]
 476:../FreeRTOS_Source/tasks.c **** 
 477:../FreeRTOS_Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 306              		.loc 1 477 0
 307 00ea 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 308 00ee C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 309 00f2 1B68     		ldr	r3, [r3, #0]
 310 00f4 012B     		cmp	r3, #1
 311 00f6 18D1     		bne	.L13
 478:../FreeRTOS_Source/tasks.c **** 				{
 479:../FreeRTOS_Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 480:../FreeRTOS_Source/tasks.c **** 					initialisation required.  We will not recover if this call
 481:../FreeRTOS_Source/tasks.c **** 					fails, but we will report the failure. */
 482:../FreeRTOS_Source/tasks.c **** 					prvInitialiseTaskLists();
 312              		.loc 1 482 0
 313 00f8 FFF7FEFF 		bl	prvInitialiseTaskLists
 314 00fc 15E0     		b	.L13
 315              	.L12:
 483:../FreeRTOS_Source/tasks.c **** 				}
 484:../FreeRTOS_Source/tasks.c **** 			}
 485:../FreeRTOS_Source/tasks.c **** 			else
 486:../FreeRTOS_Source/tasks.c **** 			{
 487:../FreeRTOS_Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 488:../FreeRTOS_Source/tasks.c **** 				current task if it is the highest priority task to be created
 489:../FreeRTOS_Source/tasks.c **** 				so far. */
 490:../FreeRTOS_Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 316              		.loc 1 490 0
 317 00fe 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 318 0102 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 319 0106 1B68     		ldr	r3, [r3, #0]
 320 0108 002B     		cmp	r3, #0
 321 010a 0ED1     		bne	.L13
 491:../FreeRTOS_Source/tasks.c **** 				{
 492:../FreeRTOS_Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 322              		.loc 1 492 0
 323 010c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 324 0110 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 325 0114 1B68     		ldr	r3, [r3, #0]
 326 0116 DA6A     		ldr	r2, [r3, #44]
 327 0118 BB6A     		ldr	r3, [r7, #40]
 328 011a 9A42     		cmp	r2, r3
 329 011c 05D8     		bhi	.L13
 493:../FreeRTOS_Source/tasks.c **** 					{
 494:../FreeRTOS_Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 330              		.loc 1 494 0
 331 011e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 332 0122 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 333 0126 BA69     		ldr	r2, [r7, #24]
 334 0128 1A60     		str	r2, [r3, #0]
 335              	.L13:
 495:../FreeRTOS_Source/tasks.c **** 					}
 496:../FreeRTOS_Source/tasks.c **** 				}
 497:../FreeRTOS_Source/tasks.c **** 			}
 498:../FreeRTOS_Source/tasks.c **** 
 499:../FreeRTOS_Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 500:../FreeRTOS_Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 501:../FreeRTOS_Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 336              		.loc 1 501 0
 337 012a BB69     		ldr	r3, [r7, #24]
 338 012c DA6A     		ldr	r2, [r3, #44]
 339 012e 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 340 0132 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 341 0136 1B68     		ldr	r3, [r3, #0]
 342 0138 9A42     		cmp	r2, r3
 343 013a 06D9     		bls	.L14
 502:../FreeRTOS_Source/tasks.c **** 			{
 503:../FreeRTOS_Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 344              		.loc 1 503 0
 345 013c BB69     		ldr	r3, [r7, #24]
 346 013e DA6A     		ldr	r2, [r3, #44]
 347 0140 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 348 0144 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 349 0148 1A60     		str	r2, [r3, #0]
 350              	.L14:
 504:../FreeRTOS_Source/tasks.c **** 			}
 505:../FreeRTOS_Source/tasks.c **** 
 506:../FreeRTOS_Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 507:../FreeRTOS_Source/tasks.c **** 			{
 508:../FreeRTOS_Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 509:../FreeRTOS_Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTCBNumber;
 510:../FreeRTOS_Source/tasks.c **** 			}
 511:../FreeRTOS_Source/tasks.c **** 			#endif
 512:../FreeRTOS_Source/tasks.c **** 			uxTCBNumber++;
 351              		.loc 1 512 0
 352 014a 40F20003 		movw	r3, #:lower16:uxTCBNumber
 353 014e C0F20003 		movt	r3, #:upper16:uxTCBNumber
 354 0152 1B68     		ldr	r3, [r3, #0]
 355 0154 03F10102 		add	r2, r3, #1
 356 0158 40F20003 		movw	r3, #:lower16:uxTCBNumber
 357 015c C0F20003 		movt	r3, #:upper16:uxTCBNumber
 358 0160 1A60     		str	r2, [r3, #0]
 513:../FreeRTOS_Source/tasks.c **** 
 514:../FreeRTOS_Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 359              		.loc 1 514 0
 360 0162 BB69     		ldr	r3, [r7, #24]
 361 0164 DA6A     		ldr	r2, [r3, #44]
 362 0166 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 363 016a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 364 016e 1B68     		ldr	r3, [r3, #0]
 365 0170 9A42     		cmp	r2, r3
 366 0172 06D9     		bls	.L15
 367              		.loc 1 514 0 is_stmt 0 discriminator 1
 368 0174 BB69     		ldr	r3, [r7, #24]
 369 0176 DA6A     		ldr	r2, [r3, #44]
 370 0178 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 371 017c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 372 0180 1A60     		str	r2, [r3, #0]
 373              	.L15:
 374              		.loc 1 514 0 discriminator 2
 375 0182 BB69     		ldr	r3, [r7, #24]
 376 0184 DA6A     		ldr	r2, [r3, #44]
 377 0186 1346     		mov	r3, r2
 378 0188 4FEA8303 		lsl	r3, r3, #2
 379 018c 9B18     		adds	r3, r3, r2
 380 018e 4FEA8303 		lsl	r3, r3, #2
 381 0192 1A46     		mov	r2, r3
 382 0194 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 383 0198 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 384 019c D218     		adds	r2, r2, r3
 385 019e BB69     		ldr	r3, [r7, #24]
 386 01a0 03F10403 		add	r3, r3, #4
 387 01a4 1046     		mov	r0, r2
 388 01a6 1946     		mov	r1, r3
 389 01a8 FFF7FEFF 		bl	vListInsertEnd
 515:../FreeRTOS_Source/tasks.c **** 
 516:../FreeRTOS_Source/tasks.c **** 			xReturn = pdPASS;
 390              		.loc 1 516 0 is_stmt 1 discriminator 2
 391 01ac 4FF00103 		mov	r3, #1
 392 01b0 FB61     		str	r3, [r7, #28]
 517:../FreeRTOS_Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 518:../FreeRTOS_Source/tasks.c **** 		}
 519:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
 393              		.loc 1 519 0 discriminator 2
 394 01b2 FFF7FEFF 		bl	vPortExitCritical
 395 01b6 02E0     		b	.L16
 396              	.L6:
 397              	.LBE2:
 520:../FreeRTOS_Source/tasks.c **** 	}
 521:../FreeRTOS_Source/tasks.c **** 	else
 522:../FreeRTOS_Source/tasks.c **** 	{
 523:../FreeRTOS_Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 398              		.loc 1 523 0
 399 01b8 4FF0FF33 		mov	r3, #-1
 400 01bc FB61     		str	r3, [r7, #28]
 401              	.L16:
 524:../FreeRTOS_Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 525:../FreeRTOS_Source/tasks.c **** 	}
 526:../FreeRTOS_Source/tasks.c **** 
 527:../FreeRTOS_Source/tasks.c **** 	if( xReturn == pdPASS )
 402              		.loc 1 527 0
 403 01be FB69     		ldr	r3, [r7, #28]
 404 01c0 012B     		cmp	r3, #1
 405 01c2 11D1     		bne	.L17
 528:../FreeRTOS_Source/tasks.c **** 	{
 529:../FreeRTOS_Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 406              		.loc 1 529 0
 407 01c4 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 408 01c8 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 409 01cc 1B68     		ldr	r3, [r3, #0]
 410 01ce 002B     		cmp	r3, #0
 411 01d0 0AD0     		beq	.L17
 530:../FreeRTOS_Source/tasks.c **** 		{
 531:../FreeRTOS_Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 532:../FreeRTOS_Source/tasks.c **** 			then it should run now. */
 533:../FreeRTOS_Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 412              		.loc 1 533 0
 413 01d2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 414 01d6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 415 01da 1B68     		ldr	r3, [r3, #0]
 416 01dc DA6A     		ldr	r2, [r3, #44]
 417 01de BB6A     		ldr	r3, [r7, #40]
 418 01e0 9A42     		cmp	r2, r3
 419 01e2 01D2     		bcs	.L17
 534:../FreeRTOS_Source/tasks.c **** 			{
 535:../FreeRTOS_Source/tasks.c **** 				portYIELD_WITHIN_API();
 420              		.loc 1 535 0
 421 01e4 FFF7FEFF 		bl	vPortYieldFromISR
 422              	.L17:
 536:../FreeRTOS_Source/tasks.c **** 			}
 537:../FreeRTOS_Source/tasks.c **** 		}
 538:../FreeRTOS_Source/tasks.c **** 	}
 539:../FreeRTOS_Source/tasks.c **** 
 540:../FreeRTOS_Source/tasks.c **** 	return xReturn;
 423              		.loc 1 540 0
 424 01e8 FB69     		ldr	r3, [r7, #28]
 541:../FreeRTOS_Source/tasks.c **** }
 425              		.loc 1 541 0
 426 01ea 1846     		mov	r0, r3
 427 01ec 07F12007 		add	r7, r7, #32
 428 01f0 BD46     		mov	sp, r7
 429 01f2 80BD     		pop	{r7, pc}
 430              		.cfi_endproc
 431              	.LFE0:
 433              		.section	.text.vTaskDelete,"ax",%progbits
 434              		.align	2
 435              		.global	vTaskDelete
 436              		.thumb
 437              		.thumb_func
 439              	vTaskDelete:
 440              	.LFB1:
 542:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 543:../FreeRTOS_Source/tasks.c **** 
 544:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 545:../FreeRTOS_Source/tasks.c **** 
 546:../FreeRTOS_Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 547:../FreeRTOS_Source/tasks.c **** 	{
 441              		.loc 1 547 0
 442              		.cfi_startproc
 443              		@ args = 0, pretend = 0, frame = 16
 444              		@ frame_needed = 1, uses_anonymous_args = 0
 445 0000 80B5     		push	{r7, lr}
 446              	.LCFI3:
 447              		.cfi_def_cfa_offset 8
 448              		.cfi_offset 14, -4
 449              		.cfi_offset 7, -8
 450 0002 84B0     		sub	sp, sp, #16
 451              	.LCFI4:
 452              		.cfi_def_cfa_offset 24
 453 0004 00AF     		add	r7, sp, #0
 454              	.LCFI5:
 455              		.cfi_def_cfa_register 7
 456 0006 7860     		str	r0, [r7, #4]
 548:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
 549:../FreeRTOS_Source/tasks.c **** 
 550:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
 457              		.loc 1 550 0
 458 0008 FFF7FEFF 		bl	vPortEnterCritical
 551:../FreeRTOS_Source/tasks.c **** 		{
 552:../FreeRTOS_Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 553:../FreeRTOS_Source/tasks.c **** 			deleted. */
 554:../FreeRTOS_Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 459              		.loc 1 554 0
 460 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 461 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 462 0014 1B68     		ldr	r3, [r3, #0]
 463 0016 7A68     		ldr	r2, [r7, #4]
 464 0018 9A42     		cmp	r2, r3
 465 001a 02D1     		bne	.L19
 555:../FreeRTOS_Source/tasks.c **** 			{
 556:../FreeRTOS_Source/tasks.c **** 				pxTaskToDelete = NULL;
 466              		.loc 1 556 0
 467 001c 4FF00003 		mov	r3, #0
 468 0020 7B60     		str	r3, [r7, #4]
 469              	.L19:
 557:../FreeRTOS_Source/tasks.c **** 			}
 558:../FreeRTOS_Source/tasks.c **** 
 559:../FreeRTOS_Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 560:../FreeRTOS_Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 470              		.loc 1 560 0
 471 0022 7B68     		ldr	r3, [r7, #4]
 472 0024 002B     		cmp	r3, #0
 473 0026 05D1     		bne	.L20
 474              		.loc 1 560 0 is_stmt 0 discriminator 1
 475 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 476 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 477 0030 1B68     		ldr	r3, [r3, #0]
 478 0032 00E0     		b	.L21
 479              	.L20:
 480              		.loc 1 560 0 discriminator 2
 481 0034 7B68     		ldr	r3, [r7, #4]
 482              	.L21:
 483              		.loc 1 560 0 discriminator 3
 484 0036 FB60     		str	r3, [r7, #12]
 561:../FreeRTOS_Source/tasks.c **** 
 562:../FreeRTOS_Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 563:../FreeRTOS_Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 564:../FreeRTOS_Source/tasks.c **** 			the termination list and free up any memory allocated by the
 565:../FreeRTOS_Source/tasks.c **** 			scheduler for the TCB and stack. */
 566:../FreeRTOS_Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 485              		.loc 1 566 0 is_stmt 1 discriminator 3
 486 0038 FB68     		ldr	r3, [r7, #12]
 487 003a 03F10403 		add	r3, r3, #4
 488 003e 1846     		mov	r0, r3
 489 0040 FFF7FEFF 		bl	vListRemove
 567:../FreeRTOS_Source/tasks.c **** 
 568:../FreeRTOS_Source/tasks.c **** 			/* Is the task waiting on an event also? */
 569:../FreeRTOS_Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 490              		.loc 1 569 0 discriminator 3
 491 0044 FB68     		ldr	r3, [r7, #12]
 492 0046 9B6A     		ldr	r3, [r3, #40]
 493 0048 002B     		cmp	r3, #0
 494 004a 05D0     		beq	.L22
 570:../FreeRTOS_Source/tasks.c **** 			{
 571:../FreeRTOS_Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 495              		.loc 1 571 0
 496 004c FB68     		ldr	r3, [r7, #12]
 497 004e 03F11803 		add	r3, r3, #24
 498 0052 1846     		mov	r0, r3
 499 0054 FFF7FEFF 		bl	vListRemove
 500              	.L22:
 572:../FreeRTOS_Source/tasks.c **** 			}
 573:../FreeRTOS_Source/tasks.c **** 
 574:../FreeRTOS_Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 501              		.loc 1 574 0
 502 0058 FB68     		ldr	r3, [r7, #12]
 503 005a 03F10403 		add	r3, r3, #4
 504 005e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 505 0062 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 506 0066 1946     		mov	r1, r3
 507 0068 FFF7FEFF 		bl	vListInsertEnd
 575:../FreeRTOS_Source/tasks.c **** 
 576:../FreeRTOS_Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 577:../FreeRTOS_Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 578:../FreeRTOS_Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 579:../FreeRTOS_Source/tasks.c **** 			++uxTasksDeleted;
 508              		.loc 1 579 0
 509 006c 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 510 0070 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 511 0074 1B68     		ldr	r3, [r3, #0]
 512 0076 03F10102 		add	r2, r3, #1
 513 007a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 514 007e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 515 0082 1A60     		str	r2, [r3, #0]
 580:../FreeRTOS_Source/tasks.c **** 
 581:../FreeRTOS_Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 582:../FreeRTOS_Source/tasks.c **** 			can detect that the task lists need re-generating. */
 583:../FreeRTOS_Source/tasks.c **** 			uxTCBNumber++;
 516              		.loc 1 583 0
 517 0084 40F20003 		movw	r3, #:lower16:uxTCBNumber
 518 0088 C0F20003 		movt	r3, #:upper16:uxTCBNumber
 519 008c 1B68     		ldr	r3, [r3, #0]
 520 008e 03F10102 		add	r2, r3, #1
 521 0092 40F20003 		movw	r3, #:lower16:uxTCBNumber
 522 0096 C0F20003 		movt	r3, #:upper16:uxTCBNumber
 523 009a 1A60     		str	r2, [r3, #0]
 584:../FreeRTOS_Source/tasks.c **** 
 585:../FreeRTOS_Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 586:../FreeRTOS_Source/tasks.c **** 		}
 587:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
 524              		.loc 1 587 0
 525 009c FFF7FEFF 		bl	vPortExitCritical
 588:../FreeRTOS_Source/tasks.c **** 
 589:../FreeRTOS_Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 590:../FreeRTOS_Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 526              		.loc 1 590 0
 527 00a0 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 528 00a4 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 529 00a8 1B68     		ldr	r3, [r3, #0]
 530 00aa 002B     		cmp	r3, #0
 531 00ac 04D0     		beq	.L18
 591:../FreeRTOS_Source/tasks.c **** 		{
 592:../FreeRTOS_Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 532              		.loc 1 592 0
 533 00ae 7B68     		ldr	r3, [r7, #4]
 534 00b0 002B     		cmp	r3, #0
 535 00b2 01D1     		bne	.L18
 593:../FreeRTOS_Source/tasks.c **** 			{
 594:../FreeRTOS_Source/tasks.c **** 				portYIELD_WITHIN_API();
 536              		.loc 1 594 0
 537 00b4 FFF7FEFF 		bl	vPortYieldFromISR
 538              	.L18:
 595:../FreeRTOS_Source/tasks.c **** 			}
 596:../FreeRTOS_Source/tasks.c **** 		}
 597:../FreeRTOS_Source/tasks.c **** 	}
 539              		.loc 1 597 0
 540 00b8 07F11007 		add	r7, r7, #16
 541 00bc BD46     		mov	sp, r7
 542 00be 80BD     		pop	{r7, pc}
 543              		.cfi_endproc
 544              	.LFE1:
 546              		.section	.text.vTaskDelayUntil,"ax",%progbits
 547              		.align	2
 548              		.global	vTaskDelayUntil
 549              		.thumb
 550              		.thumb_func
 552              	vTaskDelayUntil:
 553              	.LFB2:
 598:../FreeRTOS_Source/tasks.c **** 
 599:../FreeRTOS_Source/tasks.c **** #endif
 600:../FreeRTOS_Source/tasks.c **** 
 601:../FreeRTOS_Source/tasks.c **** 
 602:../FreeRTOS_Source/tasks.c **** 
 603:../FreeRTOS_Source/tasks.c **** 
 604:../FreeRTOS_Source/tasks.c **** 
 605:../FreeRTOS_Source/tasks.c **** 
 606:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------
 607:../FreeRTOS_Source/tasks.c ****  * TASK CONTROL API documented in task.h
 608:../FreeRTOS_Source/tasks.c ****  *----------------------------------------------------------*/
 609:../FreeRTOS_Source/tasks.c **** 
 610:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 611:../FreeRTOS_Source/tasks.c **** 
 612:../FreeRTOS_Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 613:../FreeRTOS_Source/tasks.c **** 	{
 554              		.loc 1 613 0
 555              		.cfi_startproc
 556              		@ args = 0, pretend = 0, frame = 24
 557              		@ frame_needed = 1, uses_anonymous_args = 0
 558 0000 80B5     		push	{r7, lr}
 559              	.LCFI6:
 560              		.cfi_def_cfa_offset 8
 561              		.cfi_offset 14, -4
 562              		.cfi_offset 7, -8
 563 0002 86B0     		sub	sp, sp, #24
 564              	.LCFI7:
 565              		.cfi_def_cfa_offset 32
 566 0004 00AF     		add	r7, sp, #0
 567              	.LCFI8:
 568              		.cfi_def_cfa_register 7
 569 0006 7860     		str	r0, [r7, #4]
 570 0008 3960     		str	r1, [r7, #0]
 614:../FreeRTOS_Source/tasks.c **** 	portTickType xTimeToWake;
 615:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 571              		.loc 1 615 0
 572 000a 4FF00003 		mov	r3, #0
 573 000e 7B61     		str	r3, [r7, #20]
 616:../FreeRTOS_Source/tasks.c **** 
 617:../FreeRTOS_Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 574              		.loc 1 617 0
 575 0010 7B68     		ldr	r3, [r7, #4]
 576 0012 002B     		cmp	r3, #0
 577 0014 04D1     		bne	.L25
 578              		.loc 1 617 0 is_stmt 0 discriminator 1
 579              	@ 617 "../FreeRTOS_Source/tasks.c" 1
 580 0016 4FF05000 			mov r0, #80								
 581 001a 80F31188 		msr basepri, r0							
 582              	
 583              	@ 0 "" 2
 584              		.thumb
 585              	.L26:
 586              		.loc 1 617 0 discriminator 2
 587 001e FEE7     		b	.L26
 588              	.L25:
 618:../FreeRTOS_Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 589              		.loc 1 618 0 is_stmt 1
 590 0020 3B68     		ldr	r3, [r7, #0]
 591 0022 002B     		cmp	r3, #0
 592 0024 04D1     		bne	.L27
 593              		.loc 1 618 0 is_stmt 0 discriminator 1
 594              	@ 618 "../FreeRTOS_Source/tasks.c" 1
 595 0026 4FF05000 			mov r0, #80								
 596 002a 80F31188 		msr basepri, r0							
 597              	
 598              	@ 0 "" 2
 599              		.thumb
 600              	.L28:
 601              		.loc 1 618 0 discriminator 2
 602 002e FEE7     		b	.L28
 603              	.L27:
 619:../FreeRTOS_Source/tasks.c **** 
 620:../FreeRTOS_Source/tasks.c **** 		vTaskSuspendAll();
 604              		.loc 1 620 0 is_stmt 1
 605 0030 FFF7FEFF 		bl	vTaskSuspendAll
 621:../FreeRTOS_Source/tasks.c **** 		{
 622:../FreeRTOS_Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 623:../FreeRTOS_Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 606              		.loc 1 623 0
 607 0034 7B68     		ldr	r3, [r7, #4]
 608 0036 1A68     		ldr	r2, [r3, #0]
 609 0038 3B68     		ldr	r3, [r7, #0]
 610 003a D318     		adds	r3, r2, r3
 611 003c 3B61     		str	r3, [r7, #16]
 624:../FreeRTOS_Source/tasks.c **** 
 625:../FreeRTOS_Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 612              		.loc 1 625 0
 613 003e 7B68     		ldr	r3, [r7, #4]
 614 0040 1A68     		ldr	r2, [r3, #0]
 615 0042 40F20003 		movw	r3, #:lower16:xTickCount
 616 0046 C0F20003 		movt	r3, #:upper16:xTickCount
 617 004a 1B68     		ldr	r3, [r3, #0]
 618 004c 9A42     		cmp	r2, r3
 619 004e 10D9     		bls	.L29
 626:../FreeRTOS_Source/tasks.c **** 			{
 627:../FreeRTOS_Source/tasks.c **** 				/* The tick count has overflowed since this function was
 628:../FreeRTOS_Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 629:../FreeRTOS_Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 630:../FreeRTOS_Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 631:../FreeRTOS_Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 632:../FreeRTOS_Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 620              		.loc 1 632 0
 621 0050 7B68     		ldr	r3, [r7, #4]
 622 0052 1A68     		ldr	r2, [r3, #0]
 623 0054 3B69     		ldr	r3, [r7, #16]
 624 0056 9A42     		cmp	r2, r3
 625 0058 1BD9     		bls	.L30
 626              		.loc 1 632 0 is_stmt 0 discriminator 1
 627 005a 40F20003 		movw	r3, #:lower16:xTickCount
 628 005e C0F20003 		movt	r3, #:upper16:xTickCount
 629 0062 1B68     		ldr	r3, [r3, #0]
 630 0064 3A69     		ldr	r2, [r7, #16]
 631 0066 9A42     		cmp	r2, r3
 632 0068 13D9     		bls	.L30
 633:../FreeRTOS_Source/tasks.c **** 				{
 634:../FreeRTOS_Source/tasks.c **** 					xShouldDelay = pdTRUE;
 633              		.loc 1 634 0 is_stmt 1
 634 006a 4FF00103 		mov	r3, #1
 635 006e 7B61     		str	r3, [r7, #20]
 636 0070 0FE0     		b	.L30
 637              	.L29:
 635:../FreeRTOS_Source/tasks.c **** 				}
 636:../FreeRTOS_Source/tasks.c **** 			}
 637:../FreeRTOS_Source/tasks.c **** 			else
 638:../FreeRTOS_Source/tasks.c **** 			{
 639:../FreeRTOS_Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 640:../FreeRTOS_Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 641:../FreeRTOS_Source/tasks.c **** 				tick time is less than the wake time. */
 642:../FreeRTOS_Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 638              		.loc 1 642 0
 639 0072 7B68     		ldr	r3, [r7, #4]
 640 0074 1A68     		ldr	r2, [r3, #0]
 641 0076 3B69     		ldr	r3, [r7, #16]
 642 0078 9A42     		cmp	r2, r3
 643 007a 07D8     		bhi	.L31
 644              		.loc 1 642 0 is_stmt 0 discriminator 1
 645 007c 40F20003 		movw	r3, #:lower16:xTickCount
 646 0080 C0F20003 		movt	r3, #:upper16:xTickCount
 647 0084 1B68     		ldr	r3, [r3, #0]
 648 0086 3A69     		ldr	r2, [r7, #16]
 649 0088 9A42     		cmp	r2, r3
 650 008a 02D9     		bls	.L30
 651              	.L31:
 643:../FreeRTOS_Source/tasks.c **** 				{
 644:../FreeRTOS_Source/tasks.c **** 					xShouldDelay = pdTRUE;
 652              		.loc 1 644 0 is_stmt 1
 653 008c 4FF00103 		mov	r3, #1
 654 0090 7B61     		str	r3, [r7, #20]
 655              	.L30:
 645:../FreeRTOS_Source/tasks.c **** 				}
 646:../FreeRTOS_Source/tasks.c **** 			}
 647:../FreeRTOS_Source/tasks.c **** 
 648:../FreeRTOS_Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 649:../FreeRTOS_Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 656              		.loc 1 649 0
 657 0092 7B68     		ldr	r3, [r7, #4]
 658 0094 3A69     		ldr	r2, [r7, #16]
 659 0096 1A60     		str	r2, [r3, #0]
 650:../FreeRTOS_Source/tasks.c **** 
 651:../FreeRTOS_Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 660              		.loc 1 651 0
 661 0098 7B69     		ldr	r3, [r7, #20]
 662 009a 002B     		cmp	r3, #0
 663 009c 0CD0     		beq	.L32
 652:../FreeRTOS_Source/tasks.c **** 			{
 653:../FreeRTOS_Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 654:../FreeRTOS_Source/tasks.c **** 
 655:../FreeRTOS_Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 656:../FreeRTOS_Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 657:../FreeRTOS_Source/tasks.c **** 				both lists. */
 658:../FreeRTOS_Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 664              		.loc 1 658 0
 665 009e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 666 00a2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 667 00a6 1B68     		ldr	r3, [r3, #0]
 668 00a8 03F10403 		add	r3, r3, #4
 669 00ac 1846     		mov	r0, r3
 670 00ae FFF7FEFF 		bl	vListRemove
 659:../FreeRTOS_Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 671              		.loc 1 659 0
 672 00b2 3869     		ldr	r0, [r7, #16]
 673 00b4 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 674              	.L32:
 660:../FreeRTOS_Source/tasks.c **** 			}
 661:../FreeRTOS_Source/tasks.c **** 		}
 662:../FreeRTOS_Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 675              		.loc 1 662 0
 676 00b8 FFF7FEFF 		bl	xTaskResumeAll
 677 00bc F860     		str	r0, [r7, #12]
 663:../FreeRTOS_Source/tasks.c **** 
 664:../FreeRTOS_Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 665:../FreeRTOS_Source/tasks.c **** 		have put ourselves to sleep. */
 666:../FreeRTOS_Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 678              		.loc 1 666 0
 679 00be FB68     		ldr	r3, [r7, #12]
 680 00c0 002B     		cmp	r3, #0
 681 00c2 01D1     		bne	.L24
 667:../FreeRTOS_Source/tasks.c **** 		{
 668:../FreeRTOS_Source/tasks.c **** 			portYIELD_WITHIN_API();
 682              		.loc 1 668 0
 683 00c4 FFF7FEFF 		bl	vPortYieldFromISR
 684              	.L24:
 669:../FreeRTOS_Source/tasks.c **** 		}
 670:../FreeRTOS_Source/tasks.c **** 	}
 685              		.loc 1 670 0
 686 00c8 07F11807 		add	r7, r7, #24
 687 00cc BD46     		mov	sp, r7
 688 00ce 80BD     		pop	{r7, pc}
 689              		.cfi_endproc
 690              	.LFE2:
 692              		.section	.text.vTaskDelay,"ax",%progbits
 693              		.align	2
 694              		.global	vTaskDelay
 695              		.thumb
 696              		.thumb_func
 698              	vTaskDelay:
 699              	.LFB3:
 671:../FreeRTOS_Source/tasks.c **** 
 672:../FreeRTOS_Source/tasks.c **** #endif
 673:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 674:../FreeRTOS_Source/tasks.c **** 
 675:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 676:../FreeRTOS_Source/tasks.c **** 
 677:../FreeRTOS_Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 678:../FreeRTOS_Source/tasks.c **** 	{
 700              		.loc 1 678 0
 701              		.cfi_startproc
 702              		@ args = 0, pretend = 0, frame = 16
 703              		@ frame_needed = 1, uses_anonymous_args = 0
 704 0000 80B5     		push	{r7, lr}
 705              	.LCFI9:
 706              		.cfi_def_cfa_offset 8
 707              		.cfi_offset 14, -4
 708              		.cfi_offset 7, -8
 709 0002 84B0     		sub	sp, sp, #16
 710              	.LCFI10:
 711              		.cfi_def_cfa_offset 24
 712 0004 00AF     		add	r7, sp, #0
 713              	.LCFI11:
 714              		.cfi_def_cfa_register 7
 715 0006 7860     		str	r0, [r7, #4]
 679:../FreeRTOS_Source/tasks.c **** 	portTickType xTimeToWake;
 680:../FreeRTOS_Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 716              		.loc 1 680 0
 717 0008 4FF00003 		mov	r3, #0
 718 000c FB60     		str	r3, [r7, #12]
 681:../FreeRTOS_Source/tasks.c **** 
 682:../FreeRTOS_Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 683:../FreeRTOS_Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 719              		.loc 1 683 0
 720 000e 7B68     		ldr	r3, [r7, #4]
 721 0010 002B     		cmp	r3, #0
 722 0012 19D0     		beq	.L35
 684:../FreeRTOS_Source/tasks.c **** 		{
 685:../FreeRTOS_Source/tasks.c **** 			vTaskSuspendAll();
 723              		.loc 1 685 0
 724 0014 FFF7FEFF 		bl	vTaskSuspendAll
 686:../FreeRTOS_Source/tasks.c **** 			{
 687:../FreeRTOS_Source/tasks.c **** 				traceTASK_DELAY();
 688:../FreeRTOS_Source/tasks.c **** 
 689:../FreeRTOS_Source/tasks.c **** 				/* A task that is removed from the event list while the
 690:../FreeRTOS_Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 691:../FreeRTOS_Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 692:../FreeRTOS_Source/tasks.c **** 				is resumed.
 693:../FreeRTOS_Source/tasks.c **** 
 694:../FreeRTOS_Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 695:../FreeRTOS_Source/tasks.c **** 				executing task. */
 696:../FreeRTOS_Source/tasks.c **** 
 697:../FreeRTOS_Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 698:../FreeRTOS_Source/tasks.c **** 				not a problem. */
 699:../FreeRTOS_Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 725              		.loc 1 699 0
 726 0018 40F20003 		movw	r3, #:lower16:xTickCount
 727 001c C0F20003 		movt	r3, #:upper16:xTickCount
 728 0020 1A68     		ldr	r2, [r3, #0]
 729 0022 7B68     		ldr	r3, [r7, #4]
 730 0024 D318     		adds	r3, r2, r3
 731 0026 BB60     		str	r3, [r7, #8]
 700:../FreeRTOS_Source/tasks.c **** 
 701:../FreeRTOS_Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 702:../FreeRTOS_Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 703:../FreeRTOS_Source/tasks.c **** 				both lists. */
 704:../FreeRTOS_Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 732              		.loc 1 704 0
 733 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 734 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 735 0030 1B68     		ldr	r3, [r3, #0]
 736 0032 03F10403 		add	r3, r3, #4
 737 0036 1846     		mov	r0, r3
 738 0038 FFF7FEFF 		bl	vListRemove
 705:../FreeRTOS_Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 739              		.loc 1 705 0
 740 003c B868     		ldr	r0, [r7, #8]
 741 003e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 706:../FreeRTOS_Source/tasks.c **** 			}
 707:../FreeRTOS_Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 742              		.loc 1 707 0
 743 0042 FFF7FEFF 		bl	xTaskResumeAll
 744 0046 F860     		str	r0, [r7, #12]
 745              	.L35:
 708:../FreeRTOS_Source/tasks.c **** 		}
 709:../FreeRTOS_Source/tasks.c **** 
 710:../FreeRTOS_Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 711:../FreeRTOS_Source/tasks.c **** 		have put ourselves to sleep. */
 712:../FreeRTOS_Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 746              		.loc 1 712 0
 747 0048 FB68     		ldr	r3, [r7, #12]
 748 004a 002B     		cmp	r3, #0
 749 004c 01D1     		bne	.L34
 713:../FreeRTOS_Source/tasks.c **** 		{
 714:../FreeRTOS_Source/tasks.c **** 			portYIELD_WITHIN_API();
 750              		.loc 1 714 0
 751 004e FFF7FEFF 		bl	vPortYieldFromISR
 752              	.L34:
 715:../FreeRTOS_Source/tasks.c **** 		}
 716:../FreeRTOS_Source/tasks.c **** 	}
 753              		.loc 1 716 0
 754 0052 07F11007 		add	r7, r7, #16
 755 0056 BD46     		mov	sp, r7
 756 0058 80BD     		pop	{r7, pc}
 757              		.cfi_endproc
 758              	.LFE3:
 760 005a 00BF     		.section	.text.uxTaskPriorityGet,"ax",%progbits
 761              		.align	2
 762              		.global	uxTaskPriorityGet
 763              		.thumb
 764              		.thumb_func
 766              	uxTaskPriorityGet:
 767              	.LFB4:
 717:../FreeRTOS_Source/tasks.c **** 
 718:../FreeRTOS_Source/tasks.c **** #endif
 719:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 720:../FreeRTOS_Source/tasks.c **** 
 721:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 722:../FreeRTOS_Source/tasks.c **** 
 723:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 724:../FreeRTOS_Source/tasks.c **** 	{
 768              		.loc 1 724 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 16
 771              		@ frame_needed = 1, uses_anonymous_args = 0
 772 0000 80B5     		push	{r7, lr}
 773              	.LCFI12:
 774              		.cfi_def_cfa_offset 8
 775              		.cfi_offset 14, -4
 776              		.cfi_offset 7, -8
 777 0002 84B0     		sub	sp, sp, #16
 778              	.LCFI13:
 779              		.cfi_def_cfa_offset 24
 780 0004 00AF     		add	r7, sp, #0
 781              	.LCFI14:
 782              		.cfi_def_cfa_register 7
 783 0006 7860     		str	r0, [r7, #4]
 725:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
 726:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 727:../FreeRTOS_Source/tasks.c **** 
 728:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
 784              		.loc 1 728 0
 785 0008 FFF7FEFF 		bl	vPortEnterCritical
 729:../FreeRTOS_Source/tasks.c **** 		{
 730:../FreeRTOS_Source/tasks.c **** 			/* If null is passed in here then we are changing the
 731:../FreeRTOS_Source/tasks.c **** 			priority of the calling function. */
 732:../FreeRTOS_Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 786              		.loc 1 732 0
 787 000c 7B68     		ldr	r3, [r7, #4]
 788 000e 002B     		cmp	r3, #0
 789 0010 05D1     		bne	.L38
 790              		.loc 1 732 0 is_stmt 0 discriminator 1
 791 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 792 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 793 001a 1B68     		ldr	r3, [r3, #0]
 794 001c 00E0     		b	.L39
 795              	.L38:
 796              		.loc 1 732 0 discriminator 2
 797 001e 7B68     		ldr	r3, [r7, #4]
 798              	.L39:
 799              		.loc 1 732 0 discriminator 3
 800 0020 FB60     		str	r3, [r7, #12]
 733:../FreeRTOS_Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 801              		.loc 1 733 0 is_stmt 1 discriminator 3
 802 0022 FB68     		ldr	r3, [r7, #12]
 803 0024 DB6A     		ldr	r3, [r3, #44]
 804 0026 BB60     		str	r3, [r7, #8]
 734:../FreeRTOS_Source/tasks.c **** 		}
 735:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
 805              		.loc 1 735 0 discriminator 3
 806 0028 FFF7FEFF 		bl	vPortExitCritical
 736:../FreeRTOS_Source/tasks.c **** 
 737:../FreeRTOS_Source/tasks.c **** 		return uxReturn;
 807              		.loc 1 737 0 discriminator 3
 808 002c BB68     		ldr	r3, [r7, #8]
 738:../FreeRTOS_Source/tasks.c **** 	}
 809              		.loc 1 738 0 discriminator 3
 810 002e 1846     		mov	r0, r3
 811 0030 07F11007 		add	r7, r7, #16
 812 0034 BD46     		mov	sp, r7
 813 0036 80BD     		pop	{r7, pc}
 814              		.cfi_endproc
 815              	.LFE4:
 817              		.section	.text.vTaskPrioritySet,"ax",%progbits
 818              		.align	2
 819              		.global	vTaskPrioritySet
 820              		.thumb
 821              		.thumb_func
 823              	vTaskPrioritySet:
 824              	.LFB5:
 739:../FreeRTOS_Source/tasks.c **** 
 740:../FreeRTOS_Source/tasks.c **** #endif
 741:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 742:../FreeRTOS_Source/tasks.c **** 
 743:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 744:../FreeRTOS_Source/tasks.c **** 
 745:../FreeRTOS_Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 746:../FreeRTOS_Source/tasks.c **** 	{
 825              		.loc 1 746 0
 826              		.cfi_startproc
 827              		@ args = 0, pretend = 0, frame = 24
 828              		@ frame_needed = 1, uses_anonymous_args = 0
 829 0000 80B5     		push	{r7, lr}
 830              	.LCFI15:
 831              		.cfi_def_cfa_offset 8
 832              		.cfi_offset 14, -4
 833              		.cfi_offset 7, -8
 834 0002 86B0     		sub	sp, sp, #24
 835              	.LCFI16:
 836              		.cfi_def_cfa_offset 32
 837 0004 00AF     		add	r7, sp, #0
 838              	.LCFI17:
 839              		.cfi_def_cfa_register 7
 840 0006 7860     		str	r0, [r7, #4]
 841 0008 3960     		str	r1, [r7, #0]
 747:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
 748:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 749:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 842              		.loc 1 749 0
 843 000a 4FF00003 		mov	r3, #0
 844 000e 7B61     		str	r3, [r7, #20]
 750:../FreeRTOS_Source/tasks.c **** 
 751:../FreeRTOS_Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 845              		.loc 1 751 0
 846 0010 3B68     		ldr	r3, [r7, #0]
 847 0012 012B     		cmp	r3, #1
 848 0014 04D9     		bls	.L41
 849              		.loc 1 751 0 is_stmt 0 discriminator 1
 850              	@ 751 "../FreeRTOS_Source/tasks.c" 1
 851 0016 4FF05000 			mov r0, #80								
 852 001a 80F31188 		msr basepri, r0							
 853              	
 854              	@ 0 "" 2
 855              		.thumb
 856              	.L42:
 857              		.loc 1 751 0 discriminator 2
 858 001e FEE7     		b	.L42
 859              	.L41:
 752:../FreeRTOS_Source/tasks.c **** 
 753:../FreeRTOS_Source/tasks.c **** 		/* Ensure the new priority is valid. */
 754:../FreeRTOS_Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 860              		.loc 1 754 0 is_stmt 1
 861 0020 3B68     		ldr	r3, [r7, #0]
 862 0022 012B     		cmp	r3, #1
 863 0024 02D9     		bls	.L43
 755:../FreeRTOS_Source/tasks.c **** 		{
 756:../FreeRTOS_Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 864              		.loc 1 756 0
 865 0026 4FF00103 		mov	r3, #1
 866 002a 3B60     		str	r3, [r7, #0]
 867              	.L43:
 757:../FreeRTOS_Source/tasks.c **** 		}
 758:../FreeRTOS_Source/tasks.c **** 
 759:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
 868              		.loc 1 759 0
 869 002c FFF7FEFF 		bl	vPortEnterCritical
 760:../FreeRTOS_Source/tasks.c **** 		{
 761:../FreeRTOS_Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 870              		.loc 1 761 0
 871 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 872 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 873 0038 1B68     		ldr	r3, [r3, #0]
 874 003a 7A68     		ldr	r2, [r7, #4]
 875 003c 9A42     		cmp	r2, r3
 876 003e 02D1     		bne	.L44
 762:../FreeRTOS_Source/tasks.c **** 			{
 763:../FreeRTOS_Source/tasks.c **** 				pxTask = NULL;
 877              		.loc 1 763 0
 878 0040 4FF00003 		mov	r3, #0
 879 0044 7B60     		str	r3, [r7, #4]
 880              	.L44:
 764:../FreeRTOS_Source/tasks.c **** 			}
 765:../FreeRTOS_Source/tasks.c **** 
 766:../FreeRTOS_Source/tasks.c **** 			/* If null is passed in here then we are changing the
 767:../FreeRTOS_Source/tasks.c **** 			priority of the calling function. */
 768:../FreeRTOS_Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 881              		.loc 1 768 0
 882 0046 7B68     		ldr	r3, [r7, #4]
 883 0048 002B     		cmp	r3, #0
 884 004a 05D1     		bne	.L45
 885              		.loc 1 768 0 is_stmt 0 discriminator 1
 886 004c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 887 0050 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 888 0054 1B68     		ldr	r3, [r3, #0]
 889 0056 00E0     		b	.L46
 890              	.L45:
 891              		.loc 1 768 0 discriminator 2
 892 0058 7B68     		ldr	r3, [r7, #4]
 893              	.L46:
 894              		.loc 1 768 0 discriminator 3
 895 005a 3B61     		str	r3, [r7, #16]
 769:../FreeRTOS_Source/tasks.c **** 
 770:../FreeRTOS_Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 771:../FreeRTOS_Source/tasks.c **** 
 772:../FreeRTOS_Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 773:../FreeRTOS_Source/tasks.c **** 			{
 774:../FreeRTOS_Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 896              		.loc 1 774 0 is_stmt 1 discriminator 3
 897 005c 3B69     		ldr	r3, [r7, #16]
 898 005e 1B6C     		ldr	r3, [r3, #64]
 899 0060 FB60     		str	r3, [r7, #12]
 775:../FreeRTOS_Source/tasks.c **** 			}
 776:../FreeRTOS_Source/tasks.c **** 			#else
 777:../FreeRTOS_Source/tasks.c **** 			{
 778:../FreeRTOS_Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 779:../FreeRTOS_Source/tasks.c **** 			}
 780:../FreeRTOS_Source/tasks.c **** 			#endif
 781:../FreeRTOS_Source/tasks.c **** 
 782:../FreeRTOS_Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 900              		.loc 1 782 0 discriminator 3
 901 0062 FA68     		ldr	r2, [r7, #12]
 902 0064 3B68     		ldr	r3, [r7, #0]
 903 0066 9A42     		cmp	r2, r3
 904 0068 62D0     		beq	.L47
 783:../FreeRTOS_Source/tasks.c **** 			{
 784:../FreeRTOS_Source/tasks.c **** 				/* The priority change may have readied a task of higher
 785:../FreeRTOS_Source/tasks.c **** 				priority than the calling task. */
 786:../FreeRTOS_Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 905              		.loc 1 786 0
 906 006a 3A68     		ldr	r2, [r7, #0]
 907 006c FB68     		ldr	r3, [r7, #12]
 908 006e 9A42     		cmp	r2, r3
 909 0070 06D9     		bls	.L48
 787:../FreeRTOS_Source/tasks.c **** 				{
 788:../FreeRTOS_Source/tasks.c **** 					if( pxTask != NULL )
 910              		.loc 1 788 0
 911 0072 7B68     		ldr	r3, [r7, #4]
 912 0074 002B     		cmp	r3, #0
 913 0076 09D0     		beq	.L49
 789:../FreeRTOS_Source/tasks.c **** 					{
 790:../FreeRTOS_Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 791:../FreeRTOS_Source/tasks.c **** 						were raising the priority of the currently running task
 792:../FreeRTOS_Source/tasks.c **** 						there would be no need to switch as it must have already
 793:../FreeRTOS_Source/tasks.c **** 						been the highest priority task. */
 794:../FreeRTOS_Source/tasks.c **** 						xYieldRequired = pdTRUE;
 914              		.loc 1 794 0
 915 0078 4FF00103 		mov	r3, #1
 916 007c 7B61     		str	r3, [r7, #20]
 917 007e 05E0     		b	.L49
 918              	.L48:
 795:../FreeRTOS_Source/tasks.c **** 					}
 796:../FreeRTOS_Source/tasks.c **** 				}
 797:../FreeRTOS_Source/tasks.c **** 				else if( pxTask == NULL )
 919              		.loc 1 797 0
 920 0080 7B68     		ldr	r3, [r7, #4]
 921 0082 002B     		cmp	r3, #0
 922 0084 02D1     		bne	.L49
 798:../FreeRTOS_Source/tasks.c **** 				{
 799:../FreeRTOS_Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 800:../FreeRTOS_Source/tasks.c **** 					task of higher priority that is ready to execute. */
 801:../FreeRTOS_Source/tasks.c **** 					xYieldRequired = pdTRUE;
 923              		.loc 1 801 0
 924 0086 4FF00103 		mov	r3, #1
 925 008a 7B61     		str	r3, [r7, #20]
 926              	.L49:
 802:../FreeRTOS_Source/tasks.c **** 				}
 803:../FreeRTOS_Source/tasks.c **** 
 804:../FreeRTOS_Source/tasks.c **** 
 805:../FreeRTOS_Source/tasks.c **** 
 806:../FreeRTOS_Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 807:../FreeRTOS_Source/tasks.c **** 				{
 808:../FreeRTOS_Source/tasks.c **** 					/* Only change the priority being used if the task is not
 809:../FreeRTOS_Source/tasks.c **** 					currently using an inherited priority. */
 810:../FreeRTOS_Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 927              		.loc 1 810 0
 928 008c 3B69     		ldr	r3, [r7, #16]
 929 008e 1A6C     		ldr	r2, [r3, #64]
 930 0090 3B69     		ldr	r3, [r7, #16]
 931 0092 DB6A     		ldr	r3, [r3, #44]
 932 0094 9A42     		cmp	r2, r3
 933 0096 02D1     		bne	.L50
 811:../FreeRTOS_Source/tasks.c **** 					{
 812:../FreeRTOS_Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 934              		.loc 1 812 0
 935 0098 3B69     		ldr	r3, [r7, #16]
 936 009a 3A68     		ldr	r2, [r7, #0]
 937 009c DA62     		str	r2, [r3, #44]
 938              	.L50:
 813:../FreeRTOS_Source/tasks.c **** 					}
 814:../FreeRTOS_Source/tasks.c **** 
 815:../FreeRTOS_Source/tasks.c **** 					/* The base priority gets set whatever. */
 816:../FreeRTOS_Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 939              		.loc 1 816 0
 940 009e 3B69     		ldr	r3, [r7, #16]
 941 00a0 3A68     		ldr	r2, [r7, #0]
 942 00a2 1A64     		str	r2, [r3, #64]
 817:../FreeRTOS_Source/tasks.c **** 				}
 818:../FreeRTOS_Source/tasks.c **** 				#else
 819:../FreeRTOS_Source/tasks.c **** 				{
 820:../FreeRTOS_Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 821:../FreeRTOS_Source/tasks.c **** 				}
 822:../FreeRTOS_Source/tasks.c **** 				#endif
 823:../FreeRTOS_Source/tasks.c **** 
 824:../FreeRTOS_Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 943              		.loc 1 824 0
 944 00a4 3B68     		ldr	r3, [r7, #0]
 945 00a6 C3F10202 		rsb	r2, r3, #2
 946 00aa 3B69     		ldr	r3, [r7, #16]
 947 00ac 9A61     		str	r2, [r3, #24]
 825:../FreeRTOS_Source/tasks.c **** 
 826:../FreeRTOS_Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 827:../FreeRTOS_Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 828:../FreeRTOS_Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 829:../FreeRTOS_Source/tasks.c **** 				in the queue appropriate to its new priority. */
 830:../FreeRTOS_Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 948              		.loc 1 830 0
 949 00ae 3B69     		ldr	r3, [r7, #16]
 950 00b0 5969     		ldr	r1, [r3, #20]
 951 00b2 FA68     		ldr	r2, [r7, #12]
 952 00b4 1346     		mov	r3, r2
 953 00b6 4FEA8303 		lsl	r3, r3, #2
 954 00ba 9B18     		adds	r3, r3, r2
 955 00bc 4FEA8303 		lsl	r3, r3, #2
 956 00c0 1A46     		mov	r2, r3
 957 00c2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 958 00c6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 959 00ca D318     		adds	r3, r2, r3
 960 00cc 9942     		cmp	r1, r3
 961 00ce 2AD1     		bne	.L51
 831:../FreeRTOS_Source/tasks.c **** 				{
 832:../FreeRTOS_Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 833:../FreeRTOS_Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 834:../FreeRTOS_Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 835:../FreeRTOS_Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 962              		.loc 1 835 0
 963 00d0 3B69     		ldr	r3, [r7, #16]
 964 00d2 03F10403 		add	r3, r3, #4
 965 00d6 1846     		mov	r0, r3
 966 00d8 FFF7FEFF 		bl	vListRemove
 836:../FreeRTOS_Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 967              		.loc 1 836 0
 968 00dc 3B69     		ldr	r3, [r7, #16]
 969 00de DA6A     		ldr	r2, [r3, #44]
 970 00e0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 971 00e4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 972 00e8 1B68     		ldr	r3, [r3, #0]
 973 00ea 9A42     		cmp	r2, r3
 974 00ec 06D9     		bls	.L52
 975              		.loc 1 836 0 is_stmt 0 discriminator 1
 976 00ee 3B69     		ldr	r3, [r7, #16]
 977 00f0 DA6A     		ldr	r2, [r3, #44]
 978 00f2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 979 00f6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 980 00fa 1A60     		str	r2, [r3, #0]
 981              	.L52:
 982              		.loc 1 836 0 discriminator 2
 983 00fc 3B69     		ldr	r3, [r7, #16]
 984 00fe DA6A     		ldr	r2, [r3, #44]
 985 0100 1346     		mov	r3, r2
 986 0102 4FEA8303 		lsl	r3, r3, #2
 987 0106 9B18     		adds	r3, r3, r2
 988 0108 4FEA8303 		lsl	r3, r3, #2
 989 010c 1A46     		mov	r2, r3
 990 010e 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 991 0112 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 992 0116 D218     		adds	r2, r2, r3
 993 0118 3B69     		ldr	r3, [r7, #16]
 994 011a 03F10403 		add	r3, r3, #4
 995 011e 1046     		mov	r0, r2
 996 0120 1946     		mov	r1, r3
 997 0122 FFF7FEFF 		bl	vListInsertEnd
 998              	.L51:
 837:../FreeRTOS_Source/tasks.c **** 				}
 838:../FreeRTOS_Source/tasks.c **** 
 839:../FreeRTOS_Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 999              		.loc 1 839 0 is_stmt 1
 1000 0126 7B69     		ldr	r3, [r7, #20]
 1001 0128 012B     		cmp	r3, #1
 1002 012a 01D1     		bne	.L47
 840:../FreeRTOS_Source/tasks.c **** 				{
 841:../FreeRTOS_Source/tasks.c **** 					portYIELD_WITHIN_API();
 1003              		.loc 1 841 0
 1004 012c FFF7FEFF 		bl	vPortYieldFromISR
 1005              	.L47:
 842:../FreeRTOS_Source/tasks.c **** 				}
 843:../FreeRTOS_Source/tasks.c **** 			}
 844:../FreeRTOS_Source/tasks.c **** 		}
 845:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
 1006              		.loc 1 845 0
 1007 0130 FFF7FEFF 		bl	vPortExitCritical
 846:../FreeRTOS_Source/tasks.c **** 	}
 1008              		.loc 1 846 0
 1009 0134 07F11807 		add	r7, r7, #24
 1010 0138 BD46     		mov	sp, r7
 1011 013a 80BD     		pop	{r7, pc}
 1012              		.cfi_endproc
 1013              	.LFE5:
 1015              		.section	.text.vTaskSuspend,"ax",%progbits
 1016              		.align	2
 1017              		.global	vTaskSuspend
 1018              		.thumb
 1019              		.thumb_func
 1021              	vTaskSuspend:
 1022              	.LFB6:
 847:../FreeRTOS_Source/tasks.c **** 
 848:../FreeRTOS_Source/tasks.c **** #endif
 849:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 850:../FreeRTOS_Source/tasks.c **** 
 851:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 852:../FreeRTOS_Source/tasks.c **** 
 853:../FreeRTOS_Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 854:../FreeRTOS_Source/tasks.c **** 	{
 1023              		.loc 1 854 0
 1024              		.cfi_startproc
 1025              		@ args = 0, pretend = 0, frame = 16
 1026              		@ frame_needed = 1, uses_anonymous_args = 0
 1027 0000 80B5     		push	{r7, lr}
 1028              	.LCFI18:
 1029              		.cfi_def_cfa_offset 8
 1030              		.cfi_offset 14, -4
 1031              		.cfi_offset 7, -8
 1032 0002 84B0     		sub	sp, sp, #16
 1033              	.LCFI19:
 1034              		.cfi_def_cfa_offset 24
 1035 0004 00AF     		add	r7, sp, #0
 1036              	.LCFI20:
 1037              		.cfi_def_cfa_register 7
 1038 0006 7860     		str	r0, [r7, #4]
 855:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
 856:../FreeRTOS_Source/tasks.c **** 
 857:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
 1039              		.loc 1 857 0
 1040 0008 FFF7FEFF 		bl	vPortEnterCritical
 858:../FreeRTOS_Source/tasks.c **** 		{
 859:../FreeRTOS_Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 860:../FreeRTOS_Source/tasks.c **** 			suspended. */
 861:../FreeRTOS_Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1041              		.loc 1 861 0
 1042 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1043 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1044 0014 1B68     		ldr	r3, [r3, #0]
 1045 0016 7A68     		ldr	r2, [r7, #4]
 1046 0018 9A42     		cmp	r2, r3
 1047 001a 02D1     		bne	.L54
 862:../FreeRTOS_Source/tasks.c **** 			{
 863:../FreeRTOS_Source/tasks.c **** 				pxTaskToSuspend = NULL;
 1048              		.loc 1 863 0
 1049 001c 4FF00003 		mov	r3, #0
 1050 0020 7B60     		str	r3, [r7, #4]
 1051              	.L54:
 864:../FreeRTOS_Source/tasks.c **** 			}
 865:../FreeRTOS_Source/tasks.c **** 
 866:../FreeRTOS_Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 867:../FreeRTOS_Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1052              		.loc 1 867 0
 1053 0022 7B68     		ldr	r3, [r7, #4]
 1054 0024 002B     		cmp	r3, #0
 1055 0026 05D1     		bne	.L55
 1056              		.loc 1 867 0 is_stmt 0 discriminator 1
 1057 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1058 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1059 0030 1B68     		ldr	r3, [r3, #0]
 1060 0032 00E0     		b	.L56
 1061              	.L55:
 1062              		.loc 1 867 0 discriminator 2
 1063 0034 7B68     		ldr	r3, [r7, #4]
 1064              	.L56:
 1065              		.loc 1 867 0 discriminator 3
 1066 0036 FB60     		str	r3, [r7, #12]
 868:../FreeRTOS_Source/tasks.c **** 
 869:../FreeRTOS_Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 870:../FreeRTOS_Source/tasks.c **** 
 871:../FreeRTOS_Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 872:../FreeRTOS_Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1067              		.loc 1 872 0 is_stmt 1 discriminator 3
 1068 0038 FB68     		ldr	r3, [r7, #12]
 1069 003a 03F10403 		add	r3, r3, #4
 1070 003e 1846     		mov	r0, r3
 1071 0040 FFF7FEFF 		bl	vListRemove
 873:../FreeRTOS_Source/tasks.c **** 
 874:../FreeRTOS_Source/tasks.c **** 			/* Is the task waiting on an event also? */
 875:../FreeRTOS_Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 1072              		.loc 1 875 0 discriminator 3
 1073 0044 FB68     		ldr	r3, [r7, #12]
 1074 0046 9B6A     		ldr	r3, [r3, #40]
 1075 0048 002B     		cmp	r3, #0
 1076 004a 05D0     		beq	.L57
 876:../FreeRTOS_Source/tasks.c **** 			{
 877:../FreeRTOS_Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1077              		.loc 1 877 0
 1078 004c FB68     		ldr	r3, [r7, #12]
 1079 004e 03F11803 		add	r3, r3, #24
 1080 0052 1846     		mov	r0, r3
 1081 0054 FFF7FEFF 		bl	vListRemove
 1082              	.L57:
 878:../FreeRTOS_Source/tasks.c **** 			}
 879:../FreeRTOS_Source/tasks.c **** 
 880:../FreeRTOS_Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1083              		.loc 1 880 0
 1084 0058 FB68     		ldr	r3, [r7, #12]
 1085 005a 03F10403 		add	r3, r3, #4
 1086 005e 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 1087 0062 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 1088 0066 1946     		mov	r1, r3
 1089 0068 FFF7FEFF 		bl	vListInsertEnd
 881:../FreeRTOS_Source/tasks.c **** 		}
 882:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
 1090              		.loc 1 882 0
 1091 006c FFF7FEFF 		bl	vPortExitCritical
 883:../FreeRTOS_Source/tasks.c **** 
 884:../FreeRTOS_Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1092              		.loc 1 884 0
 1093 0070 7B68     		ldr	r3, [r7, #4]
 1094 0072 002B     		cmp	r3, #0
 1095 0074 1FD1     		bne	.L53
 885:../FreeRTOS_Source/tasks.c **** 		{
 886:../FreeRTOS_Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1096              		.loc 1 886 0
 1097 0076 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1098 007a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1099 007e 1B68     		ldr	r3, [r3, #0]
 1100 0080 002B     		cmp	r3, #0
 1101 0082 02D0     		beq	.L59
 887:../FreeRTOS_Source/tasks.c **** 			{
 888:../FreeRTOS_Source/tasks.c **** 				/* We have just suspended the current task. */
 889:../FreeRTOS_Source/tasks.c **** 				portYIELD_WITHIN_API();
 1102              		.loc 1 889 0
 1103 0084 FFF7FEFF 		bl	vPortYieldFromISR
 1104 0088 15E0     		b	.L53
 1105              	.L59:
 890:../FreeRTOS_Source/tasks.c **** 			}
 891:../FreeRTOS_Source/tasks.c **** 			else
 892:../FreeRTOS_Source/tasks.c **** 			{
 893:../FreeRTOS_Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 894:../FreeRTOS_Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 895:../FreeRTOS_Source/tasks.c **** 				must be adjusted to point to a different task. */
 896:../FreeRTOS_Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1106              		.loc 1 896 0
 1107 008a 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1108 008e C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1109 0092 1A68     		ldr	r2, [r3, #0]
 1110 0094 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1111 0098 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1112 009c 1B68     		ldr	r3, [r3, #0]
 1113 009e 9A42     		cmp	r2, r3
 1114 00a0 07D1     		bne	.L60
 897:../FreeRTOS_Source/tasks.c **** 				{
 898:../FreeRTOS_Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 899:../FreeRTOS_Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 900:../FreeRTOS_Source/tasks.c **** 					be set to point to it no matter what its relative priority
 901:../FreeRTOS_Source/tasks.c **** 					is. */
 902:../FreeRTOS_Source/tasks.c **** 					pxCurrentTCB = NULL;
 1115              		.loc 1 902 0
 1116 00a2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1117 00a6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1118 00aa 4FF00002 		mov	r2, #0
 1119 00ae 1A60     		str	r2, [r3, #0]
 1120 00b0 01E0     		b	.L53
 1121              	.L60:
 903:../FreeRTOS_Source/tasks.c **** 				}
 904:../FreeRTOS_Source/tasks.c **** 				else
 905:../FreeRTOS_Source/tasks.c **** 				{
 906:../FreeRTOS_Source/tasks.c **** 					vTaskSwitchContext();
 1122              		.loc 1 906 0
 1123 00b2 FFF7FEFF 		bl	vTaskSwitchContext
 1124              	.L53:
 907:../FreeRTOS_Source/tasks.c **** 				}
 908:../FreeRTOS_Source/tasks.c **** 			}
 909:../FreeRTOS_Source/tasks.c **** 		}
 910:../FreeRTOS_Source/tasks.c **** 	}
 1125              		.loc 1 910 0
 1126 00b6 07F11007 		add	r7, r7, #16
 1127 00ba BD46     		mov	sp, r7
 1128 00bc 80BD     		pop	{r7, pc}
 1129              		.cfi_endproc
 1130              	.LFE6:
 1132 00be 00BF     		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1133              		.align	2
 1134              		.global	xTaskIsTaskSuspended
 1135              		.thumb
 1136              		.thumb_func
 1138              	xTaskIsTaskSuspended:
 1139              	.LFB7:
 911:../FreeRTOS_Source/tasks.c **** 
 912:../FreeRTOS_Source/tasks.c **** #endif
 913:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 914:../FreeRTOS_Source/tasks.c **** 
 915:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 916:../FreeRTOS_Source/tasks.c **** 
 917:../FreeRTOS_Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 918:../FreeRTOS_Source/tasks.c **** 	{
 1140              		.loc 1 918 0
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 16
 1143              		@ frame_needed = 1, uses_anonymous_args = 0
 1144              		@ link register save eliminated.
 1145 0000 80B4     		push	{r7}
 1146              	.LCFI21:
 1147              		.cfi_def_cfa_offset 4
 1148              		.cfi_offset 7, -4
 1149 0002 85B0     		sub	sp, sp, #20
 1150              	.LCFI22:
 1151              		.cfi_def_cfa_offset 24
 1152 0004 00AF     		add	r7, sp, #0
 1153              	.LCFI23:
 1154              		.cfi_def_cfa_register 7
 1155 0006 7860     		str	r0, [r7, #4]
 919:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1156              		.loc 1 919 0
 1157 0008 4FF00003 		mov	r3, #0
 1158 000c FB60     		str	r3, [r7, #12]
 920:../FreeRTOS_Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1159              		.loc 1 920 0
 1160 000e 7B68     		ldr	r3, [r7, #4]
 1161 0010 BB60     		str	r3, [r7, #8]
 921:../FreeRTOS_Source/tasks.c **** 
 922:../FreeRTOS_Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 923:../FreeRTOS_Source/tasks.c **** 		configASSERT( xTask );
 1162              		.loc 1 923 0
 1163 0012 7B68     		ldr	r3, [r7, #4]
 1164 0014 002B     		cmp	r3, #0
 1165 0016 04D1     		bne	.L62
 1166              		.loc 1 923 0 is_stmt 0 discriminator 1
 1167              	@ 923 "../FreeRTOS_Source/tasks.c" 1
 1168 0018 4FF05000 			mov r0, #80								
 1169 001c 80F31188 		msr basepri, r0							
 1170              	
 1171              	@ 0 "" 2
 1172              		.thumb
 1173              	.L63:
 1174              		.loc 1 923 0 discriminator 2
 1175 0020 FEE7     		b	.L63
 1176              	.L62:
 924:../FreeRTOS_Source/tasks.c **** 
 925:../FreeRTOS_Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 926:../FreeRTOS_Source/tasks.c **** 		suspended list? */
 927:../FreeRTOS_Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1177              		.loc 1 927 0 is_stmt 1
 1178 0022 BB68     		ldr	r3, [r7, #8]
 1179 0024 5A69     		ldr	r2, [r3, #20]
 1180 0026 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1181 002a C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1182 002e 9A42     		cmp	r2, r3
 1183 0030 0ED1     		bne	.L64
 928:../FreeRTOS_Source/tasks.c **** 		{
 929:../FreeRTOS_Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 930:../FreeRTOS_Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1184              		.loc 1 930 0
 1185 0032 BB68     		ldr	r3, [r7, #8]
 1186 0034 9A6A     		ldr	r2, [r3, #40]
 1187 0036 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1188 003a C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1189 003e 9A42     		cmp	r2, r3
 1190 0040 06D0     		beq	.L64
 931:../FreeRTOS_Source/tasks.c **** 			{
 932:../FreeRTOS_Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 933:../FreeRTOS_Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 934:../FreeRTOS_Source/tasks.c **** 				list because it is blocked on a task with no timeout
 935:../FreeRTOS_Source/tasks.c **** 				specified. */
 936:../FreeRTOS_Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1191              		.loc 1 936 0
 1192 0042 BB68     		ldr	r3, [r7, #8]
 1193 0044 9B6A     		ldr	r3, [r3, #40]
 1194 0046 002B     		cmp	r3, #0
 1195 0048 02D1     		bne	.L64
 937:../FreeRTOS_Source/tasks.c **** 				{
 938:../FreeRTOS_Source/tasks.c **** 					xReturn = pdTRUE;
 1196              		.loc 1 938 0
 1197 004a 4FF00103 		mov	r3, #1
 1198 004e FB60     		str	r3, [r7, #12]
 1199              	.L64:
 939:../FreeRTOS_Source/tasks.c **** 				}
 940:../FreeRTOS_Source/tasks.c **** 			}
 941:../FreeRTOS_Source/tasks.c **** 		}
 942:../FreeRTOS_Source/tasks.c **** 
 943:../FreeRTOS_Source/tasks.c **** 		return xReturn;
 1200              		.loc 1 943 0
 1201 0050 FB68     		ldr	r3, [r7, #12]
 944:../FreeRTOS_Source/tasks.c **** 	}
 1202              		.loc 1 944 0
 1203 0052 1846     		mov	r0, r3
 1204 0054 07F11407 		add	r7, r7, #20
 1205 0058 BD46     		mov	sp, r7
 1206 005a 80BC     		pop	{r7}
 1207 005c 7047     		bx	lr
 1208              		.cfi_endproc
 1209              	.LFE7:
 1211 005e 00BF     		.section	.text.vTaskResume,"ax",%progbits
 1212              		.align	2
 1213              		.global	vTaskResume
 1214              		.thumb
 1215              		.thumb_func
 1217              	vTaskResume:
 1218              	.LFB8:
 945:../FreeRTOS_Source/tasks.c **** 
 946:../FreeRTOS_Source/tasks.c **** #endif
 947:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 948:../FreeRTOS_Source/tasks.c **** 
 949:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 950:../FreeRTOS_Source/tasks.c **** 
 951:../FreeRTOS_Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 952:../FreeRTOS_Source/tasks.c **** 	{
 1219              		.loc 1 952 0
 1220              		.cfi_startproc
 1221              		@ args = 0, pretend = 0, frame = 16
 1222              		@ frame_needed = 1, uses_anonymous_args = 0
 1223 0000 80B5     		push	{r7, lr}
 1224              	.LCFI24:
 1225              		.cfi_def_cfa_offset 8
 1226              		.cfi_offset 14, -4
 1227              		.cfi_offset 7, -8
 1228 0002 84B0     		sub	sp, sp, #16
 1229              	.LCFI25:
 1230              		.cfi_def_cfa_offset 24
 1231 0004 00AF     		add	r7, sp, #0
 1232              	.LCFI26:
 1233              		.cfi_def_cfa_register 7
 1234 0006 7860     		str	r0, [r7, #4]
 953:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
 954:../FreeRTOS_Source/tasks.c **** 
 955:../FreeRTOS_Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
 956:../FreeRTOS_Source/tasks.c **** 		configASSERT( pxTaskToResume );
 1235              		.loc 1 956 0
 1236 0008 7B68     		ldr	r3, [r7, #4]
 1237 000a 002B     		cmp	r3, #0
 1238 000c 04D1     		bne	.L66
 1239              		.loc 1 956 0 is_stmt 0 discriminator 1
 1240              	@ 956 "../FreeRTOS_Source/tasks.c" 1
 1241 000e 4FF05000 			mov r0, #80								
 1242 0012 80F31188 		msr basepri, r0							
 1243              	
 1244              	@ 0 "" 2
 1245              		.thumb
 1246              	.L67:
 1247              		.loc 1 956 0 discriminator 2
 1248 0016 FEE7     		b	.L67
 1249              	.L66:
 957:../FreeRTOS_Source/tasks.c **** 
 958:../FreeRTOS_Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 959:../FreeRTOS_Source/tasks.c **** 		it in the ready list. */
 960:../FreeRTOS_Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1250              		.loc 1 960 0 is_stmt 1
 1251 0018 7B68     		ldr	r3, [r7, #4]
 1252 001a FB60     		str	r3, [r7, #12]
 961:../FreeRTOS_Source/tasks.c **** 
 962:../FreeRTOS_Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 963:../FreeRTOS_Source/tasks.c **** 		currently executing task. */
 964:../FreeRTOS_Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1253              		.loc 1 964 0
 1254 001c FB68     		ldr	r3, [r7, #12]
 1255 001e 002B     		cmp	r3, #0
 1256 0020 48D0     		beq	.L65
 1257              		.loc 1 964 0 is_stmt 0 discriminator 1
 1258 0022 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1259 0026 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1260 002a 1B68     		ldr	r3, [r3, #0]
 1261 002c FA68     		ldr	r2, [r7, #12]
 1262 002e 9A42     		cmp	r2, r3
 1263 0030 40D0     		beq	.L65
 965:../FreeRTOS_Source/tasks.c **** 		{
 966:../FreeRTOS_Source/tasks.c **** 			taskENTER_CRITICAL();
 1264              		.loc 1 966 0 is_stmt 1
 1265 0032 FFF7FEFF 		bl	vPortEnterCritical
 967:../FreeRTOS_Source/tasks.c **** 			{
 968:../FreeRTOS_Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1266              		.loc 1 968 0
 1267 0036 F868     		ldr	r0, [r7, #12]
 1268 0038 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1269 003c 0346     		mov	r3, r0
 1270 003e 012B     		cmp	r3, #1
 1271 0040 36D1     		bne	.L69
 969:../FreeRTOS_Source/tasks.c **** 				{
 970:../FreeRTOS_Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 971:../FreeRTOS_Source/tasks.c **** 
 972:../FreeRTOS_Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 973:../FreeRTOS_Source/tasks.c **** 					lists even if the scheduler is suspended. */
 974:../FreeRTOS_Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1272              		.loc 1 974 0
 1273 0042 FB68     		ldr	r3, [r7, #12]
 1274 0044 03F10403 		add	r3, r3, #4
 1275 0048 1846     		mov	r0, r3
 1276 004a FFF7FEFF 		bl	vListRemove
 975:../FreeRTOS_Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1277              		.loc 1 975 0
 1278 004e FB68     		ldr	r3, [r7, #12]
 1279 0050 DA6A     		ldr	r2, [r3, #44]
 1280 0052 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1281 0056 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1282 005a 1B68     		ldr	r3, [r3, #0]
 1283 005c 9A42     		cmp	r2, r3
 1284 005e 06D9     		bls	.L70
 1285              		.loc 1 975 0 is_stmt 0 discriminator 1
 1286 0060 FB68     		ldr	r3, [r7, #12]
 1287 0062 DA6A     		ldr	r2, [r3, #44]
 1288 0064 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1289 0068 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1290 006c 1A60     		str	r2, [r3, #0]
 1291              	.L70:
 1292              		.loc 1 975 0 discriminator 2
 1293 006e FB68     		ldr	r3, [r7, #12]
 1294 0070 DA6A     		ldr	r2, [r3, #44]
 1295 0072 1346     		mov	r3, r2
 1296 0074 4FEA8303 		lsl	r3, r3, #2
 1297 0078 9B18     		adds	r3, r3, r2
 1298 007a 4FEA8303 		lsl	r3, r3, #2
 1299 007e 1A46     		mov	r2, r3
 1300 0080 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1301 0084 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1302 0088 D218     		adds	r2, r2, r3
 1303 008a FB68     		ldr	r3, [r7, #12]
 1304 008c 03F10403 		add	r3, r3, #4
 1305 0090 1046     		mov	r0, r2
 1306 0092 1946     		mov	r1, r3
 1307 0094 FFF7FEFF 		bl	vListInsertEnd
 976:../FreeRTOS_Source/tasks.c **** 
 977:../FreeRTOS_Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 978:../FreeRTOS_Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1308              		.loc 1 978 0 is_stmt 1 discriminator 2
 1309 0098 FB68     		ldr	r3, [r7, #12]
 1310 009a DA6A     		ldr	r2, [r3, #44]
 1311 009c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1312 00a0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1313 00a4 1B68     		ldr	r3, [r3, #0]
 1314 00a6 DB6A     		ldr	r3, [r3, #44]
 1315 00a8 9A42     		cmp	r2, r3
 1316 00aa 01D3     		bcc	.L69
 979:../FreeRTOS_Source/tasks.c **** 					{
 980:../FreeRTOS_Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 981:../FreeRTOS_Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 982:../FreeRTOS_Source/tasks.c **** 						portYIELD_WITHIN_API();
 1317              		.loc 1 982 0
 1318 00ac FFF7FEFF 		bl	vPortYieldFromISR
 1319              	.L69:
 983:../FreeRTOS_Source/tasks.c **** 					}
 984:../FreeRTOS_Source/tasks.c **** 				}
 985:../FreeRTOS_Source/tasks.c **** 			}
 986:../FreeRTOS_Source/tasks.c **** 			taskEXIT_CRITICAL();
 1320              		.loc 1 986 0
 1321 00b0 FFF7FEFF 		bl	vPortExitCritical
 1322              	.L65:
 987:../FreeRTOS_Source/tasks.c **** 		}
 988:../FreeRTOS_Source/tasks.c **** 	}
 1323              		.loc 1 988 0
 1324 00b4 07F11007 		add	r7, r7, #16
 1325 00b8 BD46     		mov	sp, r7
 1326 00ba 80BD     		pop	{r7, pc}
 1327              		.cfi_endproc
 1328              	.LFE8:
 1330              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1331              		.align	2
 1332              		.global	xTaskResumeFromISR
 1333              		.thumb
 1334              		.thumb_func
 1336              	xTaskResumeFromISR:
 1337              	.LFB9:
 989:../FreeRTOS_Source/tasks.c **** 
 990:../FreeRTOS_Source/tasks.c **** #endif
 991:../FreeRTOS_Source/tasks.c **** 
 992:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
 993:../FreeRTOS_Source/tasks.c **** 
 994:../FreeRTOS_Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 995:../FreeRTOS_Source/tasks.c **** 
 996:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 997:../FreeRTOS_Source/tasks.c **** 	{
 1338              		.loc 1 997 0
 1339              		.cfi_startproc
 1340              		@ args = 0, pretend = 0, frame = 24
 1341              		@ frame_needed = 1, uses_anonymous_args = 0
 1342 0000 80B5     		push	{r7, lr}
 1343              	.LCFI27:
 1344              		.cfi_def_cfa_offset 8
 1345              		.cfi_offset 14, -4
 1346              		.cfi_offset 7, -8
 1347 0002 86B0     		sub	sp, sp, #24
 1348              	.LCFI28:
 1349              		.cfi_def_cfa_offset 32
 1350 0004 00AF     		add	r7, sp, #0
 1351              	.LCFI29:
 1352              		.cfi_def_cfa_register 7
 1353 0006 7860     		str	r0, [r7, #4]
 998:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1354              		.loc 1 998 0
 1355 0008 4FF00003 		mov	r3, #0
 1356 000c 7B61     		str	r3, [r7, #20]
 999:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
1000:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:../FreeRTOS_Source/tasks.c **** 
1002:../FreeRTOS_Source/tasks.c **** 		configASSERT( pxTaskToResume );
 1357              		.loc 1 1002 0
 1358 000e 7B68     		ldr	r3, [r7, #4]
 1359 0010 002B     		cmp	r3, #0
 1360 0012 04D1     		bne	.L72
 1361              		.loc 1 1002 0 is_stmt 0 discriminator 1
 1362              	@ 1002 "../FreeRTOS_Source/tasks.c" 1
 1363 0014 4FF05000 			mov r0, #80								
 1364 0018 80F31188 		msr basepri, r0							
 1365              	
 1366              	@ 0 "" 2
 1367              		.thumb
 1368              	.L73:
 1369              		.loc 1 1002 0 discriminator 2
 1370 001c FEE7     		b	.L73
 1371              	.L72:
1003:../FreeRTOS_Source/tasks.c **** 
1004:../FreeRTOS_Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1372              		.loc 1 1004 0 is_stmt 1
 1373 001e 7B68     		ldr	r3, [r7, #4]
 1374 0020 3B61     		str	r3, [r7, #16]
1005:../FreeRTOS_Source/tasks.c **** 
1006:../FreeRTOS_Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1375              		.loc 1 1006 0
 1376 0022 4FF00003 		mov	r3, #0
 1377 0026 FB60     		str	r3, [r7, #12]
 1378              	@ 1006 "../FreeRTOS_Source/tasks.c" 1
 1379 0028 4FF05000 			mov r0, #80								
 1380 002c 80F31188 		msr basepri, r0							
 1381              	
 1382              	@ 0 "" 2
1007:../FreeRTOS_Source/tasks.c **** 		{
1008:../FreeRTOS_Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1383              		.loc 1 1008 0
 1384              		.thumb
 1385 0030 3869     		ldr	r0, [r7, #16]
 1386 0032 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1387 0036 0346     		mov	r3, r0
 1388 0038 012B     		cmp	r3, #1
 1389 003a 49D1     		bne	.L74
1009:../FreeRTOS_Source/tasks.c **** 			{
1010:../FreeRTOS_Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:../FreeRTOS_Source/tasks.c **** 
1012:../FreeRTOS_Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1390              		.loc 1 1012 0
 1391 003c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1392 0040 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1393 0044 1B68     		ldr	r3, [r3, #0]
 1394 0046 002B     		cmp	r3, #0
 1395 0048 38D1     		bne	.L75
1013:../FreeRTOS_Source/tasks.c **** 				{
1014:../FreeRTOS_Source/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1396              		.loc 1 1014 0
 1397 004a 3B69     		ldr	r3, [r7, #16]
 1398 004c DA6A     		ldr	r2, [r3, #44]
 1399 004e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1400 0052 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1401 0056 1B68     		ldr	r3, [r3, #0]
 1402 0058 DB6A     		ldr	r3, [r3, #44]
 1403 005a 9A42     		cmp	r2, r3
 1404 005c 34BF     		ite	cc
 1405 005e 0023     		movcc	r3, #0
 1406 0060 0123     		movcs	r3, #1
 1407 0062 7B61     		str	r3, [r7, #20]
1015:../FreeRTOS_Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1408              		.loc 1 1015 0
 1409 0064 3B69     		ldr	r3, [r7, #16]
 1410 0066 03F10403 		add	r3, r3, #4
 1411 006a 1846     		mov	r0, r3
 1412 006c FFF7FEFF 		bl	vListRemove
1016:../FreeRTOS_Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1413              		.loc 1 1016 0
 1414 0070 3B69     		ldr	r3, [r7, #16]
 1415 0072 DA6A     		ldr	r2, [r3, #44]
 1416 0074 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1417 0078 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1418 007c 1B68     		ldr	r3, [r3, #0]
 1419 007e 9A42     		cmp	r2, r3
 1420 0080 06D9     		bls	.L76
 1421              		.loc 1 1016 0 is_stmt 0 discriminator 1
 1422 0082 3B69     		ldr	r3, [r7, #16]
 1423 0084 DA6A     		ldr	r2, [r3, #44]
 1424 0086 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1425 008a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1426 008e 1A60     		str	r2, [r3, #0]
 1427              	.L76:
 1428              		.loc 1 1016 0 discriminator 2
 1429 0090 3B69     		ldr	r3, [r7, #16]
 1430 0092 DA6A     		ldr	r2, [r3, #44]
 1431 0094 1346     		mov	r3, r2
 1432 0096 4FEA8303 		lsl	r3, r3, #2
 1433 009a 9B18     		adds	r3, r3, r2
 1434 009c 4FEA8303 		lsl	r3, r3, #2
 1435 00a0 1A46     		mov	r2, r3
 1436 00a2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1437 00a6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1438 00aa D218     		adds	r2, r2, r3
 1439 00ac 3B69     		ldr	r3, [r7, #16]
 1440 00ae 03F10403 		add	r3, r3, #4
 1441 00b2 1046     		mov	r0, r2
 1442 00b4 1946     		mov	r1, r3
 1443 00b6 FFF7FEFF 		bl	vListInsertEnd
 1444 00ba 09E0     		b	.L74
 1445              	.L75:
1017:../FreeRTOS_Source/tasks.c **** 				}
1018:../FreeRTOS_Source/tasks.c **** 				else
1019:../FreeRTOS_Source/tasks.c **** 				{
1020:../FreeRTOS_Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1021:../FreeRTOS_Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1022:../FreeRTOS_Source/tasks.c **** 					yield will be performed if necessary. */
1023:../FreeRTOS_Source/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1446              		.loc 1 1023 0 is_stmt 1
 1447 00bc 3B69     		ldr	r3, [r7, #16]
 1448 00be 03F11803 		add	r3, r3, #24
 1449 00c2 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1450 00c6 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1451 00ca 1946     		mov	r1, r3
 1452 00cc FFF7FEFF 		bl	vListInsertEnd
 1453              	.L74:
1024:../FreeRTOS_Source/tasks.c **** 				}
1025:../FreeRTOS_Source/tasks.c **** 			}
1026:../FreeRTOS_Source/tasks.c **** 		}
1027:../FreeRTOS_Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1454              		.loc 1 1027 0
 1455              	@ 1027 "../FreeRTOS_Source/tasks.c" 1
 1456 00d0 4FF00000 			mov r0, #0					
 1457 00d4 80F31188 		msr basepri, r0				
 1458              	
 1459              	@ 0 "" 2
1028:../FreeRTOS_Source/tasks.c **** 
1029:../FreeRTOS_Source/tasks.c **** 		return xYieldRequired;
 1460              		.loc 1 1029 0
 1461              		.thumb
 1462 00d8 7B69     		ldr	r3, [r7, #20]
1030:../FreeRTOS_Source/tasks.c **** 	}
 1463              		.loc 1 1030 0
 1464 00da 1846     		mov	r0, r3
 1465 00dc 07F11807 		add	r7, r7, #24
 1466 00e0 BD46     		mov	sp, r7
 1467 00e2 80BD     		pop	{r7, pc}
 1468              		.cfi_endproc
 1469              	.LFE9:
 1471              		.section	.rodata
 1472              		.align	2
 1473              	.LC0:
 1474 0000 49444C45 		.ascii	"IDLE\000"
 1474      00
 1475 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1476              		.align	2
 1477              		.global	vTaskStartScheduler
 1478              		.thumb
 1479              		.thumb_func
 1481              	vTaskStartScheduler:
 1482              	.LFB10:
1031:../FreeRTOS_Source/tasks.c **** 
1032:../FreeRTOS_Source/tasks.c **** #endif
1033:../FreeRTOS_Source/tasks.c **** 
1034:../FreeRTOS_Source/tasks.c **** 
1035:../FreeRTOS_Source/tasks.c **** 
1036:../FreeRTOS_Source/tasks.c **** 
1037:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------
1038:../FreeRTOS_Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1039:../FreeRTOS_Source/tasks.c ****  *----------------------------------------------------------*/
1040:../FreeRTOS_Source/tasks.c **** 
1041:../FreeRTOS_Source/tasks.c **** 
1042:../FreeRTOS_Source/tasks.c **** void vTaskStartScheduler( void )
1043:../FreeRTOS_Source/tasks.c **** {
 1483              		.loc 1 1043 0
 1484              		.cfi_startproc
 1485              		@ args = 0, pretend = 0, frame = 8
 1486              		@ frame_needed = 1, uses_anonymous_args = 0
 1487 0000 80B5     		push	{r7, lr}
 1488              	.LCFI30:
 1489              		.cfi_def_cfa_offset 8
 1490              		.cfi_offset 14, -4
 1491              		.cfi_offset 7, -8
 1492 0002 86B0     		sub	sp, sp, #24
 1493              	.LCFI31:
 1494              		.cfi_def_cfa_offset 32
 1495 0004 04AF     		add	r7, sp, #16
 1496              	.LCFI32:
 1497              		.cfi_def_cfa 7, 16
1044:../FreeRTOS_Source/tasks.c **** portBASE_TYPE xReturn;
1045:../FreeRTOS_Source/tasks.c **** 
1046:../FreeRTOS_Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1047:../FreeRTOS_Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:../FreeRTOS_Source/tasks.c **** 	{
1049:../FreeRTOS_Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:../FreeRTOS_Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1051:../FreeRTOS_Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1052:../FreeRTOS_Source/tasks.c **** 	}
1053:../FreeRTOS_Source/tasks.c **** 	#else
1054:../FreeRTOS_Source/tasks.c **** 	{
1055:../FreeRTOS_Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1056:../FreeRTOS_Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1498              		.loc 1 1056 0
 1499 0006 4FF00003 		mov	r3, #0
 1500 000a 0093     		str	r3, [sp, #0]
 1501 000c 4FF00003 		mov	r3, #0
 1502 0010 0193     		str	r3, [sp, #4]
 1503 0012 4FF00003 		mov	r3, #0
 1504 0016 0293     		str	r3, [sp, #8]
 1505 0018 4FF00003 		mov	r3, #0
 1506 001c 0393     		str	r3, [sp, #12]
 1507 001e 40F20000 		movw	r0, #:lower16:prvIdleTask
 1508 0022 C0F20000 		movt	r0, #:upper16:prvIdleTask
 1509 0026 40F20001 		movw	r1, #:lower16:.LC0
 1510 002a C0F20001 		movt	r1, #:upper16:.LC0
 1511 002e 4FF04602 		mov	r2, #70
 1512 0032 4FF00003 		mov	r3, #0
 1513 0036 FFF7FEFF 		bl	xTaskGenericCreate
 1514 003a 7860     		str	r0, [r7, #4]
1057:../FreeRTOS_Source/tasks.c **** 	}
1058:../FreeRTOS_Source/tasks.c **** 	#endif
1059:../FreeRTOS_Source/tasks.c **** 
1060:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1061:../FreeRTOS_Source/tasks.c **** 	{
1062:../FreeRTOS_Source/tasks.c **** 		if( xReturn == pdPASS )
 1515              		.loc 1 1062 0
 1516 003c 7B68     		ldr	r3, [r7, #4]
 1517 003e 012B     		cmp	r3, #1
 1518 0040 02D1     		bne	.L78
1063:../FreeRTOS_Source/tasks.c **** 		{
1064:../FreeRTOS_Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1519              		.loc 1 1064 0
 1520 0042 FFF7FEFF 		bl	xTimerCreateTimerTask
 1521 0046 7860     		str	r0, [r7, #4]
 1522              	.L78:
1065:../FreeRTOS_Source/tasks.c **** 		}
1066:../FreeRTOS_Source/tasks.c **** 	}
1067:../FreeRTOS_Source/tasks.c **** 	#endif
1068:../FreeRTOS_Source/tasks.c **** 
1069:../FreeRTOS_Source/tasks.c **** 	if( xReturn == pdPASS )
 1523              		.loc 1 1069 0
 1524 0048 7B68     		ldr	r3, [r7, #4]
 1525 004a 012B     		cmp	r3, #1
 1526 004c 13D1     		bne	.L79
1070:../FreeRTOS_Source/tasks.c **** 	{
1071:../FreeRTOS_Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1072:../FreeRTOS_Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1073:../FreeRTOS_Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1074:../FreeRTOS_Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1075:../FreeRTOS_Source/tasks.c **** 		starts to run.
1076:../FreeRTOS_Source/tasks.c **** 
1077:../FreeRTOS_Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:../FreeRTOS_Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:../FreeRTOS_Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1527              		.loc 1 1079 0
 1528              	@ 1079 "../FreeRTOS_Source/tasks.c" 1
 1529 004e 4FF05000 			mov r0, #80								
 1530 0052 80F31188 		msr basepri, r0							
 1531              	
 1532              	@ 0 "" 2
1080:../FreeRTOS_Source/tasks.c **** 
1081:../FreeRTOS_Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1533              		.loc 1 1081 0
 1534              		.thumb
 1535 0056 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1536 005a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1537 005e 4FF00102 		mov	r2, #1
 1538 0062 1A60     		str	r2, [r3, #0]
1082:../FreeRTOS_Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1539              		.loc 1 1082 0
 1540 0064 40F20003 		movw	r3, #:lower16:xTickCount
 1541 0068 C0F20003 		movt	r3, #:upper16:xTickCount
 1542 006c 4FF00002 		mov	r2, #0
 1543 0070 1A60     		str	r2, [r3, #0]
1083:../FreeRTOS_Source/tasks.c **** 
1084:../FreeRTOS_Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:../FreeRTOS_Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1086:../FreeRTOS_Source/tasks.c **** 		the run time counter time base. */
1087:../FreeRTOS_Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1088:../FreeRTOS_Source/tasks.c **** 		
1089:../FreeRTOS_Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1090:../FreeRTOS_Source/tasks.c **** 		portable interface. */
1091:../FreeRTOS_Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1544              		.loc 1 1091 0
 1545 0072 FFF7FEFF 		bl	xPortStartScheduler
 1546              	.L79:
1092:../FreeRTOS_Source/tasks.c **** 		{
1093:../FreeRTOS_Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1094:../FreeRTOS_Source/tasks.c **** 			function will not return. */
1095:../FreeRTOS_Source/tasks.c **** 		}
1096:../FreeRTOS_Source/tasks.c **** 		else
1097:../FreeRTOS_Source/tasks.c **** 		{
1098:../FreeRTOS_Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:../FreeRTOS_Source/tasks.c **** 		}
1100:../FreeRTOS_Source/tasks.c **** 	}
1101:../FreeRTOS_Source/tasks.c **** 
1102:../FreeRTOS_Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1103:../FreeRTOS_Source/tasks.c **** 	configASSERT( xReturn );
 1547              		.loc 1 1103 0
 1548 0076 7B68     		ldr	r3, [r7, #4]
 1549 0078 002B     		cmp	r3, #0
 1550 007a 04D1     		bne	.L77
 1551              		.loc 1 1103 0 is_stmt 0 discriminator 1
 1552              	@ 1103 "../FreeRTOS_Source/tasks.c" 1
 1553 007c 4FF05000 			mov r0, #80								
 1554 0080 80F31188 		msr basepri, r0							
 1555              	
 1556              	@ 0 "" 2
 1557              		.thumb
 1558              	.L81:
 1559              		.loc 1 1103 0 discriminator 2
 1560 0084 FEE7     		b	.L81
 1561              	.L77:
1104:../FreeRTOS_Source/tasks.c **** }
 1562              		.loc 1 1104 0 is_stmt 1
 1563 0086 07F10807 		add	r7, r7, #8
 1564 008a BD46     		mov	sp, r7
 1565 008c 80BD     		pop	{r7, pc}
 1566              		.cfi_endproc
 1567              	.LFE10:
 1569 008e 00BF     		.section	.text.vTaskEndScheduler,"ax",%progbits
 1570              		.align	2
 1571              		.global	vTaskEndScheduler
 1572              		.thumb
 1573              		.thumb_func
 1575              	vTaskEndScheduler:
 1576              	.LFB11:
1105:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1106:../FreeRTOS_Source/tasks.c **** 
1107:../FreeRTOS_Source/tasks.c **** void vTaskEndScheduler( void )
1108:../FreeRTOS_Source/tasks.c **** {
 1577              		.loc 1 1108 0
 1578              		.cfi_startproc
 1579              		@ args = 0, pretend = 0, frame = 0
 1580              		@ frame_needed = 1, uses_anonymous_args = 0
 1581 0000 80B5     		push	{r7, lr}
 1582              	.LCFI33:
 1583              		.cfi_def_cfa_offset 8
 1584              		.cfi_offset 14, -4
 1585              		.cfi_offset 7, -8
 1586 0002 00AF     		add	r7, sp, #0
 1587              	.LCFI34:
 1588              		.cfi_def_cfa_register 7
1109:../FreeRTOS_Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1110:../FreeRTOS_Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1111:../FreeRTOS_Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1112:../FreeRTOS_Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1589              		.loc 1 1112 0
 1590              	@ 1112 "../FreeRTOS_Source/tasks.c" 1
 1591 0004 4FF05000 			mov r0, #80								
 1592 0008 80F31188 		msr basepri, r0							
 1593              	
 1594              	@ 0 "" 2
1113:../FreeRTOS_Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1595              		.loc 1 1113 0
 1596              		.thumb
 1597 000c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1598 0010 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1599 0014 4FF00002 		mov	r2, #0
 1600 0018 1A60     		str	r2, [r3, #0]
1114:../FreeRTOS_Source/tasks.c **** 	vPortEndScheduler();
 1601              		.loc 1 1114 0
 1602 001a FFF7FEFF 		bl	vPortEndScheduler
1115:../FreeRTOS_Source/tasks.c **** }
 1603              		.loc 1 1115 0
 1604 001e 80BD     		pop	{r7, pc}
 1605              		.cfi_endproc
 1606              	.LFE11:
 1608              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1609              		.align	2
 1610              		.global	vTaskSuspendAll
 1611              		.thumb
 1612              		.thumb_func
 1614              	vTaskSuspendAll:
 1615              	.LFB12:
1116:../FreeRTOS_Source/tasks.c **** /*----------------------------------------------------------*/
1117:../FreeRTOS_Source/tasks.c **** 
1118:../FreeRTOS_Source/tasks.c **** void vTaskSuspendAll( void )
1119:../FreeRTOS_Source/tasks.c **** {
 1616              		.loc 1 1119 0
 1617              		.cfi_startproc
 1618              		@ args = 0, pretend = 0, frame = 0
 1619              		@ frame_needed = 1, uses_anonymous_args = 0
 1620              		@ link register save eliminated.
 1621 0000 80B4     		push	{r7}
 1622              	.LCFI35:
 1623              		.cfi_def_cfa_offset 4
 1624              		.cfi_offset 7, -4
 1625 0002 00AF     		add	r7, sp, #0
 1626              	.LCFI36:
 1627              		.cfi_def_cfa_register 7
1120:../FreeRTOS_Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1121:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE. */
1122:../FreeRTOS_Source/tasks.c **** 	++uxSchedulerSuspended;
 1628              		.loc 1 1122 0
 1629 0004 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1630 0008 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1631 000c 1B68     		ldr	r3, [r3, #0]
 1632 000e 03F10102 		add	r2, r3, #1
 1633 0012 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1634 0016 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1635 001a 1A60     		str	r2, [r3, #0]
1123:../FreeRTOS_Source/tasks.c **** }
 1636              		.loc 1 1123 0
 1637 001c BD46     		mov	sp, r7
 1638 001e 80BC     		pop	{r7}
 1639 0020 7047     		bx	lr
 1640              		.cfi_endproc
 1641              	.LFE12:
 1643 0022 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1644              		.align	2
 1645              		.global	xTaskResumeAll
 1646              		.thumb
 1647              		.thumb_func
 1649              	xTaskResumeAll:
 1650              	.LFB13:
1124:../FreeRTOS_Source/tasks.c **** /*----------------------------------------------------------*/
1125:../FreeRTOS_Source/tasks.c **** 
1126:../FreeRTOS_Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1127:../FreeRTOS_Source/tasks.c **** {
 1651              		.loc 1 1127 0
 1652              		.cfi_startproc
 1653              		@ args = 0, pretend = 0, frame = 8
 1654              		@ frame_needed = 1, uses_anonymous_args = 0
 1655 0000 90B5     		push	{r4, r7, lr}
 1656              	.LCFI37:
 1657              		.cfi_def_cfa_offset 12
 1658              		.cfi_offset 14, -4
 1659              		.cfi_offset 7, -8
 1660              		.cfi_offset 4, -12
 1661 0002 83B0     		sub	sp, sp, #12
 1662              	.LCFI38:
 1663              		.cfi_def_cfa_offset 24
 1664 0004 00AF     		add	r7, sp, #0
 1665              	.LCFI39:
 1666              		.cfi_def_cfa_register 7
1128:../FreeRTOS_Source/tasks.c **** register tskTCB *pxTCB;
1129:../FreeRTOS_Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1667              		.loc 1 1129 0
 1668 0006 4FF00003 		mov	r3, #0
 1669 000a 7B60     		str	r3, [r7, #4]
1130:../FreeRTOS_Source/tasks.c **** 
1131:../FreeRTOS_Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1132:../FreeRTOS_Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1133:../FreeRTOS_Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1670              		.loc 1 1133 0
 1671 000c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1672 0010 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1673 0014 1B68     		ldr	r3, [r3, #0]
 1674 0016 002B     		cmp	r3, #0
 1675 0018 04D1     		bne	.L85
 1676              		.loc 1 1133 0 is_stmt 0 discriminator 1
 1677              	@ 1133 "../FreeRTOS_Source/tasks.c" 1
 1678 001a 4FF05000 			mov r0, #80								
 1679 001e 80F31188 		msr basepri, r0							
 1680              	
 1681              	@ 0 "" 2
 1682              		.thumb
 1683              	.L86:
 1684              		.loc 1 1133 0 discriminator 2
 1685 0022 FEE7     		b	.L86
 1686              	.L85:
1134:../FreeRTOS_Source/tasks.c **** 
1135:../FreeRTOS_Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1136:../FreeRTOS_Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1137:../FreeRTOS_Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1138:../FreeRTOS_Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1139:../FreeRTOS_Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1140:../FreeRTOS_Source/tasks.c **** 	taskENTER_CRITICAL();
 1687              		.loc 1 1140 0 is_stmt 1
 1688 0024 FFF7FEFF 		bl	vPortEnterCritical
1141:../FreeRTOS_Source/tasks.c **** 	{
1142:../FreeRTOS_Source/tasks.c **** 		--uxSchedulerSuspended;
 1689              		.loc 1 1142 0
 1690 0028 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1691 002c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1692 0030 1B68     		ldr	r3, [r3, #0]
 1693 0032 03F1FF32 		add	r2, r3, #-1
 1694 0036 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1695 003a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1696 003e 1A60     		str	r2, [r3, #0]
1143:../FreeRTOS_Source/tasks.c **** 
1144:../FreeRTOS_Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1697              		.loc 1 1144 0
 1698 0040 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1699 0044 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1700 0048 1B68     		ldr	r3, [r3, #0]
 1701 004a 002B     		cmp	r3, #0
 1702 004c 40F08580 		bne	.L87
1145:../FreeRTOS_Source/tasks.c **** 		{
1146:../FreeRTOS_Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1703              		.loc 1 1146 0
 1704 0050 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1705 0054 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1706 0058 1B68     		ldr	r3, [r3, #0]
 1707 005a 002B     		cmp	r3, #0
 1708 005c 7DD0     		beq	.L87
 1709              	.LBB3:
1147:../FreeRTOS_Source/tasks.c **** 			{
1148:../FreeRTOS_Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1710              		.loc 1 1148 0
 1711 005e 4FF00003 		mov	r3, #0
 1712 0062 3B60     		str	r3, [r7, #0]
1149:../FreeRTOS_Source/tasks.c **** 
1150:../FreeRTOS_Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1151:../FreeRTOS_Source/tasks.c **** 				appropriate ready list. */
1152:../FreeRTOS_Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1713              		.loc 1 1152 0
 1714 0064 3CE0     		b	.L88
 1715              	.L90:
1153:../FreeRTOS_Source/tasks.c **** 				{
1154:../FreeRTOS_Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1716              		.loc 1 1154 0
 1717 0066 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1718 006a C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1719 006e DB68     		ldr	r3, [r3, #12]
 1720 0070 DC68     		ldr	r4, [r3, #12]
1155:../FreeRTOS_Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1721              		.loc 1 1155 0
 1722 0072 04F11803 		add	r3, r4, #24
 1723 0076 1846     		mov	r0, r3
 1724 0078 FFF7FEFF 		bl	vListRemove
1156:../FreeRTOS_Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1725              		.loc 1 1156 0
 1726 007c 04F10403 		add	r3, r4, #4
 1727 0080 1846     		mov	r0, r3
 1728 0082 FFF7FEFF 		bl	vListRemove
1157:../FreeRTOS_Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1729              		.loc 1 1157 0
 1730 0086 E26A     		ldr	r2, [r4, #44]
 1731 0088 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1732 008c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1733 0090 1B68     		ldr	r3, [r3, #0]
 1734 0092 9A42     		cmp	r2, r3
 1735 0094 05D9     		bls	.L89
 1736              		.loc 1 1157 0 is_stmt 0 discriminator 1
 1737 0096 E26A     		ldr	r2, [r4, #44]
 1738 0098 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1739 009c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1740 00a0 1A60     		str	r2, [r3, #0]
 1741              	.L89:
 1742              		.loc 1 1157 0 discriminator 2
 1743 00a2 E26A     		ldr	r2, [r4, #44]
 1744 00a4 1346     		mov	r3, r2
 1745 00a6 4FEA8303 		lsl	r3, r3, #2
 1746 00aa 9B18     		adds	r3, r3, r2
 1747 00ac 4FEA8303 		lsl	r3, r3, #2
 1748 00b0 1A46     		mov	r2, r3
 1749 00b2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 1750 00b6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 1751 00ba D218     		adds	r2, r2, r3
 1752 00bc 04F10403 		add	r3, r4, #4
 1753 00c0 1046     		mov	r0, r2
 1754 00c2 1946     		mov	r1, r3
 1755 00c4 FFF7FEFF 		bl	vListInsertEnd
1158:../FreeRTOS_Source/tasks.c **** 
1159:../FreeRTOS_Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1160:../FreeRTOS_Source/tasks.c **** 					the current task then we should yield. */
1161:../FreeRTOS_Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1756              		.loc 1 1161 0 is_stmt 1 discriminator 2
 1757 00c8 E26A     		ldr	r2, [r4, #44]
 1758 00ca 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1759 00ce C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1760 00d2 1B68     		ldr	r3, [r3, #0]
 1761 00d4 DB6A     		ldr	r3, [r3, #44]
 1762 00d6 9A42     		cmp	r2, r3
 1763 00d8 02D3     		bcc	.L88
1162:../FreeRTOS_Source/tasks.c **** 					{
1163:../FreeRTOS_Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1764              		.loc 1 1163 0
 1765 00da 4FF00103 		mov	r3, #1
 1766 00de 3B60     		str	r3, [r7, #0]
 1767              	.L88:
1152:../FreeRTOS_Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1768              		.loc 1 1152 0 discriminator 1
 1769 00e0 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1770 00e4 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1771 00e8 1B68     		ldr	r3, [r3, #0]
 1772 00ea 002B     		cmp	r3, #0
 1773 00ec BBD1     		bne	.L90
1164:../FreeRTOS_Source/tasks.c **** 					}
1165:../FreeRTOS_Source/tasks.c **** 				}
1166:../FreeRTOS_Source/tasks.c **** 
1167:../FreeRTOS_Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1168:../FreeRTOS_Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1169:../FreeRTOS_Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1170:../FreeRTOS_Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1774              		.loc 1 1170 0
 1775 00ee 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1776 00f2 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1777 00f6 1B68     		ldr	r3, [r3, #0]
 1778 00f8 002B     		cmp	r3, #0
 1779 00fa 18D0     		beq	.L91
1171:../FreeRTOS_Source/tasks.c **** 				{
1172:../FreeRTOS_Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1780              		.loc 1 1172 0
 1781 00fc 0DE0     		b	.L92
 1782              	.L93:
1173:../FreeRTOS_Source/tasks.c **** 					{
1174:../FreeRTOS_Source/tasks.c **** 						vTaskIncrementTick();
 1783              		.loc 1 1174 0
 1784 00fe FFF7FEFF 		bl	vTaskIncrementTick
1175:../FreeRTOS_Source/tasks.c **** 						--uxMissedTicks;
 1785              		.loc 1 1175 0
 1786 0102 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1787 0106 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1788 010a 1B68     		ldr	r3, [r3, #0]
 1789 010c 03F1FF32 		add	r2, r3, #-1
 1790 0110 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1791 0114 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1792 0118 1A60     		str	r2, [r3, #0]
 1793              	.L92:
1172:../FreeRTOS_Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1794              		.loc 1 1172 0 discriminator 1
 1795 011a 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1796 011e C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1797 0122 1B68     		ldr	r3, [r3, #0]
 1798 0124 002B     		cmp	r3, #0
 1799 0126 EAD1     		bne	.L93
1176:../FreeRTOS_Source/tasks.c **** 					}
1177:../FreeRTOS_Source/tasks.c **** 
1178:../FreeRTOS_Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1179:../FreeRTOS_Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1180:../FreeRTOS_Source/tasks.c **** 					the task actually running. */
1181:../FreeRTOS_Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1182:../FreeRTOS_Source/tasks.c **** 					{
1183:../FreeRTOS_Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1800              		.loc 1 1183 0
 1801 0128 4FF00103 		mov	r3, #1
 1802 012c 3B60     		str	r3, [r7, #0]
 1803              	.L91:
1184:../FreeRTOS_Source/tasks.c **** 					}
1185:../FreeRTOS_Source/tasks.c **** 					#endif
1186:../FreeRTOS_Source/tasks.c **** 				}
1187:../FreeRTOS_Source/tasks.c **** 
1188:../FreeRTOS_Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1804              		.loc 1 1188 0
 1805 012e 3B68     		ldr	r3, [r7, #0]
 1806 0130 012B     		cmp	r3, #1
 1807 0132 06D0     		beq	.L94
 1808              		.loc 1 1188 0 is_stmt 0 discriminator 1
 1809 0134 40F20003 		movw	r3, #:lower16:xMissedYield
 1810 0138 C0F20003 		movt	r3, #:upper16:xMissedYield
 1811 013c 1B68     		ldr	r3, [r3, #0]
 1812 013e 012B     		cmp	r3, #1
 1813 0140 0BD1     		bne	.L87
 1814              	.L94:
1189:../FreeRTOS_Source/tasks.c **** 				{
1190:../FreeRTOS_Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1815              		.loc 1 1190 0 is_stmt 1
 1816 0142 4FF00103 		mov	r3, #1
 1817 0146 7B60     		str	r3, [r7, #4]
1191:../FreeRTOS_Source/tasks.c **** 					xMissedYield = pdFALSE;
 1818              		.loc 1 1191 0
 1819 0148 40F20003 		movw	r3, #:lower16:xMissedYield
 1820 014c C0F20003 		movt	r3, #:upper16:xMissedYield
 1821 0150 4FF00002 		mov	r2, #0
 1822 0154 1A60     		str	r2, [r3, #0]
1192:../FreeRTOS_Source/tasks.c **** 					portYIELD_WITHIN_API();
 1823              		.loc 1 1192 0
 1824 0156 FFF7FEFF 		bl	vPortYieldFromISR
 1825              	.L87:
 1826              	.LBE3:
1193:../FreeRTOS_Source/tasks.c **** 				}
1194:../FreeRTOS_Source/tasks.c **** 			}
1195:../FreeRTOS_Source/tasks.c **** 		}
1196:../FreeRTOS_Source/tasks.c **** 	}
1197:../FreeRTOS_Source/tasks.c **** 	taskEXIT_CRITICAL();
 1827              		.loc 1 1197 0
 1828 015a FFF7FEFF 		bl	vPortExitCritical
1198:../FreeRTOS_Source/tasks.c **** 
1199:../FreeRTOS_Source/tasks.c **** 	return xAlreadyYielded;
 1829              		.loc 1 1199 0
 1830 015e 7B68     		ldr	r3, [r7, #4]
1200:../FreeRTOS_Source/tasks.c **** }
 1831              		.loc 1 1200 0
 1832 0160 1846     		mov	r0, r3
 1833 0162 07F10C07 		add	r7, r7, #12
 1834 0166 BD46     		mov	sp, r7
 1835 0168 90BD     		pop	{r4, r7, pc}
 1836              		.cfi_endproc
 1837              	.LFE13:
 1839 016a 00BF     		.section	.text.xTaskGetTickCount,"ax",%progbits
 1840              		.align	2
 1841              		.global	xTaskGetTickCount
 1842              		.thumb
 1843              		.thumb_func
 1845              	xTaskGetTickCount:
 1846              	.LFB14:
1201:../FreeRTOS_Source/tasks.c **** 
1202:../FreeRTOS_Source/tasks.c **** 
1203:../FreeRTOS_Source/tasks.c **** 
1204:../FreeRTOS_Source/tasks.c **** 
1205:../FreeRTOS_Source/tasks.c **** 
1206:../FreeRTOS_Source/tasks.c **** 
1207:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------
1208:../FreeRTOS_Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1209:../FreeRTOS_Source/tasks.c ****  *----------------------------------------------------------*/
1210:../FreeRTOS_Source/tasks.c **** 
1211:../FreeRTOS_Source/tasks.c **** 
1212:../FreeRTOS_Source/tasks.c **** 
1213:../FreeRTOS_Source/tasks.c **** portTickType xTaskGetTickCount( void )
1214:../FreeRTOS_Source/tasks.c **** {
 1847              		.loc 1 1214 0
 1848              		.cfi_startproc
 1849              		@ args = 0, pretend = 0, frame = 8
 1850              		@ frame_needed = 1, uses_anonymous_args = 0
 1851 0000 80B5     		push	{r7, lr}
 1852              	.LCFI40:
 1853              		.cfi_def_cfa_offset 8
 1854              		.cfi_offset 14, -4
 1855              		.cfi_offset 7, -8
 1856 0002 82B0     		sub	sp, sp, #8
 1857              	.LCFI41:
 1858              		.cfi_def_cfa_offset 16
 1859 0004 00AF     		add	r7, sp, #0
 1860              	.LCFI42:
 1861              		.cfi_def_cfa_register 7
1215:../FreeRTOS_Source/tasks.c **** portTickType xTicks;
1216:../FreeRTOS_Source/tasks.c **** 
1217:../FreeRTOS_Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1218:../FreeRTOS_Source/tasks.c **** 	taskENTER_CRITICAL();
 1862              		.loc 1 1218 0
 1863 0006 FFF7FEFF 		bl	vPortEnterCritical
1219:../FreeRTOS_Source/tasks.c **** 	{
1220:../FreeRTOS_Source/tasks.c **** 		xTicks = xTickCount;
 1864              		.loc 1 1220 0
 1865 000a 40F20003 		movw	r3, #:lower16:xTickCount
 1866 000e C0F20003 		movt	r3, #:upper16:xTickCount
 1867 0012 1B68     		ldr	r3, [r3, #0]
 1868 0014 7B60     		str	r3, [r7, #4]
1221:../FreeRTOS_Source/tasks.c **** 	}
1222:../FreeRTOS_Source/tasks.c **** 	taskEXIT_CRITICAL();
 1869              		.loc 1 1222 0
 1870 0016 FFF7FEFF 		bl	vPortExitCritical
1223:../FreeRTOS_Source/tasks.c **** 
1224:../FreeRTOS_Source/tasks.c **** 	return xTicks;
 1871              		.loc 1 1224 0
 1872 001a 7B68     		ldr	r3, [r7, #4]
1225:../FreeRTOS_Source/tasks.c **** }
 1873              		.loc 1 1225 0
 1874 001c 1846     		mov	r0, r3
 1875 001e 07F10807 		add	r7, r7, #8
 1876 0022 BD46     		mov	sp, r7
 1877 0024 80BD     		pop	{r7, pc}
 1878              		.cfi_endproc
 1879              	.LFE14:
 1881 0026 00BF     		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1882              		.align	2
 1883              		.global	xTaskGetTickCountFromISR
 1884              		.thumb
 1885              		.thumb_func
 1887              	xTaskGetTickCountFromISR:
 1888              	.LFB15:
1226:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1227:../FreeRTOS_Source/tasks.c **** 
1228:../FreeRTOS_Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1229:../FreeRTOS_Source/tasks.c **** {
 1889              		.loc 1 1229 0
 1890              		.cfi_startproc
 1891              		@ args = 0, pretend = 0, frame = 8
 1892              		@ frame_needed = 1, uses_anonymous_args = 0
 1893              		@ link register save eliminated.
 1894 0000 80B4     		push	{r7}
 1895              	.LCFI43:
 1896              		.cfi_def_cfa_offset 4
 1897              		.cfi_offset 7, -4
 1898 0002 83B0     		sub	sp, sp, #12
 1899              	.LCFI44:
 1900              		.cfi_def_cfa_offset 16
 1901 0004 00AF     		add	r7, sp, #0
 1902              	.LCFI45:
 1903              		.cfi_def_cfa_register 7
1230:../FreeRTOS_Source/tasks.c **** portTickType xReturn;
1231:../FreeRTOS_Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:../FreeRTOS_Source/tasks.c **** 
1233:../FreeRTOS_Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1904              		.loc 1 1233 0
 1905 0006 4FF00003 		mov	r3, #0
 1906 000a 7B60     		str	r3, [r7, #4]
 1907              	@ 1233 "../FreeRTOS_Source/tasks.c" 1
 1908 000c 4FF05000 			mov r0, #80								
 1909 0010 80F31188 		msr basepri, r0							
 1910              	
 1911              	@ 0 "" 2
1234:../FreeRTOS_Source/tasks.c **** 	xReturn = xTickCount;
 1912              		.loc 1 1234 0
 1913              		.thumb
 1914 0014 40F20003 		movw	r3, #:lower16:xTickCount
 1915 0018 C0F20003 		movt	r3, #:upper16:xTickCount
 1916 001c 1B68     		ldr	r3, [r3, #0]
 1917 001e 3B60     		str	r3, [r7, #0]
1235:../FreeRTOS_Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1918              		.loc 1 1235 0
 1919              	@ 1235 "../FreeRTOS_Source/tasks.c" 1
 1920 0020 4FF00000 			mov r0, #0					
 1921 0024 80F31188 		msr basepri, r0				
 1922              	
 1923              	@ 0 "" 2
1236:../FreeRTOS_Source/tasks.c **** 
1237:../FreeRTOS_Source/tasks.c **** 	return xReturn;
 1924              		.loc 1 1237 0
 1925              		.thumb
 1926 0028 3B68     		ldr	r3, [r7, #0]
1238:../FreeRTOS_Source/tasks.c **** }
 1927              		.loc 1 1238 0
 1928 002a 1846     		mov	r0, r3
 1929 002c 07F10C07 		add	r7, r7, #12
 1930 0030 BD46     		mov	sp, r7
 1931 0032 80BC     		pop	{r7}
 1932 0034 7047     		bx	lr
 1933              		.cfi_endproc
 1934              	.LFE15:
 1936 0036 00BF     		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1937              		.align	2
 1938              		.global	uxTaskGetNumberOfTasks
 1939              		.thumb
 1940              		.thumb_func
 1942              	uxTaskGetNumberOfTasks:
 1943              	.LFB16:
1239:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1240:../FreeRTOS_Source/tasks.c **** 
1241:../FreeRTOS_Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:../FreeRTOS_Source/tasks.c **** {
 1944              		.loc 1 1242 0
 1945              		.cfi_startproc
 1946              		@ args = 0, pretend = 0, frame = 0
 1947              		@ frame_needed = 1, uses_anonymous_args = 0
 1948              		@ link register save eliminated.
 1949 0000 80B4     		push	{r7}
 1950              	.LCFI46:
 1951              		.cfi_def_cfa_offset 4
 1952              		.cfi_offset 7, -4
 1953 0002 00AF     		add	r7, sp, #0
 1954              	.LCFI47:
 1955              		.cfi_def_cfa_register 7
1243:../FreeRTOS_Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1244:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE. */
1245:../FreeRTOS_Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1956              		.loc 1 1245 0
 1957 0004 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1958 0008 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1959 000c 1B68     		ldr	r3, [r3, #0]
1246:../FreeRTOS_Source/tasks.c **** }
 1960              		.loc 1 1246 0
 1961 000e 1846     		mov	r0, r3
 1962 0010 BD46     		mov	sp, r7
 1963 0012 80BC     		pop	{r7}
 1964 0014 7047     		bx	lr
 1965              		.cfi_endproc
 1966              	.LFE16:
 1968 0016 00BF     		.section	.text.vTaskIncrementTick,"ax",%progbits
 1969              		.align	2
 1970              		.global	vTaskIncrementTick
 1971              		.thumb
 1972              		.thumb_func
 1974              	vTaskIncrementTick:
 1975              	.LFB17:
1247:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1248:../FreeRTOS_Source/tasks.c **** 
1249:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:../FreeRTOS_Source/tasks.c **** 
1251:../FreeRTOS_Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:../FreeRTOS_Source/tasks.c **** 	{
1253:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
1254:../FreeRTOS_Source/tasks.c **** 
1255:../FreeRTOS_Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1256:../FreeRTOS_Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:../FreeRTOS_Source/tasks.c **** 		configASSERT( pxTCB );
1258:../FreeRTOS_Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1259:../FreeRTOS_Source/tasks.c **** 	}
1260:../FreeRTOS_Source/tasks.c **** 
1261:../FreeRTOS_Source/tasks.c **** #endif
1262:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1263:../FreeRTOS_Source/tasks.c **** 
1264:../FreeRTOS_Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1265:../FreeRTOS_Source/tasks.c **** 
1266:../FreeRTOS_Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1267:../FreeRTOS_Source/tasks.c **** 	{
1268:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1269:../FreeRTOS_Source/tasks.c **** 
1270:../FreeRTOS_Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1271:../FreeRTOS_Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1272:../FreeRTOS_Source/tasks.c **** 
1273:../FreeRTOS_Source/tasks.c **** 		vTaskSuspendAll();
1274:../FreeRTOS_Source/tasks.c **** 		{
1275:../FreeRTOS_Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1276:../FreeRTOS_Source/tasks.c **** 			report the task name, state and stack high water mark. */
1277:../FreeRTOS_Source/tasks.c **** 
1278:../FreeRTOS_Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1279:../FreeRTOS_Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1280:../FreeRTOS_Source/tasks.c **** 
1281:../FreeRTOS_Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1282:../FreeRTOS_Source/tasks.c **** 
1283:../FreeRTOS_Source/tasks.c **** 			do
1284:../FreeRTOS_Source/tasks.c **** 			{
1285:../FreeRTOS_Source/tasks.c **** 				uxQueue--;
1286:../FreeRTOS_Source/tasks.c **** 
1287:../FreeRTOS_Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1288:../FreeRTOS_Source/tasks.c **** 				{
1289:../FreeRTOS_Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1290:../FreeRTOS_Source/tasks.c **** 				}
1291:../FreeRTOS_Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1292:../FreeRTOS_Source/tasks.c **** 
1293:../FreeRTOS_Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1294:../FreeRTOS_Source/tasks.c **** 			{
1295:../FreeRTOS_Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1296:../FreeRTOS_Source/tasks.c **** 			}
1297:../FreeRTOS_Source/tasks.c **** 
1298:../FreeRTOS_Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1299:../FreeRTOS_Source/tasks.c **** 			{
1300:../FreeRTOS_Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1301:../FreeRTOS_Source/tasks.c **** 			}
1302:../FreeRTOS_Source/tasks.c **** 
1303:../FreeRTOS_Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1304:../FreeRTOS_Source/tasks.c **** 			{
1305:../FreeRTOS_Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1306:../FreeRTOS_Source/tasks.c **** 				{
1307:../FreeRTOS_Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1308:../FreeRTOS_Source/tasks.c **** 				}
1309:../FreeRTOS_Source/tasks.c **** 			}
1310:../FreeRTOS_Source/tasks.c **** 			#endif
1311:../FreeRTOS_Source/tasks.c **** 
1312:../FreeRTOS_Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1313:../FreeRTOS_Source/tasks.c **** 			{
1314:../FreeRTOS_Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1315:../FreeRTOS_Source/tasks.c **** 				{
1316:../FreeRTOS_Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1317:../FreeRTOS_Source/tasks.c **** 				}
1318:../FreeRTOS_Source/tasks.c **** 			}
1319:../FreeRTOS_Source/tasks.c **** 			#endif
1320:../FreeRTOS_Source/tasks.c **** 		}
1321:../FreeRTOS_Source/tasks.c **** 		xTaskResumeAll();
1322:../FreeRTOS_Source/tasks.c **** 	}
1323:../FreeRTOS_Source/tasks.c **** 
1324:../FreeRTOS_Source/tasks.c **** #endif
1325:../FreeRTOS_Source/tasks.c **** /*----------------------------------------------------------*/
1326:../FreeRTOS_Source/tasks.c **** 
1327:../FreeRTOS_Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:../FreeRTOS_Source/tasks.c **** 
1329:../FreeRTOS_Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:../FreeRTOS_Source/tasks.c **** 	{
1331:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1332:../FreeRTOS_Source/tasks.c **** 	unsigned long ulTotalRunTime;
1333:../FreeRTOS_Source/tasks.c **** 
1334:../FreeRTOS_Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1335:../FreeRTOS_Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1336:../FreeRTOS_Source/tasks.c **** 
1337:../FreeRTOS_Source/tasks.c **** 		vTaskSuspendAll();
1338:../FreeRTOS_Source/tasks.c **** 		{
1339:../FreeRTOS_Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:../FreeRTOS_Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:../FreeRTOS_Source/tasks.c **** 			#else
1342:../FreeRTOS_Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1343:../FreeRTOS_Source/tasks.c **** 			#endif
1344:../FreeRTOS_Source/tasks.c **** 
1345:../FreeRTOS_Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:../FreeRTOS_Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:../FreeRTOS_Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1348:../FreeRTOS_Source/tasks.c **** 			
1349:../FreeRTOS_Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1350:../FreeRTOS_Source/tasks.c **** 			generating a table of run timer percentages in the provided
1351:../FreeRTOS_Source/tasks.c **** 			buffer. */
1352:../FreeRTOS_Source/tasks.c **** 
1353:../FreeRTOS_Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1354:../FreeRTOS_Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1355:../FreeRTOS_Source/tasks.c **** 
1356:../FreeRTOS_Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1357:../FreeRTOS_Source/tasks.c **** 
1358:../FreeRTOS_Source/tasks.c **** 			do
1359:../FreeRTOS_Source/tasks.c **** 			{
1360:../FreeRTOS_Source/tasks.c **** 				uxQueue--;
1361:../FreeRTOS_Source/tasks.c **** 
1362:../FreeRTOS_Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1363:../FreeRTOS_Source/tasks.c **** 				{
1364:../FreeRTOS_Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1365:../FreeRTOS_Source/tasks.c **** 				}
1366:../FreeRTOS_Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1367:../FreeRTOS_Source/tasks.c **** 
1368:../FreeRTOS_Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1369:../FreeRTOS_Source/tasks.c **** 			{
1370:../FreeRTOS_Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1371:../FreeRTOS_Source/tasks.c **** 			}
1372:../FreeRTOS_Source/tasks.c **** 
1373:../FreeRTOS_Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1374:../FreeRTOS_Source/tasks.c **** 			{
1375:../FreeRTOS_Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1376:../FreeRTOS_Source/tasks.c **** 			}
1377:../FreeRTOS_Source/tasks.c **** 
1378:../FreeRTOS_Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:../FreeRTOS_Source/tasks.c **** 			{
1380:../FreeRTOS_Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1381:../FreeRTOS_Source/tasks.c **** 				{
1382:../FreeRTOS_Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1383:../FreeRTOS_Source/tasks.c **** 				}
1384:../FreeRTOS_Source/tasks.c **** 			}
1385:../FreeRTOS_Source/tasks.c **** 			#endif
1386:../FreeRTOS_Source/tasks.c **** 
1387:../FreeRTOS_Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1388:../FreeRTOS_Source/tasks.c **** 			{
1389:../FreeRTOS_Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1390:../FreeRTOS_Source/tasks.c **** 				{
1391:../FreeRTOS_Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1392:../FreeRTOS_Source/tasks.c **** 				}
1393:../FreeRTOS_Source/tasks.c **** 			}
1394:../FreeRTOS_Source/tasks.c **** 			#endif
1395:../FreeRTOS_Source/tasks.c **** 		}
1396:../FreeRTOS_Source/tasks.c **** 		xTaskResumeAll();
1397:../FreeRTOS_Source/tasks.c **** 	}
1398:../FreeRTOS_Source/tasks.c **** 
1399:../FreeRTOS_Source/tasks.c **** #endif
1400:../FreeRTOS_Source/tasks.c **** /*----------------------------------------------------------*/
1401:../FreeRTOS_Source/tasks.c **** 
1402:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:../FreeRTOS_Source/tasks.c **** 
1404:../FreeRTOS_Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:../FreeRTOS_Source/tasks.c **** 	{
1406:../FreeRTOS_Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:../FreeRTOS_Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1408:../FreeRTOS_Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:../FreeRTOS_Source/tasks.c **** 		return xIdleTaskHandle;
1410:../FreeRTOS_Source/tasks.c **** 	}
1411:../FreeRTOS_Source/tasks.c **** 	
1412:../FreeRTOS_Source/tasks.c **** #endif
1413:../FreeRTOS_Source/tasks.c **** 
1414:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------
1415:../FreeRTOS_Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:../FreeRTOS_Source/tasks.c ****  * documented in task.h
1417:../FreeRTOS_Source/tasks.c ****  *----------------------------------------------------------*/
1418:../FreeRTOS_Source/tasks.c **** 
1419:../FreeRTOS_Source/tasks.c **** void vTaskIncrementTick( void )
1420:../FreeRTOS_Source/tasks.c **** {
 1976              		.loc 1 1420 0
 1977              		.cfi_startproc
 1978              		@ args = 0, pretend = 0, frame = 16
 1979              		@ frame_needed = 1, uses_anonymous_args = 0
 1980 0000 80B5     		push	{r7, lr}
 1981              	.LCFI48:
 1982              		.cfi_def_cfa_offset 8
 1983              		.cfi_offset 14, -4
 1984              		.cfi_offset 7, -8
 1985 0002 84B0     		sub	sp, sp, #16
 1986              	.LCFI49:
 1987              		.cfi_def_cfa_offset 24
 1988 0004 00AF     		add	r7, sp, #0
 1989              	.LCFI50:
 1990              		.cfi_def_cfa_register 7
1421:../FreeRTOS_Source/tasks.c **** tskTCB * pxTCB;
1422:../FreeRTOS_Source/tasks.c **** 
1423:../FreeRTOS_Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1424:../FreeRTOS_Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1425:../FreeRTOS_Source/tasks.c **** 	tasks to be unblocked. */
1426:../FreeRTOS_Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1991              		.loc 1 1426 0
 1992 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1993 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1994 000e 1B68     		ldr	r3, [r3, #0]
 1995 0010 002B     		cmp	r3, #0
 1996 0012 40F0CD80 		bne	.L99
1427:../FreeRTOS_Source/tasks.c **** 	{
1428:../FreeRTOS_Source/tasks.c **** 		++xTickCount;
 1997              		.loc 1 1428 0
 1998 0016 40F20003 		movw	r3, #:lower16:xTickCount
 1999 001a C0F20003 		movt	r3, #:upper16:xTickCount
 2000 001e 1B68     		ldr	r3, [r3, #0]
 2001 0020 03F10102 		add	r2, r3, #1
 2002 0024 40F20003 		movw	r3, #:lower16:xTickCount
 2003 0028 C0F20003 		movt	r3, #:upper16:xTickCount
 2004 002c 1A60     		str	r2, [r3, #0]
1429:../FreeRTOS_Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 2005              		.loc 1 1429 0
 2006 002e 40F20003 		movw	r3, #:lower16:xTickCount
 2007 0032 C0F20003 		movt	r3, #:upper16:xTickCount
 2008 0036 1B68     		ldr	r3, [r3, #0]
 2009 0038 002B     		cmp	r3, #0
 2010 003a 4DD1     		bne	.L100
 2011              	.LBB4:
1430:../FreeRTOS_Source/tasks.c **** 		{
1431:../FreeRTOS_Source/tasks.c **** 			xList *pxTemp;
1432:../FreeRTOS_Source/tasks.c **** 
1433:../FreeRTOS_Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1434:../FreeRTOS_Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1435:../FreeRTOS_Source/tasks.c **** 			an error! */
1436:../FreeRTOS_Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 2012              		.loc 1 1436 0
 2013 003c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2014 0040 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2015 0044 1B68     		ldr	r3, [r3, #0]
 2016 0046 1B68     		ldr	r3, [r3, #0]
 2017 0048 002B     		cmp	r3, #0
 2018 004a 04D0     		beq	.L101
 2019              		.loc 1 1436 0 is_stmt 0 discriminator 1
 2020              	@ 1436 "../FreeRTOS_Source/tasks.c" 1
 2021 004c 4FF05000 			mov r0, #80								
 2022 0050 80F31188 		msr basepri, r0							
 2023              	
 2024              	@ 0 "" 2
 2025              		.thumb
 2026              	.L102:
 2027              		.loc 1 1436 0 discriminator 2
 2028 0054 FEE7     		b	.L102
 2029              	.L101:
1437:../FreeRTOS_Source/tasks.c **** 			
1438:../FreeRTOS_Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2030              		.loc 1 1438 0 is_stmt 1
 2031 0056 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2032 005a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2033 005e 1B68     		ldr	r3, [r3, #0]
 2034 0060 FB60     		str	r3, [r7, #12]
1439:../FreeRTOS_Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2035              		.loc 1 1439 0
 2036 0062 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2037 0066 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2038 006a 1A68     		ldr	r2, [r3, #0]
 2039 006c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2040 0070 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2041 0074 1A60     		str	r2, [r3, #0]
1440:../FreeRTOS_Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2042              		.loc 1 1440 0
 2043 0076 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2044 007a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2045 007e FA68     		ldr	r2, [r7, #12]
 2046 0080 1A60     		str	r2, [r3, #0]
1441:../FreeRTOS_Source/tasks.c **** 			xNumOfOverflows++;
 2047              		.loc 1 1441 0
 2048 0082 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2049 0086 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2050 008a 1B68     		ldr	r3, [r3, #0]
 2051 008c 03F10102 		add	r2, r3, #1
 2052 0090 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2053 0094 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2054 0098 1A60     		str	r2, [r3, #0]
1442:../FreeRTOS_Source/tasks.c **** 	
1443:../FreeRTOS_Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2055              		.loc 1 1443 0
 2056 009a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2057 009e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2058 00a2 1B68     		ldr	r3, [r3, #0]
 2059 00a4 1B68     		ldr	r3, [r3, #0]
 2060 00a6 002B     		cmp	r3, #0
 2061 00a8 07D1     		bne	.L103
1444:../FreeRTOS_Source/tasks.c **** 			{
1445:../FreeRTOS_Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1446:../FreeRTOS_Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1447:../FreeRTOS_Source/tasks.c **** 				extremely unlikely that the	
1448:../FreeRTOS_Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:../FreeRTOS_Source/tasks.c **** 				there is an item in the delayed list. */
1450:../FreeRTOS_Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2062              		.loc 1 1450 0
 2063 00aa 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2064 00ae C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2065 00b2 4FF0FF32 		mov	r2, #-1
 2066 00b6 1A60     		str	r2, [r3, #0]
 2067 00b8 0EE0     		b	.L100
 2068              	.L103:
1451:../FreeRTOS_Source/tasks.c **** 			}
1452:../FreeRTOS_Source/tasks.c **** 			else
1453:../FreeRTOS_Source/tasks.c **** 			{
1454:../FreeRTOS_Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1455:../FreeRTOS_Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1456:../FreeRTOS_Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1457:../FreeRTOS_Source/tasks.c **** 				from the Blocked state. */
1458:../FreeRTOS_Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2069              		.loc 1 1458 0
 2070 00ba 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2071 00be C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2072 00c2 1B68     		ldr	r3, [r3, #0]
 2073 00c4 DB68     		ldr	r3, [r3, #12]
 2074 00c6 DB68     		ldr	r3, [r3, #12]
 2075 00c8 BB60     		str	r3, [r7, #8]
1459:../FreeRTOS_Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2076              		.loc 1 1459 0
 2077 00ca BB68     		ldr	r3, [r7, #8]
 2078 00cc 5A68     		ldr	r2, [r3, #4]
 2079 00ce 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2080 00d2 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2081 00d6 1A60     		str	r2, [r3, #0]
 2082              	.L100:
 2083              	.LBE4:
 2084              	.LBB5:
1460:../FreeRTOS_Source/tasks.c **** 			}
1461:../FreeRTOS_Source/tasks.c **** 		}
1462:../FreeRTOS_Source/tasks.c **** 
1463:../FreeRTOS_Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1464:../FreeRTOS_Source/tasks.c **** 		prvCheckDelayedTasks();
 2085              		.loc 1 1464 0
 2086 00d8 40F20003 		movw	r3, #:lower16:xTickCount
 2087 00dc C0F20003 		movt	r3, #:upper16:xTickCount
 2088 00e0 1A68     		ldr	r2, [r3, #0]
 2089 00e2 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2090 00e6 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2091 00ea 1B68     		ldr	r3, [r3, #0]
 2092 00ec 9A42     		cmp	r2, r3
 2093 00ee 6BD3     		bcc	.L98
 2094              	.L109:
 2095              		.loc 1 1464 0 is_stmt 0 discriminator 1
 2096 00f0 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2097 00f4 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2098 00f8 1B68     		ldr	r3, [r3, #0]
 2099 00fa 1B68     		ldr	r3, [r3, #0]
 2100 00fc 002B     		cmp	r3, #0
 2101 00fe 07D1     		bne	.L105
 2102              		.loc 1 1464 0 discriminator 2
 2103 0100 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2104 0104 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2105 0108 4FF0FF32 		mov	r2, #-1
 2106 010c 1A60     		str	r2, [r3, #0]
 2107 010e 5BE0     		b	.L98
 2108              	.L105:
 2109              		.loc 1 1464 0 discriminator 3
 2110 0110 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2111 0114 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2112 0118 1B68     		ldr	r3, [r3, #0]
 2113 011a DB68     		ldr	r3, [r3, #12]
 2114 011c DB68     		ldr	r3, [r3, #12]
 2115 011e BB60     		str	r3, [r7, #8]
 2116 0120 BB68     		ldr	r3, [r7, #8]
 2117 0122 5B68     		ldr	r3, [r3, #4]
 2118 0124 7B60     		str	r3, [r7, #4]
 2119 0126 40F20003 		movw	r3, #:lower16:xTickCount
 2120 012a C0F20003 		movt	r3, #:upper16:xTickCount
 2121 012e 1A68     		ldr	r2, [r3, #0]
 2122 0130 7B68     		ldr	r3, [r7, #4]
 2123 0132 9A42     		cmp	r2, r3
 2124 0134 06D2     		bcs	.L106
 2125              		.loc 1 1464 0 discriminator 4
 2126 0136 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2127 013a C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2128 013e 7A68     		ldr	r2, [r7, #4]
 2129 0140 1A60     		str	r2, [r3, #0]
 2130 0142 41E0     		b	.L98
 2131              	.L106:
 2132              		.loc 1 1464 0 discriminator 5
 2133 0144 BB68     		ldr	r3, [r7, #8]
 2134 0146 03F10403 		add	r3, r3, #4
 2135 014a 1846     		mov	r0, r3
 2136 014c FFF7FEFF 		bl	vListRemove
 2137 0150 BB68     		ldr	r3, [r7, #8]
 2138 0152 9B6A     		ldr	r3, [r3, #40]
 2139 0154 002B     		cmp	r3, #0
 2140 0156 05D0     		beq	.L107
 2141              		.loc 1 1464 0 discriminator 6
 2142 0158 BB68     		ldr	r3, [r7, #8]
 2143 015a 03F11803 		add	r3, r3, #24
 2144 015e 1846     		mov	r0, r3
 2145 0160 FFF7FEFF 		bl	vListRemove
 2146              	.L107:
 2147              		.loc 1 1464 0 discriminator 7
 2148 0164 BB68     		ldr	r3, [r7, #8]
 2149 0166 DA6A     		ldr	r2, [r3, #44]
 2150 0168 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2151 016c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2152 0170 1B68     		ldr	r3, [r3, #0]
 2153 0172 9A42     		cmp	r2, r3
 2154 0174 06D9     		bls	.L108
 2155              		.loc 1 1464 0 discriminator 8
 2156 0176 BB68     		ldr	r3, [r7, #8]
 2157 0178 DA6A     		ldr	r2, [r3, #44]
 2158 017a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2159 017e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2160 0182 1A60     		str	r2, [r3, #0]
 2161              	.L108:
 2162              		.loc 1 1464 0 discriminator 9
 2163 0184 BB68     		ldr	r3, [r7, #8]
 2164 0186 DA6A     		ldr	r2, [r3, #44]
 2165 0188 1346     		mov	r3, r2
 2166 018a 4FEA8303 		lsl	r3, r3, #2
 2167 018e 9B18     		adds	r3, r3, r2
 2168 0190 4FEA8303 		lsl	r3, r3, #2
 2169 0194 1A46     		mov	r2, r3
 2170 0196 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2171 019a C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2172 019e D218     		adds	r2, r2, r3
 2173 01a0 BB68     		ldr	r3, [r7, #8]
 2174 01a2 03F10403 		add	r3, r3, #4
 2175 01a6 1046     		mov	r0, r2
 2176 01a8 1946     		mov	r1, r3
 2177 01aa FFF7FEFF 		bl	vListInsertEnd
 2178 01ae 9FE7     		b	.L109
 2179              	.L99:
 2180              	.LBE5:
1465:../FreeRTOS_Source/tasks.c **** 	}
1466:../FreeRTOS_Source/tasks.c **** 	else
1467:../FreeRTOS_Source/tasks.c **** 	{
1468:../FreeRTOS_Source/tasks.c **** 		++uxMissedTicks;
 2181              		.loc 1 1468 0 is_stmt 1
 2182 01b0 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2183 01b4 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2184 01b8 1B68     		ldr	r3, [r3, #0]
 2185 01ba 03F10102 		add	r2, r3, #1
 2186 01be 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2187 01c2 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2188 01c6 1A60     		str	r2, [r3, #0]
 2189              	.L98:
1469:../FreeRTOS_Source/tasks.c **** 
1470:../FreeRTOS_Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1471:../FreeRTOS_Source/tasks.c **** 		scheduler is locked. */
1472:../FreeRTOS_Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1473:../FreeRTOS_Source/tasks.c **** 		{
1474:../FreeRTOS_Source/tasks.c **** 			vApplicationTickHook();
1475:../FreeRTOS_Source/tasks.c **** 		}
1476:../FreeRTOS_Source/tasks.c **** 		#endif
1477:../FreeRTOS_Source/tasks.c **** 	}
1478:../FreeRTOS_Source/tasks.c **** 
1479:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1480:../FreeRTOS_Source/tasks.c **** 	{
1481:../FreeRTOS_Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1482:../FreeRTOS_Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1483:../FreeRTOS_Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1484:../FreeRTOS_Source/tasks.c **** 		{
1485:../FreeRTOS_Source/tasks.c **** 			vApplicationTickHook();
1486:../FreeRTOS_Source/tasks.c **** 		}
1487:../FreeRTOS_Source/tasks.c **** 	}
1488:../FreeRTOS_Source/tasks.c **** 	#endif
1489:../FreeRTOS_Source/tasks.c **** 
1490:../FreeRTOS_Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1491:../FreeRTOS_Source/tasks.c **** }
 2190              		.loc 1 1491 0
 2191 01c8 07F11007 		add	r7, r7, #16
 2192 01cc BD46     		mov	sp, r7
 2193 01ce 80BD     		pop	{r7, pc}
 2194              		.cfi_endproc
 2195              	.LFE17:
 2197              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2198              		.align	2
 2199              		.global	vTaskSwitchContext
 2200              		.thumb
 2201              		.thumb_func
 2203              	vTaskSwitchContext:
 2204              	.LFB18:
1492:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1493:../FreeRTOS_Source/tasks.c **** 
1494:../FreeRTOS_Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:../FreeRTOS_Source/tasks.c **** 
1496:../FreeRTOS_Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:../FreeRTOS_Source/tasks.c **** 	{
1498:../FreeRTOS_Source/tasks.c **** 	tskTCB *xTCB;
1499:../FreeRTOS_Source/tasks.c **** 
1500:../FreeRTOS_Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:../FreeRTOS_Source/tasks.c **** 		if( xTask == NULL )
1502:../FreeRTOS_Source/tasks.c **** 		{
1503:../FreeRTOS_Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:../FreeRTOS_Source/tasks.c **** 		}
1505:../FreeRTOS_Source/tasks.c **** 		else
1506:../FreeRTOS_Source/tasks.c **** 		{
1507:../FreeRTOS_Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:../FreeRTOS_Source/tasks.c **** 		}
1509:../FreeRTOS_Source/tasks.c **** 
1510:../FreeRTOS_Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:../FreeRTOS_Source/tasks.c **** 		the value can be accessed from an interrupt. */
1512:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
1513:../FreeRTOS_Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1514:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
1515:../FreeRTOS_Source/tasks.c **** 	}
1516:../FreeRTOS_Source/tasks.c **** 
1517:../FreeRTOS_Source/tasks.c **** #endif
1518:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1519:../FreeRTOS_Source/tasks.c **** 
1520:../FreeRTOS_Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:../FreeRTOS_Source/tasks.c **** 
1522:../FreeRTOS_Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:../FreeRTOS_Source/tasks.c **** 	{
1524:../FreeRTOS_Source/tasks.c **** 	tskTCB *xTCB;
1525:../FreeRTOS_Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1526:../FreeRTOS_Source/tasks.c **** 
1527:../FreeRTOS_Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1528:../FreeRTOS_Source/tasks.c **** 		if( xTask == NULL )
1529:../FreeRTOS_Source/tasks.c **** 		{
1530:../FreeRTOS_Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:../FreeRTOS_Source/tasks.c **** 		}
1532:../FreeRTOS_Source/tasks.c **** 		else
1533:../FreeRTOS_Source/tasks.c **** 		{
1534:../FreeRTOS_Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1535:../FreeRTOS_Source/tasks.c **** 		}
1536:../FreeRTOS_Source/tasks.c **** 
1537:../FreeRTOS_Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1538:../FreeRTOS_Source/tasks.c **** 		the value can be accessed from an interrupt. */
1539:../FreeRTOS_Source/tasks.c **** 		taskENTER_CRITICAL();
1540:../FreeRTOS_Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1541:../FreeRTOS_Source/tasks.c **** 		taskEXIT_CRITICAL();
1542:../FreeRTOS_Source/tasks.c **** 
1543:../FreeRTOS_Source/tasks.c **** 		return xReturn;
1544:../FreeRTOS_Source/tasks.c **** 	}
1545:../FreeRTOS_Source/tasks.c **** 
1546:../FreeRTOS_Source/tasks.c **** #endif
1547:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1548:../FreeRTOS_Source/tasks.c **** 
1549:../FreeRTOS_Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:../FreeRTOS_Source/tasks.c **** 
1551:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:../FreeRTOS_Source/tasks.c **** 	{
1553:../FreeRTOS_Source/tasks.c **** 	tskTCB *xTCB;
1554:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xReturn;
1555:../FreeRTOS_Source/tasks.c **** 
1556:../FreeRTOS_Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1557:../FreeRTOS_Source/tasks.c **** 		if( xTask == NULL )
1558:../FreeRTOS_Source/tasks.c **** 		{
1559:../FreeRTOS_Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:../FreeRTOS_Source/tasks.c **** 		}
1561:../FreeRTOS_Source/tasks.c **** 		else
1562:../FreeRTOS_Source/tasks.c **** 		{
1563:../FreeRTOS_Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1564:../FreeRTOS_Source/tasks.c **** 		}
1565:../FreeRTOS_Source/tasks.c **** 
1566:../FreeRTOS_Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1567:../FreeRTOS_Source/tasks.c **** 		{
1568:../FreeRTOS_Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1569:../FreeRTOS_Source/tasks.c **** 		}
1570:../FreeRTOS_Source/tasks.c **** 		else
1571:../FreeRTOS_Source/tasks.c **** 		{
1572:../FreeRTOS_Source/tasks.c **** 			xReturn = pdFAIL;
1573:../FreeRTOS_Source/tasks.c **** 		}
1574:../FreeRTOS_Source/tasks.c **** 
1575:../FreeRTOS_Source/tasks.c **** 		return xReturn;
1576:../FreeRTOS_Source/tasks.c **** 	}
1577:../FreeRTOS_Source/tasks.c **** 
1578:../FreeRTOS_Source/tasks.c **** #endif
1579:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1580:../FreeRTOS_Source/tasks.c **** 
1581:../FreeRTOS_Source/tasks.c **** void vTaskSwitchContext( void )
1582:../FreeRTOS_Source/tasks.c **** {
 2205              		.loc 1 1582 0
 2206              		.cfi_startproc
 2207              		@ args = 0, pretend = 0, frame = 8
 2208              		@ frame_needed = 1, uses_anonymous_args = 0
 2209              		@ link register save eliminated.
 2210 0000 80B4     		push	{r7}
 2211              	.LCFI51:
 2212              		.cfi_def_cfa_offset 4
 2213              		.cfi_offset 7, -4
 2214 0002 83B0     		sub	sp, sp, #12
 2215              	.LCFI52:
 2216              		.cfi_def_cfa_offset 16
 2217 0004 00AF     		add	r7, sp, #0
 2218              	.LCFI53:
 2219              		.cfi_def_cfa_register 7
1583:../FreeRTOS_Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2220              		.loc 1 1583 0
 2221 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2222 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2223 000e 1B68     		ldr	r3, [r3, #0]
 2224 0010 002B     		cmp	r3, #0
 2225 0012 20D0     		beq	.L119
1584:../FreeRTOS_Source/tasks.c **** 	{
1585:../FreeRTOS_Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1586:../FreeRTOS_Source/tasks.c **** 		switch. */
1587:../FreeRTOS_Source/tasks.c **** 		xMissedYield = pdTRUE;
 2226              		.loc 1 1587 0
 2227 0014 40F20003 		movw	r3, #:lower16:xMissedYield
 2228 0018 C0F20003 		movt	r3, #:upper16:xMissedYield
 2229 001c 4FF00102 		mov	r2, #1
 2230 0020 1A60     		str	r2, [r3, #0]
 2231 0022 58E0     		b	.L111
 2232              	.L117:
1588:../FreeRTOS_Source/tasks.c **** 	}
1589:../FreeRTOS_Source/tasks.c **** 	else
1590:../FreeRTOS_Source/tasks.c **** 	{
1591:../FreeRTOS_Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1592:../FreeRTOS_Source/tasks.c **** 	
1593:../FreeRTOS_Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:../FreeRTOS_Source/tasks.c **** 		{
1595:../FreeRTOS_Source/tasks.c **** 			unsigned long ulTempCounter;
1596:../FreeRTOS_Source/tasks.c **** 			
1597:../FreeRTOS_Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:../FreeRTOS_Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:../FreeRTOS_Source/tasks.c **** 				#else
1600:../FreeRTOS_Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1601:../FreeRTOS_Source/tasks.c **** 				#endif
1602:../FreeRTOS_Source/tasks.c **** 	
1603:../FreeRTOS_Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1604:../FreeRTOS_Source/tasks.c **** 				time so far.  The time the task started running was stored in
1605:../FreeRTOS_Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:../FreeRTOS_Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1607:../FreeRTOS_Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1608:../FreeRTOS_Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1609:../FreeRTOS_Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1610:../FreeRTOS_Source/tasks.c **** 		}
1611:../FreeRTOS_Source/tasks.c **** 		#endif
1612:../FreeRTOS_Source/tasks.c **** 	
1613:../FreeRTOS_Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1614:../FreeRTOS_Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1615:../FreeRTOS_Source/tasks.c **** 	
1616:../FreeRTOS_Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1617:../FreeRTOS_Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1618:../FreeRTOS_Source/tasks.c **** 		{
1619:../FreeRTOS_Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
 2233              		.loc 1 1619 0
 2234 0024 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2235 0028 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2236 002c 1B68     		ldr	r3, [r3, #0]
 2237 002e 002B     		cmp	r3, #0
 2238 0030 04D1     		bne	.L115
 2239              		.loc 1 1619 0 is_stmt 0 discriminator 1
 2240              	@ 1619 "../FreeRTOS_Source/tasks.c" 1
 2241 0032 4FF05000 			mov r0, #80								
 2242 0036 80F31188 		msr basepri, r0							
 2243              	
 2244              	@ 0 "" 2
 2245              		.thumb
 2246              	.L116:
 2247              		.loc 1 1619 0 discriminator 2
 2248 003a FEE7     		b	.L116
 2249              	.L115:
1620:../FreeRTOS_Source/tasks.c **** 			--uxTopReadyPriority;
 2250              		.loc 1 1620 0 is_stmt 1
 2251 003c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2252 0040 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2253 0044 1B68     		ldr	r3, [r3, #0]
 2254 0046 03F1FF32 		add	r2, r3, #-1
 2255 004a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2256 004e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2257 0052 1A60     		str	r2, [r3, #0]
 2258 0054 00E0     		b	.L114
 2259              	.L119:
1617:../FreeRTOS_Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2260              		.loc 1 1617 0
 2261 0056 00BF     		nop
 2262              	.L114:
1617:../FreeRTOS_Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2263              		.loc 1 1617 0 is_stmt 0 discriminator 1
 2264 0058 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2265 005c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2266 0060 1A68     		ldr	r2, [r3, #0]
 2267 0062 1346     		mov	r3, r2
 2268 0064 4FEA8303 		lsl	r3, r3, #2
 2269 0068 9B18     		adds	r3, r3, r2
 2270 006a 4FEA8303 		lsl	r3, r3, #2
 2271 006e 1A46     		mov	r2, r3
 2272 0070 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2273 0074 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2274 0078 D318     		adds	r3, r2, r3
 2275 007a 1B68     		ldr	r3, [r3, #0]
 2276 007c 002B     		cmp	r3, #0
 2277 007e D1D0     		beq	.L117
 2278              	.LBB6:
1621:../FreeRTOS_Source/tasks.c **** 		}
1622:../FreeRTOS_Source/tasks.c **** 	
1623:../FreeRTOS_Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:../FreeRTOS_Source/tasks.c **** 		same priority get an equal share of the processor time. */
1625:../FreeRTOS_Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2279              		.loc 1 1625 0 is_stmt 1
 2280 0080 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2281 0084 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2282 0088 1A68     		ldr	r2, [r3, #0]
 2283 008a 1346     		mov	r3, r2
 2284 008c 4FEA8303 		lsl	r3, r3, #2
 2285 0090 9B18     		adds	r3, r3, r2
 2286 0092 4FEA8303 		lsl	r3, r3, #2
 2287 0096 1A46     		mov	r2, r3
 2288 0098 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2289 009c C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2290 00a0 D318     		adds	r3, r2, r3
 2291 00a2 7B60     		str	r3, [r7, #4]
 2292 00a4 7B68     		ldr	r3, [r7, #4]
 2293 00a6 5B68     		ldr	r3, [r3, #4]
 2294 00a8 5A68     		ldr	r2, [r3, #4]
 2295 00aa 7B68     		ldr	r3, [r7, #4]
 2296 00ac 5A60     		str	r2, [r3, #4]
 2297 00ae 7B68     		ldr	r3, [r7, #4]
 2298 00b0 5A68     		ldr	r2, [r3, #4]
 2299 00b2 7B68     		ldr	r3, [r7, #4]
 2300 00b4 03F10803 		add	r3, r3, #8
 2301 00b8 9A42     		cmp	r2, r3
 2302 00ba 04D1     		bne	.L118
 2303              		.loc 1 1625 0 is_stmt 0 discriminator 1
 2304 00bc 7B68     		ldr	r3, [r7, #4]
 2305 00be 5B68     		ldr	r3, [r3, #4]
 2306 00c0 5A68     		ldr	r2, [r3, #4]
 2307 00c2 7B68     		ldr	r3, [r7, #4]
 2308 00c4 5A60     		str	r2, [r3, #4]
 2309              	.L118:
 2310              		.loc 1 1625 0 discriminator 2
 2311 00c6 7B68     		ldr	r3, [r7, #4]
 2312 00c8 5B68     		ldr	r3, [r3, #4]
 2313 00ca DA68     		ldr	r2, [r3, #12]
 2314 00cc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2315 00d0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2316 00d4 1A60     		str	r2, [r3, #0]
 2317              	.L111:
 2318              	.LBE6:
1626:../FreeRTOS_Source/tasks.c **** 	
1627:../FreeRTOS_Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1628:../FreeRTOS_Source/tasks.c **** 	}
1629:../FreeRTOS_Source/tasks.c **** }
 2319              		.loc 1 1629 0 is_stmt 1
 2320 00d6 07F10C07 		add	r7, r7, #12
 2321 00da BD46     		mov	sp, r7
 2322 00dc 80BC     		pop	{r7}
 2323 00de 7047     		bx	lr
 2324              		.cfi_endproc
 2325              	.LFE18:
 2327              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2328              		.align	2
 2329              		.global	vTaskPlaceOnEventList
 2330              		.thumb
 2331              		.thumb_func
 2333              	vTaskPlaceOnEventList:
 2334              	.LFB19:
1630:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1631:../FreeRTOS_Source/tasks.c **** 
1632:../FreeRTOS_Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:../FreeRTOS_Source/tasks.c **** {
 2335              		.loc 1 1633 0
 2336              		.cfi_startproc
 2337              		@ args = 0, pretend = 0, frame = 16
 2338              		@ frame_needed = 1, uses_anonymous_args = 0
 2339 0000 80B5     		push	{r7, lr}
 2340              	.LCFI54:
 2341              		.cfi_def_cfa_offset 8
 2342              		.cfi_offset 14, -4
 2343              		.cfi_offset 7, -8
 2344 0002 84B0     		sub	sp, sp, #16
 2345              	.LCFI55:
 2346              		.cfi_def_cfa_offset 24
 2347 0004 00AF     		add	r7, sp, #0
 2348              	.LCFI56:
 2349              		.cfi_def_cfa_register 7
 2350 0006 7860     		str	r0, [r7, #4]
 2351 0008 3960     		str	r1, [r7, #0]
1634:../FreeRTOS_Source/tasks.c **** portTickType xTimeToWake;
1635:../FreeRTOS_Source/tasks.c **** 
1636:../FreeRTOS_Source/tasks.c **** 	configASSERT( pxEventList );
 2352              		.loc 1 1636 0
 2353 000a 7B68     		ldr	r3, [r7, #4]
 2354 000c 002B     		cmp	r3, #0
 2355 000e 04D1     		bne	.L121
 2356              		.loc 1 1636 0 is_stmt 0 discriminator 1
 2357              	@ 1636 "../FreeRTOS_Source/tasks.c" 1
 2358 0010 4FF05000 			mov r0, #80								
 2359 0014 80F31188 		msr basepri, r0							
 2360              	
 2361              	@ 0 "" 2
 2362              		.thumb
 2363              	.L122:
 2364              		.loc 1 1636 0 discriminator 2
 2365 0018 FEE7     		b	.L122
 2366              	.L121:
1637:../FreeRTOS_Source/tasks.c **** 
1638:../FreeRTOS_Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:../FreeRTOS_Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1640:../FreeRTOS_Source/tasks.c **** 
1641:../FreeRTOS_Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1642:../FreeRTOS_Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1643:../FreeRTOS_Source/tasks.c **** 	is the first to be woken by the event. */
1644:../FreeRTOS_Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2367              		.loc 1 1644 0 is_stmt 1
 2368 001a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2369 001e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2370 0022 1B68     		ldr	r3, [r3, #0]
 2371 0024 03F11803 		add	r3, r3, #24
 2372 0028 7868     		ldr	r0, [r7, #4]
 2373 002a 1946     		mov	r1, r3
 2374 002c FFF7FEFF 		bl	vListInsert
1645:../FreeRTOS_Source/tasks.c **** 
1646:../FreeRTOS_Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1647:../FreeRTOS_Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1648:../FreeRTOS_Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1649:../FreeRTOS_Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2375              		.loc 1 1649 0
 2376 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2377 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2378 0038 1B68     		ldr	r3, [r3, #0]
 2379 003a 03F10403 		add	r3, r3, #4
 2380 003e 1846     		mov	r0, r3
 2381 0040 FFF7FEFF 		bl	vListRemove
1650:../FreeRTOS_Source/tasks.c **** 
1651:../FreeRTOS_Source/tasks.c **** 
1652:../FreeRTOS_Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1653:../FreeRTOS_Source/tasks.c **** 	{
1654:../FreeRTOS_Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2382              		.loc 1 1654 0
 2383 0044 3B68     		ldr	r3, [r7, #0]
 2384 0046 B3F1FF3F 		cmp	r3, #-1
 2385 004a 0ED1     		bne	.L123
1655:../FreeRTOS_Source/tasks.c **** 		{
1656:../FreeRTOS_Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1657:../FreeRTOS_Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1658:../FreeRTOS_Source/tasks.c **** 			indefinitely. */
1659:../FreeRTOS_Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2386              		.loc 1 1659 0
 2387 004c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2388 0050 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2389 0054 1B68     		ldr	r3, [r3, #0]
 2390 0056 03F10403 		add	r3, r3, #4
 2391 005a 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2392 005e C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2393 0062 1946     		mov	r1, r3
 2394 0064 FFF7FEFF 		bl	vListInsertEnd
 2395 0068 0AE0     		b	.L120
 2396              	.L123:
1660:../FreeRTOS_Source/tasks.c **** 		}
1661:../FreeRTOS_Source/tasks.c **** 		else
1662:../FreeRTOS_Source/tasks.c **** 		{
1663:../FreeRTOS_Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1664:../FreeRTOS_Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1665:../FreeRTOS_Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2397              		.loc 1 1665 0
 2398 006a 40F20003 		movw	r3, #:lower16:xTickCount
 2399 006e C0F20003 		movt	r3, #:upper16:xTickCount
 2400 0072 1A68     		ldr	r2, [r3, #0]
 2401 0074 3B68     		ldr	r3, [r7, #0]
 2402 0076 D318     		adds	r3, r2, r3
 2403 0078 FB60     		str	r3, [r7, #12]
1666:../FreeRTOS_Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2404              		.loc 1 1666 0
 2405 007a F868     		ldr	r0, [r7, #12]
 2406 007c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2407              	.L120:
1667:../FreeRTOS_Source/tasks.c **** 		}
1668:../FreeRTOS_Source/tasks.c **** 	}
1669:../FreeRTOS_Source/tasks.c **** 	#else
1670:../FreeRTOS_Source/tasks.c **** 	{
1671:../FreeRTOS_Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1672:../FreeRTOS_Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1673:../FreeRTOS_Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1674:../FreeRTOS_Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:../FreeRTOS_Source/tasks.c **** 	}
1676:../FreeRTOS_Source/tasks.c **** 	#endif
1677:../FreeRTOS_Source/tasks.c **** }
 2408              		.loc 1 1677 0
 2409 0080 07F11007 		add	r7, r7, #16
 2410 0084 BD46     		mov	sp, r7
 2411 0086 80BD     		pop	{r7, pc}
 2412              		.cfi_endproc
 2413              	.LFE19:
 2415              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2416              		.align	2
 2417              		.global	vTaskPlaceOnEventListRestricted
 2418              		.thumb
 2419              		.thumb_func
 2421              	vTaskPlaceOnEventListRestricted:
 2422              	.LFB20:
1678:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1679:../FreeRTOS_Source/tasks.c **** 
1680:../FreeRTOS_Source/tasks.c **** #if configUSE_TIMERS == 1
1681:../FreeRTOS_Source/tasks.c **** 
1682:../FreeRTOS_Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:../FreeRTOS_Source/tasks.c **** 	{
 2423              		.loc 1 1683 0
 2424              		.cfi_startproc
 2425              		@ args = 0, pretend = 0, frame = 16
 2426              		@ frame_needed = 1, uses_anonymous_args = 0
 2427 0000 80B5     		push	{r7, lr}
 2428              	.LCFI57:
 2429              		.cfi_def_cfa_offset 8
 2430              		.cfi_offset 14, -4
 2431              		.cfi_offset 7, -8
 2432 0002 84B0     		sub	sp, sp, #16
 2433              	.LCFI58:
 2434              		.cfi_def_cfa_offset 24
 2435 0004 00AF     		add	r7, sp, #0
 2436              	.LCFI59:
 2437              		.cfi_def_cfa_register 7
 2438 0006 7860     		str	r0, [r7, #4]
 2439 0008 3960     		str	r1, [r7, #0]
1684:../FreeRTOS_Source/tasks.c **** 	portTickType xTimeToWake;
1685:../FreeRTOS_Source/tasks.c **** 
1686:../FreeRTOS_Source/tasks.c **** 		configASSERT( pxEventList );
 2440              		.loc 1 1686 0
 2441 000a 7B68     		ldr	r3, [r7, #4]
 2442 000c 002B     		cmp	r3, #0
 2443 000e 04D1     		bne	.L126
 2444              		.loc 1 1686 0 is_stmt 0 discriminator 1
 2445              	@ 1686 "../FreeRTOS_Source/tasks.c" 1
 2446 0010 4FF05000 			mov r0, #80								
 2447 0014 80F31188 		msr basepri, r0							
 2448              	
 2449              	@ 0 "" 2
 2450              		.thumb
 2451              	.L127:
 2452              		.loc 1 1686 0 discriminator 2
 2453 0018 FEE7     		b	.L127
 2454              	.L126:
1687:../FreeRTOS_Source/tasks.c **** 
1688:../FreeRTOS_Source/tasks.c **** 		/* This function should not be called by application code hence the
1689:../FreeRTOS_Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1690:../FreeRTOS_Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1691:../FreeRTOS_Source/tasks.c **** 		it should be called from a critical section. */
1692:../FreeRTOS_Source/tasks.c **** 
1693:../FreeRTOS_Source/tasks.c **** 	
1694:../FreeRTOS_Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1695:../FreeRTOS_Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1696:../FreeRTOS_Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1697:../FreeRTOS_Source/tasks.c **** 		can be used in place of vListInsert. */
1698:../FreeRTOS_Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2455              		.loc 1 1698 0 is_stmt 1
 2456 001a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2457 001e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2458 0022 1B68     		ldr	r3, [r3, #0]
 2459 0024 03F11803 		add	r3, r3, #24
 2460 0028 7868     		ldr	r0, [r7, #4]
 2461 002a 1946     		mov	r1, r3
 2462 002c FFF7FEFF 		bl	vListInsertEnd
1699:../FreeRTOS_Source/tasks.c **** 
1700:../FreeRTOS_Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1701:../FreeRTOS_Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1702:../FreeRTOS_Source/tasks.c **** 		function is called form a critical section. */
1703:../FreeRTOS_Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2463              		.loc 1 1703 0
 2464 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2465 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2466 0038 1B68     		ldr	r3, [r3, #0]
 2467 003a 03F10403 		add	r3, r3, #4
 2468 003e 1846     		mov	r0, r3
 2469 0040 FFF7FEFF 		bl	vListRemove
1704:../FreeRTOS_Source/tasks.c **** 
1705:../FreeRTOS_Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1706:../FreeRTOS_Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1707:../FreeRTOS_Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2470              		.loc 1 1707 0
 2471 0044 40F20003 		movw	r3, #:lower16:xTickCount
 2472 0048 C0F20003 		movt	r3, #:upper16:xTickCount
 2473 004c 1A68     		ldr	r2, [r3, #0]
 2474 004e 3B68     		ldr	r3, [r7, #0]
 2475 0050 D318     		adds	r3, r2, r3
 2476 0052 FB60     		str	r3, [r7, #12]
1708:../FreeRTOS_Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2477              		.loc 1 1708 0
 2478 0054 F868     		ldr	r0, [r7, #12]
 2479 0056 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1709:../FreeRTOS_Source/tasks.c **** 	}
 2480              		.loc 1 1709 0
 2481 005a 07F11007 		add	r7, r7, #16
 2482 005e BD46     		mov	sp, r7
 2483 0060 80BD     		pop	{r7, pc}
 2484              		.cfi_endproc
 2485              	.LFE20:
 2487 0062 00BF     		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2488              		.align	2
 2489              		.global	xTaskRemoveFromEventList
 2490              		.thumb
 2491              		.thumb_func
 2493              	xTaskRemoveFromEventList:
 2494              	.LFB21:
1710:../FreeRTOS_Source/tasks.c **** 	
1711:../FreeRTOS_Source/tasks.c **** #endif /* configUSE_TIMERS */
1712:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1713:../FreeRTOS_Source/tasks.c **** 
1714:../FreeRTOS_Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:../FreeRTOS_Source/tasks.c **** {
 2495              		.loc 1 1715 0
 2496              		.cfi_startproc
 2497              		@ args = 0, pretend = 0, frame = 16
 2498              		@ frame_needed = 1, uses_anonymous_args = 0
 2499 0000 80B5     		push	{r7, lr}
 2500              	.LCFI60:
 2501              		.cfi_def_cfa_offset 8
 2502              		.cfi_offset 14, -4
 2503              		.cfi_offset 7, -8
 2504 0002 84B0     		sub	sp, sp, #16
 2505              	.LCFI61:
 2506              		.cfi_def_cfa_offset 24
 2507 0004 00AF     		add	r7, sp, #0
 2508              	.LCFI62:
 2509              		.cfi_def_cfa_register 7
 2510 0006 7860     		str	r0, [r7, #4]
1716:../FreeRTOS_Source/tasks.c **** tskTCB *pxUnblockedTCB;
1717:../FreeRTOS_Source/tasks.c **** portBASE_TYPE xReturn;
1718:../FreeRTOS_Source/tasks.c **** 
1719:../FreeRTOS_Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:../FreeRTOS_Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:../FreeRTOS_Source/tasks.c **** 
1722:../FreeRTOS_Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1723:../FreeRTOS_Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1724:../FreeRTOS_Source/tasks.c **** 	it to the ready list.
1725:../FreeRTOS_Source/tasks.c **** 
1726:../FreeRTOS_Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1727:../FreeRTOS_Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1728:../FreeRTOS_Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1729:../FreeRTOS_Source/tasks.c **** 	
1730:../FreeRTOS_Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1731:../FreeRTOS_Source/tasks.c **** 	pxEventList is not empty. */
1732:../FreeRTOS_Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2511              		.loc 1 1732 0
 2512 0008 7B68     		ldr	r3, [r7, #4]
 2513 000a DB68     		ldr	r3, [r3, #12]
 2514 000c DB68     		ldr	r3, [r3, #12]
 2515 000e BB60     		str	r3, [r7, #8]
1733:../FreeRTOS_Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2516              		.loc 1 1733 0
 2517 0010 BB68     		ldr	r3, [r7, #8]
 2518 0012 002B     		cmp	r3, #0
 2519 0014 04D1     		bne	.L129
 2520              		.loc 1 1733 0 is_stmt 0 discriminator 1
 2521              	@ 1733 "../FreeRTOS_Source/tasks.c" 1
 2522 0016 4FF05000 			mov r0, #80								
 2523 001a 80F31188 		msr basepri, r0							
 2524              	
 2525              	@ 0 "" 2
 2526              		.thumb
 2527              	.L130:
 2528              		.loc 1 1733 0 discriminator 2
 2529 001e FEE7     		b	.L130
 2530              	.L129:
1734:../FreeRTOS_Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2531              		.loc 1 1734 0 is_stmt 1
 2532 0020 BB68     		ldr	r3, [r7, #8]
 2533 0022 03F11803 		add	r3, r3, #24
 2534 0026 1846     		mov	r0, r3
 2535 0028 FFF7FEFF 		bl	vListRemove
1735:../FreeRTOS_Source/tasks.c **** 
1736:../FreeRTOS_Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2536              		.loc 1 1736 0
 2537 002c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2538 0030 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2539 0034 1B68     		ldr	r3, [r3, #0]
 2540 0036 002B     		cmp	r3, #0
 2541 0038 2BD1     		bne	.L131
1737:../FreeRTOS_Source/tasks.c **** 	{
1738:../FreeRTOS_Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2542              		.loc 1 1738 0
 2543 003a BB68     		ldr	r3, [r7, #8]
 2544 003c 03F10403 		add	r3, r3, #4
 2545 0040 1846     		mov	r0, r3
 2546 0042 FFF7FEFF 		bl	vListRemove
1739:../FreeRTOS_Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2547              		.loc 1 1739 0
 2548 0046 BB68     		ldr	r3, [r7, #8]
 2549 0048 DA6A     		ldr	r2, [r3, #44]
 2550 004a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2551 004e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2552 0052 1B68     		ldr	r3, [r3, #0]
 2553 0054 9A42     		cmp	r2, r3
 2554 0056 06D9     		bls	.L132
 2555              		.loc 1 1739 0 is_stmt 0 discriminator 1
 2556 0058 BB68     		ldr	r3, [r7, #8]
 2557 005a DA6A     		ldr	r2, [r3, #44]
 2558 005c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2559 0060 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2560 0064 1A60     		str	r2, [r3, #0]
 2561              	.L132:
 2562              		.loc 1 1739 0 discriminator 2
 2563 0066 BB68     		ldr	r3, [r7, #8]
 2564 0068 DA6A     		ldr	r2, [r3, #44]
 2565 006a 1346     		mov	r3, r2
 2566 006c 4FEA8303 		lsl	r3, r3, #2
 2567 0070 9B18     		adds	r3, r3, r2
 2568 0072 4FEA8303 		lsl	r3, r3, #2
 2569 0076 1A46     		mov	r2, r3
 2570 0078 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2571 007c C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2572 0080 D218     		adds	r2, r2, r3
 2573 0082 BB68     		ldr	r3, [r7, #8]
 2574 0084 03F10403 		add	r3, r3, #4
 2575 0088 1046     		mov	r0, r2
 2576 008a 1946     		mov	r1, r3
 2577 008c FFF7FEFF 		bl	vListInsertEnd
 2578 0090 09E0     		b	.L133
 2579              	.L131:
1740:../FreeRTOS_Source/tasks.c **** 	}
1741:../FreeRTOS_Source/tasks.c **** 	else
1742:../FreeRTOS_Source/tasks.c **** 	{
1743:../FreeRTOS_Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1744:../FreeRTOS_Source/tasks.c **** 		task pending until the scheduler is resumed. */
1745:../FreeRTOS_Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2580              		.loc 1 1745 0 is_stmt 1
 2581 0092 BB68     		ldr	r3, [r7, #8]
 2582 0094 03F11803 		add	r3, r3, #24
 2583 0098 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2584 009c C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2585 00a0 1946     		mov	r1, r3
 2586 00a2 FFF7FEFF 		bl	vListInsertEnd
 2587              	.L133:
1746:../FreeRTOS_Source/tasks.c **** 	}
1747:../FreeRTOS_Source/tasks.c **** 
1748:../FreeRTOS_Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2588              		.loc 1 1748 0
 2589 00a6 BB68     		ldr	r3, [r7, #8]
 2590 00a8 DA6A     		ldr	r2, [r3, #44]
 2591 00aa 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2592 00ae C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2593 00b2 1B68     		ldr	r3, [r3, #0]
 2594 00b4 DB6A     		ldr	r3, [r3, #44]
 2595 00b6 9A42     		cmp	r2, r3
 2596 00b8 03D3     		bcc	.L134
1749:../FreeRTOS_Source/tasks.c **** 	{
1750:../FreeRTOS_Source/tasks.c **** 		/* Return true if the task removed from the event list has
1751:../FreeRTOS_Source/tasks.c **** 		a higher priority than the calling task.  This allows
1752:../FreeRTOS_Source/tasks.c **** 		the calling task to know if it should force a context
1753:../FreeRTOS_Source/tasks.c **** 		switch now. */
1754:../FreeRTOS_Source/tasks.c **** 		xReturn = pdTRUE;
 2597              		.loc 1 1754 0
 2598 00ba 4FF00103 		mov	r3, #1
 2599 00be FB60     		str	r3, [r7, #12]
 2600 00c0 02E0     		b	.L135
 2601              	.L134:
1755:../FreeRTOS_Source/tasks.c **** 	}
1756:../FreeRTOS_Source/tasks.c **** 	else
1757:../FreeRTOS_Source/tasks.c **** 	{
1758:../FreeRTOS_Source/tasks.c **** 		xReturn = pdFALSE;
 2602              		.loc 1 1758 0
 2603 00c2 4FF00003 		mov	r3, #0
 2604 00c6 FB60     		str	r3, [r7, #12]
 2605              	.L135:
1759:../FreeRTOS_Source/tasks.c **** 	}
1760:../FreeRTOS_Source/tasks.c **** 
1761:../FreeRTOS_Source/tasks.c **** 	return xReturn;
 2606              		.loc 1 1761 0
 2607 00c8 FB68     		ldr	r3, [r7, #12]
1762:../FreeRTOS_Source/tasks.c **** }
 2608              		.loc 1 1762 0
 2609 00ca 1846     		mov	r0, r3
 2610 00cc 07F11007 		add	r7, r7, #16
 2611 00d0 BD46     		mov	sp, r7
 2612 00d2 80BD     		pop	{r7, pc}
 2613              		.cfi_endproc
 2614              	.LFE21:
 2616              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2617              		.align	2
 2618              		.global	vTaskSetTimeOutState
 2619              		.thumb
 2620              		.thumb_func
 2622              	vTaskSetTimeOutState:
 2623              	.LFB22:
1763:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1764:../FreeRTOS_Source/tasks.c **** 
1765:../FreeRTOS_Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:../FreeRTOS_Source/tasks.c **** {
 2624              		.loc 1 1766 0
 2625              		.cfi_startproc
 2626              		@ args = 0, pretend = 0, frame = 8
 2627              		@ frame_needed = 1, uses_anonymous_args = 0
 2628              		@ link register save eliminated.
 2629 0000 80B4     		push	{r7}
 2630              	.LCFI63:
 2631              		.cfi_def_cfa_offset 4
 2632              		.cfi_offset 7, -4
 2633 0002 83B0     		sub	sp, sp, #12
 2634              	.LCFI64:
 2635              		.cfi_def_cfa_offset 16
 2636 0004 00AF     		add	r7, sp, #0
 2637              	.LCFI65:
 2638              		.cfi_def_cfa_register 7
 2639 0006 7860     		str	r0, [r7, #4]
1767:../FreeRTOS_Source/tasks.c **** 	configASSERT( pxTimeOut );
 2640              		.loc 1 1767 0
 2641 0008 7B68     		ldr	r3, [r7, #4]
 2642 000a 002B     		cmp	r3, #0
 2643 000c 04D1     		bne	.L137
 2644              		.loc 1 1767 0 is_stmt 0 discriminator 1
 2645              	@ 1767 "../FreeRTOS_Source/tasks.c" 1
 2646 000e 4FF05000 			mov r0, #80								
 2647 0012 80F31188 		msr basepri, r0							
 2648              	
 2649              	@ 0 "" 2
 2650              		.thumb
 2651              	.L138:
 2652              		.loc 1 1767 0 discriminator 2
 2653 0016 FEE7     		b	.L138
 2654              	.L137:
1768:../FreeRTOS_Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2655              		.loc 1 1768 0 is_stmt 1
 2656 0018 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2657 001c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2658 0020 1A68     		ldr	r2, [r3, #0]
 2659 0022 7B68     		ldr	r3, [r7, #4]
 2660 0024 1A60     		str	r2, [r3, #0]
1769:../FreeRTOS_Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2661              		.loc 1 1769 0
 2662 0026 40F20003 		movw	r3, #:lower16:xTickCount
 2663 002a C0F20003 		movt	r3, #:upper16:xTickCount
 2664 002e 1A68     		ldr	r2, [r3, #0]
 2665 0030 7B68     		ldr	r3, [r7, #4]
 2666 0032 5A60     		str	r2, [r3, #4]
1770:../FreeRTOS_Source/tasks.c **** }
 2667              		.loc 1 1770 0
 2668 0034 07F10C07 		add	r7, r7, #12
 2669 0038 BD46     		mov	sp, r7
 2670 003a 80BC     		pop	{r7}
 2671 003c 7047     		bx	lr
 2672              		.cfi_endproc
 2673              	.LFE22:
 2675 003e 00BF     		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2676              		.align	2
 2677              		.global	xTaskCheckForTimeOut
 2678              		.thumb
 2679              		.thumb_func
 2681              	xTaskCheckForTimeOut:
 2682              	.LFB23:
1771:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1772:../FreeRTOS_Source/tasks.c **** 
1773:../FreeRTOS_Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1774:../FreeRTOS_Source/tasks.c **** {
 2683              		.loc 1 1774 0
 2684              		.cfi_startproc
 2685              		@ args = 0, pretend = 0, frame = 16
 2686              		@ frame_needed = 1, uses_anonymous_args = 0
 2687 0000 80B5     		push	{r7, lr}
 2688              	.LCFI66:
 2689              		.cfi_def_cfa_offset 8
 2690              		.cfi_offset 14, -4
 2691              		.cfi_offset 7, -8
 2692 0002 84B0     		sub	sp, sp, #16
 2693              	.LCFI67:
 2694              		.cfi_def_cfa_offset 24
 2695 0004 00AF     		add	r7, sp, #0
 2696              	.LCFI68:
 2697              		.cfi_def_cfa_register 7
 2698 0006 7860     		str	r0, [r7, #4]
 2699 0008 3960     		str	r1, [r7, #0]
1775:../FreeRTOS_Source/tasks.c **** portBASE_TYPE xReturn;
1776:../FreeRTOS_Source/tasks.c **** 
1777:../FreeRTOS_Source/tasks.c **** 	configASSERT( pxTimeOut );
 2700              		.loc 1 1777 0
 2701 000a 7B68     		ldr	r3, [r7, #4]
 2702 000c 002B     		cmp	r3, #0
 2703 000e 04D1     		bne	.L140
 2704              		.loc 1 1777 0 is_stmt 0 discriminator 1
 2705              	@ 1777 "../FreeRTOS_Source/tasks.c" 1
 2706 0010 4FF05000 			mov r0, #80								
 2707 0014 80F31188 		msr basepri, r0							
 2708              	
 2709              	@ 0 "" 2
 2710              		.thumb
 2711              	.L141:
 2712              		.loc 1 1777 0 discriminator 2
 2713 0018 FEE7     		b	.L141
 2714              	.L140:
1778:../FreeRTOS_Source/tasks.c **** 	configASSERT( pxTicksToWait );
 2715              		.loc 1 1778 0 is_stmt 1
 2716 001a 3B68     		ldr	r3, [r7, #0]
 2717 001c 002B     		cmp	r3, #0
 2718 001e 04D1     		bne	.L142
 2719              		.loc 1 1778 0 is_stmt 0 discriminator 1
 2720              	@ 1778 "../FreeRTOS_Source/tasks.c" 1
 2721 0020 4FF05000 			mov r0, #80								
 2722 0024 80F31188 		msr basepri, r0							
 2723              	
 2724              	@ 0 "" 2
 2725              		.thumb
 2726              	.L143:
 2727              		.loc 1 1778 0 discriminator 2
 2728 0028 FEE7     		b	.L143
 2729              	.L142:
1779:../FreeRTOS_Source/tasks.c **** 
1780:../FreeRTOS_Source/tasks.c **** 	taskENTER_CRITICAL();
 2730              		.loc 1 1780 0 is_stmt 1
 2731 002a FFF7FEFF 		bl	vPortEnterCritical
1781:../FreeRTOS_Source/tasks.c **** 	{
1782:../FreeRTOS_Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1783:../FreeRTOS_Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:../FreeRTOS_Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1785:../FreeRTOS_Source/tasks.c **** 			therefore never time out. */
1786:../FreeRTOS_Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2732              		.loc 1 1786 0
 2733 002e 3B68     		ldr	r3, [r7, #0]
 2734 0030 1B68     		ldr	r3, [r3, #0]
 2735 0032 B3F1FF3F 		cmp	r3, #-1
 2736 0036 03D1     		bne	.L144
1787:../FreeRTOS_Source/tasks.c **** 			{
1788:../FreeRTOS_Source/tasks.c **** 				xReturn = pdFALSE;
 2737              		.loc 1 1788 0
 2738 0038 4FF00003 		mov	r3, #0
 2739 003c FB60     		str	r3, [r7, #12]
 2740 003e 38E0     		b	.L145
 2741              	.L144:
1789:../FreeRTOS_Source/tasks.c **** 			}
1790:../FreeRTOS_Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1791:../FreeRTOS_Source/tasks.c **** 		#endif
1792:../FreeRTOS_Source/tasks.c **** 
1793:../FreeRTOS_Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2742              		.loc 1 1793 0
 2743 0040 7B68     		ldr	r3, [r7, #4]
 2744 0042 1A68     		ldr	r2, [r3, #0]
 2745 0044 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2746 0048 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2747 004c 1B68     		ldr	r3, [r3, #0]
 2748 004e 9A42     		cmp	r2, r3
 2749 0050 0CD0     		beq	.L146
 2750              		.loc 1 1793 0 is_stmt 0 discriminator 1
 2751 0052 7B68     		ldr	r3, [r7, #4]
 2752 0054 5A68     		ldr	r2, [r3, #4]
 2753 0056 40F20003 		movw	r3, #:lower16:xTickCount
 2754 005a C0F20003 		movt	r3, #:upper16:xTickCount
 2755 005e 1B68     		ldr	r3, [r3, #0]
 2756 0060 9A42     		cmp	r2, r3
 2757 0062 03D8     		bhi	.L146
1794:../FreeRTOS_Source/tasks.c **** 		{
1795:../FreeRTOS_Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:../FreeRTOS_Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:../FreeRTOS_Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1798:../FreeRTOS_Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1799:../FreeRTOS_Source/tasks.c **** 			xReturn = pdTRUE;
 2758              		.loc 1 1799 0 is_stmt 1
 2759 0064 4FF00103 		mov	r3, #1
 2760 0068 FB60     		str	r3, [r7, #12]
 2761 006a 22E0     		b	.L145
 2762              	.L146:
1800:../FreeRTOS_Source/tasks.c **** 		}
1801:../FreeRTOS_Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2763              		.loc 1 1801 0
 2764 006c 40F20003 		movw	r3, #:lower16:xTickCount
 2765 0070 C0F20003 		movt	r3, #:upper16:xTickCount
 2766 0074 1A68     		ldr	r2, [r3, #0]
 2767 0076 7B68     		ldr	r3, [r7, #4]
 2768 0078 5B68     		ldr	r3, [r3, #4]
 2769 007a D21A     		subs	r2, r2, r3
 2770 007c 3B68     		ldr	r3, [r7, #0]
 2771 007e 1B68     		ldr	r3, [r3, #0]
 2772 0080 9A42     		cmp	r2, r3
 2773 0082 13D2     		bcs	.L147
1802:../FreeRTOS_Source/tasks.c **** 		{
1803:../FreeRTOS_Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:../FreeRTOS_Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2774              		.loc 1 1804 0
 2775 0084 3B68     		ldr	r3, [r7, #0]
 2776 0086 1A68     		ldr	r2, [r3, #0]
 2777 0088 7B68     		ldr	r3, [r7, #4]
 2778 008a 5968     		ldr	r1, [r3, #4]
 2779 008c 40F20003 		movw	r3, #:lower16:xTickCount
 2780 0090 C0F20003 		movt	r3, #:upper16:xTickCount
 2781 0094 1B68     		ldr	r3, [r3, #0]
 2782 0096 CB1A     		subs	r3, r1, r3
 2783 0098 D218     		adds	r2, r2, r3
 2784 009a 3B68     		ldr	r3, [r7, #0]
 2785 009c 1A60     		str	r2, [r3, #0]
1805:../FreeRTOS_Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2786              		.loc 1 1805 0
 2787 009e 7868     		ldr	r0, [r7, #4]
 2788 00a0 FFF7FEFF 		bl	vTaskSetTimeOutState
1806:../FreeRTOS_Source/tasks.c **** 			xReturn = pdFALSE;
 2789              		.loc 1 1806 0
 2790 00a4 4FF00003 		mov	r3, #0
 2791 00a8 FB60     		str	r3, [r7, #12]
 2792 00aa 02E0     		b	.L145
 2793              	.L147:
1807:../FreeRTOS_Source/tasks.c **** 		}
1808:../FreeRTOS_Source/tasks.c **** 		else
1809:../FreeRTOS_Source/tasks.c **** 		{
1810:../FreeRTOS_Source/tasks.c **** 			xReturn = pdTRUE;
 2794              		.loc 1 1810 0
 2795 00ac 4FF00103 		mov	r3, #1
 2796 00b0 FB60     		str	r3, [r7, #12]
 2797              	.L145:
1811:../FreeRTOS_Source/tasks.c **** 		}
1812:../FreeRTOS_Source/tasks.c **** 	}
1813:../FreeRTOS_Source/tasks.c **** 	taskEXIT_CRITICAL();
 2798              		.loc 1 1813 0
 2799 00b2 FFF7FEFF 		bl	vPortExitCritical
1814:../FreeRTOS_Source/tasks.c **** 
1815:../FreeRTOS_Source/tasks.c **** 	return xReturn;
 2800              		.loc 1 1815 0
 2801 00b6 FB68     		ldr	r3, [r7, #12]
1816:../FreeRTOS_Source/tasks.c **** }
 2802              		.loc 1 1816 0
 2803 00b8 1846     		mov	r0, r3
 2804 00ba 07F11007 		add	r7, r7, #16
 2805 00be BD46     		mov	sp, r7
 2806 00c0 80BD     		pop	{r7, pc}
 2807              		.cfi_endproc
 2808              	.LFE23:
 2810 00c2 00BF     		.section	.text.vTaskMissedYield,"ax",%progbits
 2811              		.align	2
 2812              		.global	vTaskMissedYield
 2813              		.thumb
 2814              		.thumb_func
 2816              	vTaskMissedYield:
 2817              	.LFB24:
1817:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1818:../FreeRTOS_Source/tasks.c **** 
1819:../FreeRTOS_Source/tasks.c **** void vTaskMissedYield( void )
1820:../FreeRTOS_Source/tasks.c **** {
 2818              		.loc 1 1820 0
 2819              		.cfi_startproc
 2820              		@ args = 0, pretend = 0, frame = 0
 2821              		@ frame_needed = 1, uses_anonymous_args = 0
 2822              		@ link register save eliminated.
 2823 0000 80B4     		push	{r7}
 2824              	.LCFI69:
 2825              		.cfi_def_cfa_offset 4
 2826              		.cfi_offset 7, -4
 2827 0002 00AF     		add	r7, sp, #0
 2828              	.LCFI70:
 2829              		.cfi_def_cfa_register 7
1821:../FreeRTOS_Source/tasks.c **** 	xMissedYield = pdTRUE;
 2830              		.loc 1 1821 0
 2831 0004 40F20003 		movw	r3, #:lower16:xMissedYield
 2832 0008 C0F20003 		movt	r3, #:upper16:xMissedYield
 2833 000c 4FF00102 		mov	r2, #1
 2834 0010 1A60     		str	r2, [r3, #0]
1822:../FreeRTOS_Source/tasks.c **** }
 2835              		.loc 1 1822 0
 2836 0012 BD46     		mov	sp, r7
 2837 0014 80BC     		pop	{r7}
 2838 0016 7047     		bx	lr
 2839              		.cfi_endproc
 2840              	.LFE24:
 2842              		.section	.text.prvIdleTask,"ax",%progbits
 2843              		.align	2
 2844              		.thumb
 2845              		.thumb_func
 2847              	prvIdleTask:
 2848              	.LFB25:
1823:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1824:../FreeRTOS_Source/tasks.c **** 
1825:../FreeRTOS_Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1826:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:../FreeRTOS_Source/tasks.c **** 	{
1828:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1829:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
1830:../FreeRTOS_Source/tasks.c **** 	
1831:../FreeRTOS_Source/tasks.c **** 		if( xTask != NULL )
1832:../FreeRTOS_Source/tasks.c **** 		{
1833:../FreeRTOS_Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
1834:../FreeRTOS_Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
1835:../FreeRTOS_Source/tasks.c **** 		}
1836:../FreeRTOS_Source/tasks.c **** 		else
1837:../FreeRTOS_Source/tasks.c **** 		{
1838:../FreeRTOS_Source/tasks.c **** 			uxReturn = 0U;
1839:../FreeRTOS_Source/tasks.c **** 		}
1840:../FreeRTOS_Source/tasks.c **** 		
1841:../FreeRTOS_Source/tasks.c **** 		return uxReturn;
1842:../FreeRTOS_Source/tasks.c **** 	}
1843:../FreeRTOS_Source/tasks.c **** #endif
1844:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
1845:../FreeRTOS_Source/tasks.c **** 
1846:../FreeRTOS_Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1847:../FreeRTOS_Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:../FreeRTOS_Source/tasks.c **** 	{
1849:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
1850:../FreeRTOS_Source/tasks.c **** 	
1851:../FreeRTOS_Source/tasks.c **** 		if( xTask != NULL )
1852:../FreeRTOS_Source/tasks.c **** 		{
1853:../FreeRTOS_Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
1854:../FreeRTOS_Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
1855:../FreeRTOS_Source/tasks.c **** 		}
1856:../FreeRTOS_Source/tasks.c **** 	}
1857:../FreeRTOS_Source/tasks.c **** #endif
1858:../FreeRTOS_Source/tasks.c **** 
1859:../FreeRTOS_Source/tasks.c **** 
1860:../FreeRTOS_Source/tasks.c **** /*
1861:../FreeRTOS_Source/tasks.c ****  * -----------------------------------------------------------
1862:../FreeRTOS_Source/tasks.c ****  * The Idle task.
1863:../FreeRTOS_Source/tasks.c ****  * ----------------------------------------------------------
1864:../FreeRTOS_Source/tasks.c ****  *
1865:../FreeRTOS_Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:../FreeRTOS_Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1867:../FreeRTOS_Source/tasks.c ****  *
1868:../FreeRTOS_Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1869:../FreeRTOS_Source/tasks.c ****  *
1870:../FreeRTOS_Source/tasks.c ****  */
1871:../FreeRTOS_Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:../FreeRTOS_Source/tasks.c **** {
 2849              		.loc 1 1872 0
 2850              		.cfi_startproc
 2851              		@ args = 0, pretend = 0, frame = 8
 2852              		@ frame_needed = 1, uses_anonymous_args = 0
 2853 0000 80B5     		push	{r7, lr}
 2854              	.LCFI71:
 2855              		.cfi_def_cfa_offset 8
 2856              		.cfi_offset 14, -4
 2857              		.cfi_offset 7, -8
 2858 0002 82B0     		sub	sp, sp, #8
 2859              	.LCFI72:
 2860              		.cfi_def_cfa_offset 16
 2861 0004 00AF     		add	r7, sp, #0
 2862              	.LCFI73:
 2863              		.cfi_def_cfa_register 7
 2864 0006 7860     		str	r0, [r7, #4]
 2865 0008 00E0     		b	.L151
 2866              	.L152:
1873:../FreeRTOS_Source/tasks.c **** 	/* Stop warnings. */
1874:../FreeRTOS_Source/tasks.c **** 	( void ) pvParameters;
1875:../FreeRTOS_Source/tasks.c **** 
1876:../FreeRTOS_Source/tasks.c **** 	for( ;; )
1877:../FreeRTOS_Source/tasks.c **** 	{
1878:../FreeRTOS_Source/tasks.c **** 		/* See if any tasks have been deleted. */
1879:../FreeRTOS_Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1880:../FreeRTOS_Source/tasks.c **** 
1881:../FreeRTOS_Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1882:../FreeRTOS_Source/tasks.c **** 		{
1883:../FreeRTOS_Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1884:../FreeRTOS_Source/tasks.c **** 			see if any other task has become available.  If we are using
1885:../FreeRTOS_Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1886:../FreeRTOS_Source/tasks.c **** 			will automatically get the processor anyway. */
1887:../FreeRTOS_Source/tasks.c **** 			taskYIELD();
1888:../FreeRTOS_Source/tasks.c **** 		}
1889:../FreeRTOS_Source/tasks.c **** 		#endif
1890:../FreeRTOS_Source/tasks.c **** 
1891:../FreeRTOS_Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:../FreeRTOS_Source/tasks.c **** 		{
1893:../FreeRTOS_Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1894:../FreeRTOS_Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1895:../FreeRTOS_Source/tasks.c **** 			to run then the idle task should yield before the end of the
1896:../FreeRTOS_Source/tasks.c **** 			timeslice.
1897:../FreeRTOS_Source/tasks.c **** 
1898:../FreeRTOS_Source/tasks.c **** 			A critical region is not required here as we are just reading from
1899:../FreeRTOS_Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1900:../FreeRTOS_Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1901:../FreeRTOS_Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1902:../FreeRTOS_Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1903:../FreeRTOS_Source/tasks.c **** 			{
1904:../FreeRTOS_Source/tasks.c **** 				taskYIELD();
1905:../FreeRTOS_Source/tasks.c **** 			}
1906:../FreeRTOS_Source/tasks.c **** 		}
1907:../FreeRTOS_Source/tasks.c **** 		#endif
1908:../FreeRTOS_Source/tasks.c **** 
1909:../FreeRTOS_Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1910:../FreeRTOS_Source/tasks.c **** 		{
1911:../FreeRTOS_Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1912:../FreeRTOS_Source/tasks.c **** 
1913:../FreeRTOS_Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1914:../FreeRTOS_Source/tasks.c **** 			allows the application designer to add background functionality
1915:../FreeRTOS_Source/tasks.c **** 			without the overhead of a separate task.
1916:../FreeRTOS_Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:../FreeRTOS_Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:../FreeRTOS_Source/tasks.c **** 			vApplicationIdleHook();
1919:../FreeRTOS_Source/tasks.c **** 		}
1920:../FreeRTOS_Source/tasks.c **** 		#endif
1921:../FreeRTOS_Source/tasks.c **** 	}
 2867              		.loc 1 1921 0
 2868 000a 00BF     		nop
 2869              	.L151:
1879:../FreeRTOS_Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2870              		.loc 1 1879 0
 2871 000c FFF7FEFF 		bl	prvCheckTasksWaitingTermination
1902:../FreeRTOS_Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2872              		.loc 1 1902 0
 2873 0010 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2874 0014 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2875 0018 1B68     		ldr	r3, [r3, #0]
 2876 001a 012B     		cmp	r3, #1
 2877 001c F5D9     		bls	.L152
1904:../FreeRTOS_Source/tasks.c **** 				taskYIELD();
 2878              		.loc 1 1904 0
 2879 001e FFF7FEFF 		bl	vPortYieldFromISR
 2880              		.loc 1 1921 0
 2881 0022 F2E7     		b	.L152
 2882              		.cfi_endproc
 2883              	.LFE25:
 2885              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2886              		.align	2
 2887              		.thumb
 2888              		.thumb_func
 2890              	prvInitialiseTCBVariables:
 2891              	.LFB26:
1922:../FreeRTOS_Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:../FreeRTOS_Source/tasks.c **** 
1924:../FreeRTOS_Source/tasks.c **** 
1925:../FreeRTOS_Source/tasks.c **** 
1926:../FreeRTOS_Source/tasks.c **** 
1927:../FreeRTOS_Source/tasks.c **** 
1928:../FreeRTOS_Source/tasks.c **** 
1929:../FreeRTOS_Source/tasks.c **** 
1930:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------
1931:../FreeRTOS_Source/tasks.c ****  * File private functions documented at the top of the file.
1932:../FreeRTOS_Source/tasks.c ****  *----------------------------------------------------------*/
1933:../FreeRTOS_Source/tasks.c **** 
1934:../FreeRTOS_Source/tasks.c **** 
1935:../FreeRTOS_Source/tasks.c **** 
1936:../FreeRTOS_Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1937:../FreeRTOS_Source/tasks.c **** {
 2892              		.loc 1 1937 0
 2893              		.cfi_startproc
 2894              		@ args = 4, pretend = 0, frame = 16
 2895              		@ frame_needed = 1, uses_anonymous_args = 0
 2896 0000 80B5     		push	{r7, lr}
 2897              	.LCFI74:
 2898              		.cfi_def_cfa_offset 8
 2899              		.cfi_offset 14, -4
 2900              		.cfi_offset 7, -8
 2901 0002 84B0     		sub	sp, sp, #16
 2902              	.LCFI75:
 2903              		.cfi_def_cfa_offset 24
 2904 0004 00AF     		add	r7, sp, #0
 2905              	.LCFI76:
 2906              		.cfi_def_cfa_register 7
 2907 0006 F860     		str	r0, [r7, #12]
 2908 0008 B960     		str	r1, [r7, #8]
 2909 000a 7A60     		str	r2, [r7, #4]
 2910 000c 3B60     		str	r3, [r7, #0]
1938:../FreeRTOS_Source/tasks.c **** 	/* Store the function name in the TCB. */
1939:../FreeRTOS_Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1940:../FreeRTOS_Source/tasks.c **** 	{
1941:../FreeRTOS_Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1942:../FreeRTOS_Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2911              		.loc 1 1942 0
 2912 000e FB68     		ldr	r3, [r7, #12]
 2913 0010 03F13403 		add	r3, r3, #52
 2914 0014 1846     		mov	r0, r3
 2915 0016 B968     		ldr	r1, [r7, #8]
 2916 0018 4FF00A02 		mov	r2, #10
 2917 001c FFF7FEFF 		bl	strncpy
1943:../FreeRTOS_Source/tasks.c **** 	}
1944:../FreeRTOS_Source/tasks.c **** 	#endif
1945:../FreeRTOS_Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2918              		.loc 1 1945 0
 2919 0020 FB68     		ldr	r3, [r7, #12]
 2920 0022 4FF00002 		mov	r2, #0
 2921 0026 83F83D20 		strb	r2, [r3, #61]
1946:../FreeRTOS_Source/tasks.c **** 
1947:../FreeRTOS_Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1948:../FreeRTOS_Source/tasks.c **** 	remove the privilege bit if one is present. */
1949:../FreeRTOS_Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2922              		.loc 1 1949 0
 2923 002a 7B68     		ldr	r3, [r7, #4]
 2924 002c 012B     		cmp	r3, #1
 2925 002e 02D9     		bls	.L154
1950:../FreeRTOS_Source/tasks.c **** 	{
1951:../FreeRTOS_Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2926              		.loc 1 1951 0
 2927 0030 4FF00103 		mov	r3, #1
 2928 0034 7B60     		str	r3, [r7, #4]
 2929              	.L154:
1952:../FreeRTOS_Source/tasks.c **** 	}
1953:../FreeRTOS_Source/tasks.c **** 
1954:../FreeRTOS_Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2930              		.loc 1 1954 0
 2931 0036 FB68     		ldr	r3, [r7, #12]
 2932 0038 7A68     		ldr	r2, [r7, #4]
 2933 003a DA62     		str	r2, [r3, #44]
1955:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1956:../FreeRTOS_Source/tasks.c **** 	{
1957:../FreeRTOS_Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2934              		.loc 1 1957 0
 2935 003c FB68     		ldr	r3, [r7, #12]
 2936 003e 7A68     		ldr	r2, [r7, #4]
 2937 0040 1A64     		str	r2, [r3, #64]
1958:../FreeRTOS_Source/tasks.c **** 	}
1959:../FreeRTOS_Source/tasks.c **** 	#endif
1960:../FreeRTOS_Source/tasks.c **** 
1961:../FreeRTOS_Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2938              		.loc 1 1961 0
 2939 0042 FB68     		ldr	r3, [r7, #12]
 2940 0044 03F10403 		add	r3, r3, #4
 2941 0048 1846     		mov	r0, r3
 2942 004a FFF7FEFF 		bl	vListInitialiseItem
1962:../FreeRTOS_Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2943              		.loc 1 1962 0
 2944 004e FB68     		ldr	r3, [r7, #12]
 2945 0050 03F11803 		add	r3, r3, #24
 2946 0054 1846     		mov	r0, r3
 2947 0056 FFF7FEFF 		bl	vListInitialiseItem
1963:../FreeRTOS_Source/tasks.c **** 
1964:../FreeRTOS_Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:../FreeRTOS_Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1966:../FreeRTOS_Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2948              		.loc 1 1966 0
 2949 005a FB68     		ldr	r3, [r7, #12]
 2950 005c FA68     		ldr	r2, [r7, #12]
 2951 005e 1A61     		str	r2, [r3, #16]
1967:../FreeRTOS_Source/tasks.c **** 
1968:../FreeRTOS_Source/tasks.c **** 	/* Event lists are always in priority order. */
1969:../FreeRTOS_Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2952              		.loc 1 1969 0
 2953 0060 7B68     		ldr	r3, [r7, #4]
 2954 0062 C3F10202 		rsb	r2, r3, #2
 2955 0066 FB68     		ldr	r3, [r7, #12]
 2956 0068 9A61     		str	r2, [r3, #24]
1970:../FreeRTOS_Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2957              		.loc 1 1970 0
 2958 006a FB68     		ldr	r3, [r7, #12]
 2959 006c FA68     		ldr	r2, [r7, #12]
 2960 006e 5A62     		str	r2, [r3, #36]
1971:../FreeRTOS_Source/tasks.c **** 
1972:../FreeRTOS_Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:../FreeRTOS_Source/tasks.c **** 	{
1974:../FreeRTOS_Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:../FreeRTOS_Source/tasks.c **** 	}
1976:../FreeRTOS_Source/tasks.c **** 	#endif
1977:../FreeRTOS_Source/tasks.c **** 
1978:../FreeRTOS_Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:../FreeRTOS_Source/tasks.c **** 	{
1980:../FreeRTOS_Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1981:../FreeRTOS_Source/tasks.c **** 	}
1982:../FreeRTOS_Source/tasks.c **** 	#endif
1983:../FreeRTOS_Source/tasks.c **** 
1984:../FreeRTOS_Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:../FreeRTOS_Source/tasks.c **** 	{
1986:../FreeRTOS_Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1987:../FreeRTOS_Source/tasks.c **** 	}
1988:../FreeRTOS_Source/tasks.c **** 	#endif
1989:../FreeRTOS_Source/tasks.c **** 
1990:../FreeRTOS_Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:../FreeRTOS_Source/tasks.c **** 	{
1992:../FreeRTOS_Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:../FreeRTOS_Source/tasks.c **** 	}
1994:../FreeRTOS_Source/tasks.c **** 	#else
1995:../FreeRTOS_Source/tasks.c **** 	{
1996:../FreeRTOS_Source/tasks.c **** 		( void ) xRegions;
1997:../FreeRTOS_Source/tasks.c **** 		( void ) usStackDepth;
1998:../FreeRTOS_Source/tasks.c **** 	}
1999:../FreeRTOS_Source/tasks.c **** 	#endif
2000:../FreeRTOS_Source/tasks.c **** }
 2961              		.loc 1 2000 0
 2962 0070 07F11007 		add	r7, r7, #16
 2963 0074 BD46     		mov	sp, r7
 2964 0076 80BD     		pop	{r7, pc}
 2965              		.cfi_endproc
 2966              	.LFE26:
 2968              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 2969              		.align	2
 2970              		.thumb
 2971              		.thumb_func
 2973              	prvInitialiseTaskLists:
 2974              	.LFB27:
2001:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2002:../FreeRTOS_Source/tasks.c **** 
2003:../FreeRTOS_Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2004:../FreeRTOS_Source/tasks.c **** 
2005:../FreeRTOS_Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:../FreeRTOS_Source/tasks.c **** 	{
2007:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
2008:../FreeRTOS_Source/tasks.c **** 	
2009:../FreeRTOS_Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2010:../FreeRTOS_Source/tasks.c **** 		{
2011:../FreeRTOS_Source/tasks.c **** 			xTaskToModify = NULL;
2012:../FreeRTOS_Source/tasks.c **** 		}
2013:../FreeRTOS_Source/tasks.c **** 
2014:../FreeRTOS_Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2015:../FreeRTOS_Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:../FreeRTOS_Source/tasks.c **** 
2017:../FreeRTOS_Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:../FreeRTOS_Source/tasks.c **** 	}
2019:../FreeRTOS_Source/tasks.c **** 	/*-----------------------------------------------------------*/
2020:../FreeRTOS_Source/tasks.c **** #endif
2021:../FreeRTOS_Source/tasks.c **** 
2022:../FreeRTOS_Source/tasks.c **** static void prvInitialiseTaskLists( void )
2023:../FreeRTOS_Source/tasks.c **** {
 2975              		.loc 1 2023 0
 2976              		.cfi_startproc
 2977              		@ args = 0, pretend = 0, frame = 8
 2978              		@ frame_needed = 1, uses_anonymous_args = 0
 2979 0000 80B5     		push	{r7, lr}
 2980              	.LCFI77:
 2981              		.cfi_def_cfa_offset 8
 2982              		.cfi_offset 14, -4
 2983              		.cfi_offset 7, -8
 2984 0002 82B0     		sub	sp, sp, #8
 2985              	.LCFI78:
 2986              		.cfi_def_cfa_offset 16
 2987 0004 00AF     		add	r7, sp, #0
 2988              	.LCFI79:
 2989              		.cfi_def_cfa_register 7
2024:../FreeRTOS_Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2025:../FreeRTOS_Source/tasks.c **** 
2026:../FreeRTOS_Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2990              		.loc 1 2026 0
 2991 0006 4FF00003 		mov	r3, #0
 2992 000a 7B60     		str	r3, [r7, #4]
 2993 000c 13E0     		b	.L156
 2994              	.L157:
2027:../FreeRTOS_Source/tasks.c **** 	{
2028:../FreeRTOS_Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 2995              		.loc 1 2028 0 discriminator 2
 2996 000e 7A68     		ldr	r2, [r7, #4]
 2997 0010 1346     		mov	r3, r2
 2998 0012 4FEA8303 		lsl	r3, r3, #2
 2999 0016 9B18     		adds	r3, r3, r2
 3000 0018 4FEA8303 		lsl	r3, r3, #2
 3001 001c 1A46     		mov	r2, r3
 3002 001e 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3003 0022 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3004 0026 D318     		adds	r3, r2, r3
 3005 0028 1846     		mov	r0, r3
 3006 002a FFF7FEFF 		bl	vListInitialise
2026:../FreeRTOS_Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3007              		.loc 1 2026 0 discriminator 2
 3008 002e 7B68     		ldr	r3, [r7, #4]
 3009 0030 03F10103 		add	r3, r3, #1
 3010 0034 7B60     		str	r3, [r7, #4]
 3011              	.L156:
2026:../FreeRTOS_Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3012              		.loc 1 2026 0 is_stmt 0 discriminator 1
 3013 0036 7B68     		ldr	r3, [r7, #4]
 3014 0038 012B     		cmp	r3, #1
 3015 003a E8D9     		bls	.L157
2029:../FreeRTOS_Source/tasks.c **** 	}
2030:../FreeRTOS_Source/tasks.c **** 
2031:../FreeRTOS_Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3016              		.loc 1 2031 0 is_stmt 1
 3017 003c 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 3018 0040 C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 3019 0044 FFF7FEFF 		bl	vListInitialise
2032:../FreeRTOS_Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3020              		.loc 1 2032 0
 3021 0048 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 3022 004c C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 3023 0050 FFF7FEFF 		bl	vListInitialise
2033:../FreeRTOS_Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3024              		.loc 1 2033 0
 3025 0054 40F20000 		movw	r0, #:lower16:xPendingReadyList
 3026 0058 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 3027 005c FFF7FEFF 		bl	vListInitialise
2034:../FreeRTOS_Source/tasks.c **** 
2035:../FreeRTOS_Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2036:../FreeRTOS_Source/tasks.c **** 	{
2037:../FreeRTOS_Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3028              		.loc 1 2037 0
 3029 0060 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 3030 0064 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 3031 0068 FFF7FEFF 		bl	vListInitialise
2038:../FreeRTOS_Source/tasks.c **** 	}
2039:../FreeRTOS_Source/tasks.c **** 	#endif
2040:../FreeRTOS_Source/tasks.c **** 
2041:../FreeRTOS_Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2042:../FreeRTOS_Source/tasks.c **** 	{
2043:../FreeRTOS_Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3032              		.loc 1 2043 0
 3033 006c 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 3034 0070 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 3035 0074 FFF7FEFF 		bl	vListInitialise
2044:../FreeRTOS_Source/tasks.c **** 	}
2045:../FreeRTOS_Source/tasks.c **** 	#endif
2046:../FreeRTOS_Source/tasks.c **** 
2047:../FreeRTOS_Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:../FreeRTOS_Source/tasks.c **** 	using list2. */
2049:../FreeRTOS_Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3036              		.loc 1 2049 0
 3037 0078 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3038 007c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3039 0080 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 3040 0084 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 3041 0088 1A60     		str	r2, [r3, #0]
2050:../FreeRTOS_Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3042              		.loc 1 2050 0
 3043 008a 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3044 008e C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3045 0092 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 3046 0096 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 3047 009a 1A60     		str	r2, [r3, #0]
2051:../FreeRTOS_Source/tasks.c **** }
 3048              		.loc 1 2051 0
 3049 009c 07F10807 		add	r7, r7, #8
 3050 00a0 BD46     		mov	sp, r7
 3051 00a2 80BD     		pop	{r7, pc}
 3052              		.cfi_endproc
 3053              	.LFE27:
 3055              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3056              		.align	2
 3057              		.thumb
 3058              		.thumb_func
 3060              	prvCheckTasksWaitingTermination:
 3061              	.LFB28:
2052:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2053:../FreeRTOS_Source/tasks.c **** 
2054:../FreeRTOS_Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2055:../FreeRTOS_Source/tasks.c **** {
 3062              		.loc 1 2055 0
 3063              		.cfi_startproc
 3064              		@ args = 0, pretend = 0, frame = 8
 3065              		@ frame_needed = 1, uses_anonymous_args = 0
 3066 0000 80B5     		push	{r7, lr}
 3067              	.LCFI80:
 3068              		.cfi_def_cfa_offset 8
 3069              		.cfi_offset 14, -4
 3070              		.cfi_offset 7, -8
 3071 0002 82B0     		sub	sp, sp, #8
 3072              	.LCFI81:
 3073              		.cfi_def_cfa_offset 16
 3074 0004 00AF     		add	r7, sp, #0
 3075              	.LCFI82:
 3076              		.cfi_def_cfa_register 7
 3077              	.LBB7:
2056:../FreeRTOS_Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2057:../FreeRTOS_Source/tasks.c **** 	{
2058:../FreeRTOS_Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2059:../FreeRTOS_Source/tasks.c **** 
2060:../FreeRTOS_Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:../FreeRTOS_Source/tasks.c **** 		too often in the idle task. */
2062:../FreeRTOS_Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3078              		.loc 1 2062 0
 3079 0006 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3080 000a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3081 000e 1B68     		ldr	r3, [r3, #0]
 3082 0010 002B     		cmp	r3, #0
 3083 0012 3CD0     		beq	.L158
2063:../FreeRTOS_Source/tasks.c **** 		{
2064:../FreeRTOS_Source/tasks.c **** 			vTaskSuspendAll();
 3084              		.loc 1 2064 0
 3085 0014 FFF7FEFF 		bl	vTaskSuspendAll
2065:../FreeRTOS_Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3086              		.loc 1 2065 0
 3087 0018 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3088 001c C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3089 0020 1B68     		ldr	r3, [r3, #0]
 3090 0022 002B     		cmp	r3, #0
 3091 0024 14BF     		ite	ne
 3092 0026 0023     		movne	r3, #0
 3093 0028 0123     		moveq	r3, #1
 3094 002a 7B60     		str	r3, [r7, #4]
2066:../FreeRTOS_Source/tasks.c **** 			xTaskResumeAll();
 3095              		.loc 1 2066 0
 3096 002c FFF7FEFF 		bl	xTaskResumeAll
2067:../FreeRTOS_Source/tasks.c **** 
2068:../FreeRTOS_Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3097              		.loc 1 2068 0
 3098 0030 7B68     		ldr	r3, [r7, #4]
 3099 0032 002B     		cmp	r3, #0
 3100 0034 2BD1     		bne	.L158
 3101              	.LBB8:
2069:../FreeRTOS_Source/tasks.c **** 			{
2070:../FreeRTOS_Source/tasks.c **** 				tskTCB *pxTCB;
2071:../FreeRTOS_Source/tasks.c **** 
2072:../FreeRTOS_Source/tasks.c **** 				taskENTER_CRITICAL();
 3102              		.loc 1 2072 0
 3103 0036 FFF7FEFF 		bl	vPortEnterCritical
2073:../FreeRTOS_Source/tasks.c **** 				{
2074:../FreeRTOS_Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3104              		.loc 1 2074 0
 3105 003a 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3106 003e C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3107 0042 DB68     		ldr	r3, [r3, #12]
 3108 0044 DB68     		ldr	r3, [r3, #12]
 3109 0046 3B60     		str	r3, [r7, #0]
2075:../FreeRTOS_Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3110              		.loc 1 2075 0
 3111 0048 3B68     		ldr	r3, [r7, #0]
 3112 004a 03F10403 		add	r3, r3, #4
 3113 004e 1846     		mov	r0, r3
 3114 0050 FFF7FEFF 		bl	vListRemove
2076:../FreeRTOS_Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3115              		.loc 1 2076 0
 3116 0054 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3117 0058 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3118 005c 1B68     		ldr	r3, [r3, #0]
 3119 005e 03F1FF32 		add	r2, r3, #-1
 3120 0062 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3121 0066 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3122 006a 1A60     		str	r2, [r3, #0]
2077:../FreeRTOS_Source/tasks.c **** 					--uxTasksDeleted;
 3123              		.loc 1 2077 0
 3124 006c 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3125 0070 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3126 0074 1B68     		ldr	r3, [r3, #0]
 3127 0076 03F1FF32 		add	r2, r3, #-1
 3128 007a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3129 007e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3130 0082 1A60     		str	r2, [r3, #0]
2078:../FreeRTOS_Source/tasks.c **** 				}
2079:../FreeRTOS_Source/tasks.c **** 				taskEXIT_CRITICAL();
 3131              		.loc 1 2079 0
 3132 0084 FFF7FEFF 		bl	vPortExitCritical
2080:../FreeRTOS_Source/tasks.c **** 
2081:../FreeRTOS_Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3133              		.loc 1 2081 0
 3134 0088 3868     		ldr	r0, [r7, #0]
 3135 008a FFF7FEFF 		bl	prvDeleteTCB
 3136              	.L158:
 3137              	.LBE8:
 3138              	.LBE7:
2082:../FreeRTOS_Source/tasks.c **** 			}
2083:../FreeRTOS_Source/tasks.c **** 		}
2084:../FreeRTOS_Source/tasks.c **** 	}
2085:../FreeRTOS_Source/tasks.c **** 	#endif
2086:../FreeRTOS_Source/tasks.c **** }
 3139              		.loc 1 2086 0
 3140 008e 07F10807 		add	r7, r7, #8
 3141 0092 BD46     		mov	sp, r7
 3142 0094 80BD     		pop	{r7, pc}
 3143              		.cfi_endproc
 3144              	.LFE28:
 3146 0096 00BF     		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3147              		.align	2
 3148              		.thumb
 3149              		.thumb_func
 3151              	prvAddCurrentTaskToDelayedList:
 3152              	.LFB29:
2087:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2088:../FreeRTOS_Source/tasks.c **** 
2089:../FreeRTOS_Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:../FreeRTOS_Source/tasks.c **** {
 3153              		.loc 1 2090 0
 3154              		.cfi_startproc
 3155              		@ args = 0, pretend = 0, frame = 8
 3156              		@ frame_needed = 1, uses_anonymous_args = 0
 3157 0000 80B5     		push	{r7, lr}
 3158              	.LCFI83:
 3159              		.cfi_def_cfa_offset 8
 3160              		.cfi_offset 14, -4
 3161              		.cfi_offset 7, -8
 3162 0002 82B0     		sub	sp, sp, #8
 3163              	.LCFI84:
 3164              		.cfi_def_cfa_offset 16
 3165 0004 00AF     		add	r7, sp, #0
 3166              	.LCFI85:
 3167              		.cfi_def_cfa_register 7
 3168 0006 7860     		str	r0, [r7, #4]
2091:../FreeRTOS_Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2092:../FreeRTOS_Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3169              		.loc 1 2092 0
 3170 0008 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3171 000c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3172 0010 1B68     		ldr	r3, [r3, #0]
 3173 0012 7A68     		ldr	r2, [r7, #4]
 3174 0014 5A60     		str	r2, [r3, #4]
2093:../FreeRTOS_Source/tasks.c **** 
2094:../FreeRTOS_Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3175              		.loc 1 2094 0
 3176 0016 40F20003 		movw	r3, #:lower16:xTickCount
 3177 001a C0F20003 		movt	r3, #:upper16:xTickCount
 3178 001e 1B68     		ldr	r3, [r3, #0]
 3179 0020 7A68     		ldr	r2, [r7, #4]
 3180 0022 9A42     		cmp	r2, r3
 3181 0024 10D2     		bcs	.L161
2095:../FreeRTOS_Source/tasks.c **** 	{
2096:../FreeRTOS_Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:../FreeRTOS_Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3182              		.loc 1 2097 0
 3183 0026 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3184 002a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3185 002e 1A68     		ldr	r2, [r3, #0]
 3186 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3187 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3188 0038 1B68     		ldr	r3, [r3, #0]
 3189 003a 03F10403 		add	r3, r3, #4
 3190 003e 1046     		mov	r0, r2
 3191 0040 1946     		mov	r1, r3
 3192 0042 FFF7FEFF 		bl	vListInsert
 3193 0046 1DE0     		b	.L160
 3194              	.L161:
2098:../FreeRTOS_Source/tasks.c **** 	}
2099:../FreeRTOS_Source/tasks.c **** 	else
2100:../FreeRTOS_Source/tasks.c **** 	{
2101:../FreeRTOS_Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2102:../FreeRTOS_Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3195              		.loc 1 2102 0
 3196 0048 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3197 004c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3198 0050 1A68     		ldr	r2, [r3, #0]
 3199 0052 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3200 0056 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3201 005a 1B68     		ldr	r3, [r3, #0]
 3202 005c 03F10403 		add	r3, r3, #4
 3203 0060 1046     		mov	r0, r2
 3204 0062 1946     		mov	r1, r3
 3205 0064 FFF7FEFF 		bl	vListInsert
2103:../FreeRTOS_Source/tasks.c **** 
2104:../FreeRTOS_Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2105:../FreeRTOS_Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:../FreeRTOS_Source/tasks.c **** 		too. */
2107:../FreeRTOS_Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3206              		.loc 1 2107 0
 3207 0068 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3208 006c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3209 0070 1B68     		ldr	r3, [r3, #0]
 3210 0072 7A68     		ldr	r2, [r7, #4]
 3211 0074 9A42     		cmp	r2, r3
 3212 0076 05D2     		bcs	.L160
2108:../FreeRTOS_Source/tasks.c **** 		{
2109:../FreeRTOS_Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3213              		.loc 1 2109 0
 3214 0078 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3215 007c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3216 0080 7A68     		ldr	r2, [r7, #4]
 3217 0082 1A60     		str	r2, [r3, #0]
 3218              	.L160:
2110:../FreeRTOS_Source/tasks.c **** 		}
2111:../FreeRTOS_Source/tasks.c **** 	}
2112:../FreeRTOS_Source/tasks.c **** }
 3219              		.loc 1 2112 0
 3220 0084 07F10807 		add	r7, r7, #8
 3221 0088 BD46     		mov	sp, r7
 3222 008a 80BD     		pop	{r7, pc}
 3223              		.cfi_endproc
 3224              	.LFE29:
 3226              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3227              		.align	2
 3228              		.thumb
 3229              		.thumb_func
 3231              	prvAllocateTCBAndStack:
 3232              	.LFB30:
2113:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2114:../FreeRTOS_Source/tasks.c **** 
2115:../FreeRTOS_Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2116:../FreeRTOS_Source/tasks.c **** {
 3233              		.loc 1 2116 0
 3234              		.cfi_startproc
 3235              		@ args = 0, pretend = 0, frame = 16
 3236              		@ frame_needed = 1, uses_anonymous_args = 0
 3237 0000 80B5     		push	{r7, lr}
 3238              	.LCFI86:
 3239              		.cfi_def_cfa_offset 8
 3240              		.cfi_offset 14, -4
 3241              		.cfi_offset 7, -8
 3242 0002 84B0     		sub	sp, sp, #16
 3243              	.LCFI87:
 3244              		.cfi_def_cfa_offset 24
 3245 0004 00AF     		add	r7, sp, #0
 3246              	.LCFI88:
 3247              		.cfi_def_cfa_register 7
 3248 0006 0346     		mov	r3, r0
 3249 0008 3960     		str	r1, [r7, #0]
 3250 000a FB80     		strh	r3, [r7, #6]	@ movhi
2117:../FreeRTOS_Source/tasks.c **** tskTCB *pxNewTCB;
2118:../FreeRTOS_Source/tasks.c **** 
2119:../FreeRTOS_Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:../FreeRTOS_Source/tasks.c **** 	the implementation of the port malloc function. */
2121:../FreeRTOS_Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3251              		.loc 1 2121 0
 3252 000c 4FF04400 		mov	r0, #68
 3253 0010 FFF7FEFF 		bl	pvPortMalloc
 3254 0014 F860     		str	r0, [r7, #12]
2122:../FreeRTOS_Source/tasks.c **** 
2123:../FreeRTOS_Source/tasks.c **** 	if( pxNewTCB != NULL )
 3255              		.loc 1 2123 0
 3256 0016 FB68     		ldr	r3, [r7, #12]
 3257 0018 002B     		cmp	r3, #0
 3258 001a 23D0     		beq	.L164
2124:../FreeRTOS_Source/tasks.c **** 	{
2125:../FreeRTOS_Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2126:../FreeRTOS_Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2127:../FreeRTOS_Source/tasks.c **** 		be deleted later if required. */
2128:../FreeRTOS_Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3259              		.loc 1 2128 0
 3260 001c 3B68     		ldr	r3, [r7, #0]
 3261 001e 002B     		cmp	r3, #0
 3262 0020 07D1     		bne	.L165
 3263              		.loc 1 2128 0 is_stmt 0 discriminator 1
 3264 0022 FB88     		ldrh	r3, [r7, #6]
 3265 0024 4FEA8303 		lsl	r3, r3, #2
 3266 0028 1846     		mov	r0, r3
 3267 002a FFF7FEFF 		bl	pvPortMalloc
 3268 002e 0346     		mov	r3, r0
 3269 0030 00E0     		b	.L166
 3270              	.L165:
 3271              		.loc 1 2128 0 discriminator 2
 3272 0032 3B68     		ldr	r3, [r7, #0]
 3273              	.L166:
 3274              		.loc 1 2128 0 discriminator 3
 3275 0034 FA68     		ldr	r2, [r7, #12]
 3276 0036 1363     		str	r3, [r2, #48]
2129:../FreeRTOS_Source/tasks.c **** 
2130:../FreeRTOS_Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3277              		.loc 1 2130 0 is_stmt 1 discriminator 3
 3278 0038 FB68     		ldr	r3, [r7, #12]
 3279 003a 1B6B     		ldr	r3, [r3, #48]
 3280 003c 002B     		cmp	r3, #0
 3281 003e 06D1     		bne	.L167
2131:../FreeRTOS_Source/tasks.c **** 		{
2132:../FreeRTOS_Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:../FreeRTOS_Source/tasks.c **** 			vPortFree( pxNewTCB );
 3282              		.loc 1 2133 0
 3283 0040 F868     		ldr	r0, [r7, #12]
 3284 0042 FFF7FEFF 		bl	vPortFree
2134:../FreeRTOS_Source/tasks.c **** 			pxNewTCB = NULL;
 3285              		.loc 1 2134 0
 3286 0046 4FF00003 		mov	r3, #0
 3287 004a FB60     		str	r3, [r7, #12]
 3288 004c 0AE0     		b	.L164
 3289              	.L167:
2135:../FreeRTOS_Source/tasks.c **** 		}
2136:../FreeRTOS_Source/tasks.c **** 		else
2137:../FreeRTOS_Source/tasks.c **** 		{
2138:../FreeRTOS_Source/tasks.c **** 			/* Just to help debugging. */
2139:../FreeRTOS_Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3290              		.loc 1 2139 0
 3291 004e FB68     		ldr	r3, [r7, #12]
 3292 0050 1A6B     		ldr	r2, [r3, #48]
 3293 0052 FB88     		ldrh	r3, [r7, #6]
 3294 0054 4FEA8303 		lsl	r3, r3, #2
 3295 0058 1046     		mov	r0, r2
 3296 005a 4FF0A501 		mov	r1, #165
 3297 005e 1A46     		mov	r2, r3
 3298 0060 FFF7FEFF 		bl	memset
 3299              	.L164:
2140:../FreeRTOS_Source/tasks.c **** 		}
2141:../FreeRTOS_Source/tasks.c **** 	}
2142:../FreeRTOS_Source/tasks.c **** 
2143:../FreeRTOS_Source/tasks.c **** 	return pxNewTCB;
 3300              		.loc 1 2143 0
 3301 0064 FB68     		ldr	r3, [r7, #12]
2144:../FreeRTOS_Source/tasks.c **** }
 3302              		.loc 1 2144 0
 3303 0066 1846     		mov	r0, r3
 3304 0068 07F11007 		add	r7, r7, #16
 3305 006c BD46     		mov	sp, r7
 3306 006e 80BD     		pop	{r7, pc}
 3307              		.cfi_endproc
 3308              	.LFE30:
 3310              		.section	.text.prvDeleteTCB,"ax",%progbits
 3311              		.align	2
 3312              		.thumb
 3313              		.thumb_func
 3315              	prvDeleteTCB:
 3316              	.LFB31:
2145:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2146:../FreeRTOS_Source/tasks.c **** 
2147:../FreeRTOS_Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2148:../FreeRTOS_Source/tasks.c **** 
2149:../FreeRTOS_Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2150:../FreeRTOS_Source/tasks.c **** 	{
2151:../FreeRTOS_Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:../FreeRTOS_Source/tasks.c **** 	unsigned short usStackRemaining;
2153:../FreeRTOS_Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:../FreeRTOS_Source/tasks.c **** 
2155:../FreeRTOS_Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2156:../FreeRTOS_Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2157:../FreeRTOS_Source/tasks.c **** 		do
2158:../FreeRTOS_Source/tasks.c **** 		{
2159:../FreeRTOS_Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2160:../FreeRTOS_Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2161:../FreeRTOS_Source/tasks.c **** 			{
2162:../FreeRTOS_Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:../FreeRTOS_Source/tasks.c **** 			}
2164:../FreeRTOS_Source/tasks.c **** 			#else
2165:../FreeRTOS_Source/tasks.c **** 			{
2166:../FreeRTOS_Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2167:../FreeRTOS_Source/tasks.c **** 			}
2168:../FreeRTOS_Source/tasks.c **** 			#endif			
2169:../FreeRTOS_Source/tasks.c **** 			
2170:../FreeRTOS_Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2171:../FreeRTOS_Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2172:../FreeRTOS_Source/tasks.c **** 
2173:../FreeRTOS_Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2174:../FreeRTOS_Source/tasks.c **** 	}
2175:../FreeRTOS_Source/tasks.c **** 
2176:../FreeRTOS_Source/tasks.c **** #endif
2177:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2178:../FreeRTOS_Source/tasks.c **** 
2179:../FreeRTOS_Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:../FreeRTOS_Source/tasks.c **** 
2181:../FreeRTOS_Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2182:../FreeRTOS_Source/tasks.c **** 	{
2183:../FreeRTOS_Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:../FreeRTOS_Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2185:../FreeRTOS_Source/tasks.c **** 
2186:../FreeRTOS_Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:../FreeRTOS_Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2188:../FreeRTOS_Source/tasks.c **** 		do
2189:../FreeRTOS_Source/tasks.c **** 		{
2190:../FreeRTOS_Source/tasks.c **** 			/* Get next TCB in from the list. */
2191:../FreeRTOS_Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2192:../FreeRTOS_Source/tasks.c **** 
2193:../FreeRTOS_Source/tasks.c **** 			/* Divide by zero check. */
2194:../FreeRTOS_Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2195:../FreeRTOS_Source/tasks.c **** 			{
2196:../FreeRTOS_Source/tasks.c **** 				/* Has the task run at all? */
2197:../FreeRTOS_Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2198:../FreeRTOS_Source/tasks.c **** 				{
2199:../FreeRTOS_Source/tasks.c **** 					/* The task has used no CPU time at all. */
2200:../FreeRTOS_Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2201:../FreeRTOS_Source/tasks.c **** 				}
2202:../FreeRTOS_Source/tasks.c **** 				else
2203:../FreeRTOS_Source/tasks.c **** 				{
2204:../FreeRTOS_Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2205:../FreeRTOS_Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2206:../FreeRTOS_Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2207:../FreeRTOS_Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2208:../FreeRTOS_Source/tasks.c **** 
2209:../FreeRTOS_Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2210:../FreeRTOS_Source/tasks.c **** 					{
2211:../FreeRTOS_Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:../FreeRTOS_Source/tasks.c **** 						{
2213:../FreeRTOS_Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2214:../FreeRTOS_Source/tasks.c **** 						}
2215:../FreeRTOS_Source/tasks.c **** 						#else
2216:../FreeRTOS_Source/tasks.c **** 						{
2217:../FreeRTOS_Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2218:../FreeRTOS_Source/tasks.c **** 							printf() library can be used. */
2219:../FreeRTOS_Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2220:../FreeRTOS_Source/tasks.c **** 						}
2221:../FreeRTOS_Source/tasks.c **** 						#endif
2222:../FreeRTOS_Source/tasks.c **** 					}
2223:../FreeRTOS_Source/tasks.c **** 					else
2224:../FreeRTOS_Source/tasks.c **** 					{
2225:../FreeRTOS_Source/tasks.c **** 						/* If the percentage is zero here then the task has
2226:../FreeRTOS_Source/tasks.c **** 						consumed less than 1% of the total run time. */
2227:../FreeRTOS_Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:../FreeRTOS_Source/tasks.c **** 						{
2229:../FreeRTOS_Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2230:../FreeRTOS_Source/tasks.c **** 						}
2231:../FreeRTOS_Source/tasks.c **** 						#else
2232:../FreeRTOS_Source/tasks.c **** 						{
2233:../FreeRTOS_Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2234:../FreeRTOS_Source/tasks.c **** 							printf() library can be used. */
2235:../FreeRTOS_Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2236:../FreeRTOS_Source/tasks.c **** 						}
2237:../FreeRTOS_Source/tasks.c **** 						#endif
2238:../FreeRTOS_Source/tasks.c **** 					}
2239:../FreeRTOS_Source/tasks.c **** 				}
2240:../FreeRTOS_Source/tasks.c **** 
2241:../FreeRTOS_Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2242:../FreeRTOS_Source/tasks.c **** 			}
2243:../FreeRTOS_Source/tasks.c **** 
2244:../FreeRTOS_Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2245:../FreeRTOS_Source/tasks.c **** 	}
2246:../FreeRTOS_Source/tasks.c **** 
2247:../FreeRTOS_Source/tasks.c **** #endif
2248:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2249:../FreeRTOS_Source/tasks.c **** 
2250:../FreeRTOS_Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:../FreeRTOS_Source/tasks.c **** 
2252:../FreeRTOS_Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:../FreeRTOS_Source/tasks.c **** 	{
2254:../FreeRTOS_Source/tasks.c **** 	register unsigned short usCount = 0U;
2255:../FreeRTOS_Source/tasks.c **** 
2256:../FreeRTOS_Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2257:../FreeRTOS_Source/tasks.c **** 		{
2258:../FreeRTOS_Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2259:../FreeRTOS_Source/tasks.c **** 			usCount++;
2260:../FreeRTOS_Source/tasks.c **** 		}
2261:../FreeRTOS_Source/tasks.c **** 
2262:../FreeRTOS_Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2263:../FreeRTOS_Source/tasks.c **** 
2264:../FreeRTOS_Source/tasks.c **** 		return usCount;
2265:../FreeRTOS_Source/tasks.c **** 	}
2266:../FreeRTOS_Source/tasks.c **** 
2267:../FreeRTOS_Source/tasks.c **** #endif
2268:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2269:../FreeRTOS_Source/tasks.c **** 
2270:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:../FreeRTOS_Source/tasks.c **** 
2272:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:../FreeRTOS_Source/tasks.c **** 	{
2274:../FreeRTOS_Source/tasks.c **** 	tskTCB *pxTCB;
2275:../FreeRTOS_Source/tasks.c **** 	unsigned char *pcEndOfStack;
2276:../FreeRTOS_Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2277:../FreeRTOS_Source/tasks.c **** 
2278:../FreeRTOS_Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2279:../FreeRTOS_Source/tasks.c **** 
2280:../FreeRTOS_Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2281:../FreeRTOS_Source/tasks.c **** 		{
2282:../FreeRTOS_Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2283:../FreeRTOS_Source/tasks.c **** 		}
2284:../FreeRTOS_Source/tasks.c **** 		#else
2285:../FreeRTOS_Source/tasks.c **** 		{
2286:../FreeRTOS_Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:../FreeRTOS_Source/tasks.c **** 		}
2288:../FreeRTOS_Source/tasks.c **** 		#endif
2289:../FreeRTOS_Source/tasks.c **** 
2290:../FreeRTOS_Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2291:../FreeRTOS_Source/tasks.c **** 
2292:../FreeRTOS_Source/tasks.c **** 		return uxReturn;
2293:../FreeRTOS_Source/tasks.c **** 	}
2294:../FreeRTOS_Source/tasks.c **** 
2295:../FreeRTOS_Source/tasks.c **** #endif
2296:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2297:../FreeRTOS_Source/tasks.c **** 
2298:../FreeRTOS_Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2299:../FreeRTOS_Source/tasks.c **** 
2300:../FreeRTOS_Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2301:../FreeRTOS_Source/tasks.c **** 	{
 3317              		.loc 1 2301 0
 3318              		.cfi_startproc
 3319              		@ args = 0, pretend = 0, frame = 8
 3320              		@ frame_needed = 1, uses_anonymous_args = 0
 3321 0000 80B5     		push	{r7, lr}
 3322              	.LCFI89:
 3323              		.cfi_def_cfa_offset 8
 3324              		.cfi_offset 14, -4
 3325              		.cfi_offset 7, -8
 3326 0002 82B0     		sub	sp, sp, #8
 3327              	.LCFI90:
 3328              		.cfi_def_cfa_offset 16
 3329 0004 00AF     		add	r7, sp, #0
 3330              	.LCFI91:
 3331              		.cfi_def_cfa_register 7
 3332 0006 7860     		str	r0, [r7, #4]
2302:../FreeRTOS_Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2303:../FreeRTOS_Source/tasks.c **** 		above the vPortFree() calls. */
2304:../FreeRTOS_Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2305:../FreeRTOS_Source/tasks.c **** 
2306:../FreeRTOS_Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:../FreeRTOS_Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2308:../FreeRTOS_Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3333              		.loc 1 2308 0
 3334 0008 7B68     		ldr	r3, [r7, #4]
 3335 000a 1B6B     		ldr	r3, [r3, #48]
 3336 000c 1846     		mov	r0, r3
 3337 000e FFF7FEFF 		bl	vPortFree
2309:../FreeRTOS_Source/tasks.c **** 		vPortFree( pxTCB );
 3338              		.loc 1 2309 0
 3339 0012 7868     		ldr	r0, [r7, #4]
 3340 0014 FFF7FEFF 		bl	vPortFree
2310:../FreeRTOS_Source/tasks.c **** 	}
 3341              		.loc 1 2310 0
 3342 0018 07F10807 		add	r7, r7, #8
 3343 001c BD46     		mov	sp, r7
 3344 001e 80BD     		pop	{r7, pc}
 3345              		.cfi_endproc
 3346              	.LFE31:
 3348              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3349              		.align	2
 3350              		.global	xTaskGetCurrentTaskHandle
 3351              		.thumb
 3352              		.thumb_func
 3354              	xTaskGetCurrentTaskHandle:
 3355              	.LFB32:
2311:../FreeRTOS_Source/tasks.c **** 
2312:../FreeRTOS_Source/tasks.c **** #endif
2313:../FreeRTOS_Source/tasks.c **** 
2314:../FreeRTOS_Source/tasks.c **** 
2315:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2316:../FreeRTOS_Source/tasks.c **** 
2317:../FreeRTOS_Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:../FreeRTOS_Source/tasks.c **** 
2319:../FreeRTOS_Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:../FreeRTOS_Source/tasks.c **** 	{
 3356              		.loc 1 2320 0
 3357              		.cfi_startproc
 3358              		@ args = 0, pretend = 0, frame = 8
 3359              		@ frame_needed = 1, uses_anonymous_args = 0
 3360              		@ link register save eliminated.
 3361 0000 80B4     		push	{r7}
 3362              	.LCFI92:
 3363              		.cfi_def_cfa_offset 4
 3364              		.cfi_offset 7, -4
 3365 0002 83B0     		sub	sp, sp, #12
 3366              	.LCFI93:
 3367              		.cfi_def_cfa_offset 16
 3368 0004 00AF     		add	r7, sp, #0
 3369              	.LCFI94:
 3370              		.cfi_def_cfa_register 7
2321:../FreeRTOS_Source/tasks.c **** 	xTaskHandle xReturn;
2322:../FreeRTOS_Source/tasks.c **** 
2323:../FreeRTOS_Source/tasks.c **** 		/* A critical section is not required as this is not called from
2324:../FreeRTOS_Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2325:../FreeRTOS_Source/tasks.c **** 		individual execution thread. */
2326:../FreeRTOS_Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3371              		.loc 1 2326 0
 3372 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3373 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3374 000e 1B68     		ldr	r3, [r3, #0]
 3375 0010 7B60     		str	r3, [r7, #4]
2327:../FreeRTOS_Source/tasks.c **** 
2328:../FreeRTOS_Source/tasks.c **** 		return xReturn;
 3376              		.loc 1 2328 0
 3377 0012 7B68     		ldr	r3, [r7, #4]
2329:../FreeRTOS_Source/tasks.c **** 	}
 3378              		.loc 1 2329 0
 3379 0014 1846     		mov	r0, r3
 3380 0016 07F10C07 		add	r7, r7, #12
 3381 001a BD46     		mov	sp, r7
 3382 001c 80BC     		pop	{r7}
 3383 001e 7047     		bx	lr
 3384              		.cfi_endproc
 3385              	.LFE32:
 3387              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3388              		.align	2
 3389              		.global	xTaskGetSchedulerState
 3390              		.thumb
 3391              		.thumb_func
 3393              	xTaskGetSchedulerState:
 3394              	.LFB33:
2330:../FreeRTOS_Source/tasks.c **** 
2331:../FreeRTOS_Source/tasks.c **** #endif
2332:../FreeRTOS_Source/tasks.c **** 
2333:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2334:../FreeRTOS_Source/tasks.c **** 
2335:../FreeRTOS_Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:../FreeRTOS_Source/tasks.c **** 
2337:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2338:../FreeRTOS_Source/tasks.c **** 	{
 3395              		.loc 1 2338 0
 3396              		.cfi_startproc
 3397              		@ args = 0, pretend = 0, frame = 8
 3398              		@ frame_needed = 1, uses_anonymous_args = 0
 3399              		@ link register save eliminated.
 3400 0000 80B4     		push	{r7}
 3401              	.LCFI95:
 3402              		.cfi_def_cfa_offset 4
 3403              		.cfi_offset 7, -4
 3404 0002 83B0     		sub	sp, sp, #12
 3405              	.LCFI96:
 3406              		.cfi_def_cfa_offset 16
 3407 0004 00AF     		add	r7, sp, #0
 3408              	.LCFI97:
 3409              		.cfi_def_cfa_register 7
2339:../FreeRTOS_Source/tasks.c **** 	portBASE_TYPE xReturn;
2340:../FreeRTOS_Source/tasks.c **** 
2341:../FreeRTOS_Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3410              		.loc 1 2341 0
 3411 0006 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 3412 000a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 3413 000e 1B68     		ldr	r3, [r3, #0]
 3414 0010 002B     		cmp	r3, #0
 3415 0012 03D1     		bne	.L171
2342:../FreeRTOS_Source/tasks.c **** 		{
2343:../FreeRTOS_Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3416              		.loc 1 2343 0
 3417 0014 4FF00003 		mov	r3, #0
 3418 0018 7B60     		str	r3, [r7, #4]
 3419 001a 0DE0     		b	.L172
 3420              	.L171:
2344:../FreeRTOS_Source/tasks.c **** 		}
2345:../FreeRTOS_Source/tasks.c **** 		else
2346:../FreeRTOS_Source/tasks.c **** 		{
2347:../FreeRTOS_Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3421              		.loc 1 2347 0
 3422 001c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 3423 0020 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 3424 0024 1B68     		ldr	r3, [r3, #0]
 3425 0026 002B     		cmp	r3, #0
 3426 0028 03D1     		bne	.L173
2348:../FreeRTOS_Source/tasks.c **** 			{
2349:../FreeRTOS_Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3427              		.loc 1 2349 0
 3428 002a 4FF00103 		mov	r3, #1
 3429 002e 7B60     		str	r3, [r7, #4]
 3430 0030 02E0     		b	.L172
 3431              	.L173:
2350:../FreeRTOS_Source/tasks.c **** 			}
2351:../FreeRTOS_Source/tasks.c **** 			else
2352:../FreeRTOS_Source/tasks.c **** 			{
2353:../FreeRTOS_Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3432              		.loc 1 2353 0
 3433 0032 4FF00203 		mov	r3, #2
 3434 0036 7B60     		str	r3, [r7, #4]
 3435              	.L172:
2354:../FreeRTOS_Source/tasks.c **** 			}
2355:../FreeRTOS_Source/tasks.c **** 		}
2356:../FreeRTOS_Source/tasks.c **** 
2357:../FreeRTOS_Source/tasks.c **** 		return xReturn;
 3436              		.loc 1 2357 0
 3437 0038 7B68     		ldr	r3, [r7, #4]
2358:../FreeRTOS_Source/tasks.c **** 	}
 3438              		.loc 1 2358 0
 3439 003a 1846     		mov	r0, r3
 3440 003c 07F10C07 		add	r7, r7, #12
 3441 0040 BD46     		mov	sp, r7
 3442 0042 80BC     		pop	{r7}
 3443 0044 7047     		bx	lr
 3444              		.cfi_endproc
 3445              	.LFE33:
 3447 0046 00BF     		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3448              		.align	2
 3449              		.global	vTaskPriorityInherit
 3450              		.thumb
 3451              		.thumb_func
 3453              	vTaskPriorityInherit:
 3454              	.LFB34:
2359:../FreeRTOS_Source/tasks.c **** 
2360:../FreeRTOS_Source/tasks.c **** #endif
2361:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2362:../FreeRTOS_Source/tasks.c **** 
2363:../FreeRTOS_Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2364:../FreeRTOS_Source/tasks.c **** 
2365:../FreeRTOS_Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:../FreeRTOS_Source/tasks.c **** 	{
 3455              		.loc 1 2366 0
 3456              		.cfi_startproc
 3457              		@ args = 0, pretend = 0, frame = 16
 3458              		@ frame_needed = 1, uses_anonymous_args = 0
 3459 0000 80B5     		push	{r7, lr}
 3460              	.LCFI98:
 3461              		.cfi_def_cfa_offset 8
 3462              		.cfi_offset 14, -4
 3463              		.cfi_offset 7, -8
 3464 0002 84B0     		sub	sp, sp, #16
 3465              	.LCFI99:
 3466              		.cfi_def_cfa_offset 24
 3467 0004 00AF     		add	r7, sp, #0
 3468              	.LCFI100:
 3469              		.cfi_def_cfa_register 7
 3470 0006 7860     		str	r0, [r7, #4]
2367:../FreeRTOS_Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3471              		.loc 1 2367 0
 3472 0008 7B68     		ldr	r3, [r7, #4]
 3473 000a FB60     		str	r3, [r7, #12]
2368:../FreeRTOS_Source/tasks.c **** 
2369:../FreeRTOS_Source/tasks.c **** 		configASSERT( pxMutexHolder );
 3474              		.loc 1 2369 0
 3475 000c 7B68     		ldr	r3, [r7, #4]
 3476 000e 002B     		cmp	r3, #0
 3477 0010 04D1     		bne	.L175
 3478              		.loc 1 2369 0 is_stmt 0 discriminator 1
 3479              	@ 2369 "../FreeRTOS_Source/tasks.c" 1
 3480 0012 4FF05000 			mov r0, #80								
 3481 0016 80F31188 		msr basepri, r0							
 3482              	
 3483              	@ 0 "" 2
 3484              		.thumb
 3485              	.L176:
 3486              		.loc 1 2369 0 discriminator 2
 3487 001a FEE7     		b	.L176
 3488              	.L175:
2370:../FreeRTOS_Source/tasks.c **** 
2371:../FreeRTOS_Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3489              		.loc 1 2371 0 is_stmt 1
 3490 001c FB68     		ldr	r3, [r7, #12]
 3491 001e DA6A     		ldr	r2, [r3, #44]
 3492 0020 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3493 0024 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3494 0028 1B68     		ldr	r3, [r3, #0]
 3495 002a DB6A     		ldr	r3, [r3, #44]
 3496 002c 9A42     		cmp	r2, r3
 3497 002e 57D2     		bcs	.L174
2372:../FreeRTOS_Source/tasks.c **** 		{
2373:../FreeRTOS_Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2374:../FreeRTOS_Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3498              		.loc 1 2374 0
 3499 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3500 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3501 0038 1B68     		ldr	r3, [r3, #0]
 3502 003a DB6A     		ldr	r3, [r3, #44]
 3503 003c C3F10202 		rsb	r2, r3, #2
 3504 0040 FB68     		ldr	r3, [r7, #12]
 3505 0042 9A61     		str	r2, [r3, #24]
2375:../FreeRTOS_Source/tasks.c **** 
2376:../FreeRTOS_Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2377:../FreeRTOS_Source/tasks.c **** 			be moved in to a new list. */
2378:../FreeRTOS_Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3506              		.loc 1 2378 0
 3507 0044 FB68     		ldr	r3, [r7, #12]
 3508 0046 5969     		ldr	r1, [r3, #20]
 3509 0048 FB68     		ldr	r3, [r7, #12]
 3510 004a DA6A     		ldr	r2, [r3, #44]
 3511 004c 1346     		mov	r3, r2
 3512 004e 4FEA8303 		lsl	r3, r3, #2
 3513 0052 9B18     		adds	r3, r3, r2
 3514 0054 4FEA8303 		lsl	r3, r3, #2
 3515 0058 1A46     		mov	r2, r3
 3516 005a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3517 005e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3518 0062 D318     		adds	r3, r2, r3
 3519 0064 9942     		cmp	r1, r3
 3520 0066 33D1     		bne	.L178
2379:../FreeRTOS_Source/tasks.c **** 			{
2380:../FreeRTOS_Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3521              		.loc 1 2380 0
 3522 0068 FB68     		ldr	r3, [r7, #12]
 3523 006a 03F10403 		add	r3, r3, #4
 3524 006e 1846     		mov	r0, r3
 3525 0070 FFF7FEFF 		bl	vListRemove
2381:../FreeRTOS_Source/tasks.c **** 
2382:../FreeRTOS_Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2383:../FreeRTOS_Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3526              		.loc 1 2383 0
 3527 0074 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3528 0078 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3529 007c 1B68     		ldr	r3, [r3, #0]
 3530 007e DA6A     		ldr	r2, [r3, #44]
 3531 0080 FB68     		ldr	r3, [r7, #12]
 3532 0082 DA62     		str	r2, [r3, #44]
2384:../FreeRTOS_Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3533              		.loc 1 2384 0
 3534 0084 FB68     		ldr	r3, [r7, #12]
 3535 0086 DA6A     		ldr	r2, [r3, #44]
 3536 0088 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3537 008c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3538 0090 1B68     		ldr	r3, [r3, #0]
 3539 0092 9A42     		cmp	r2, r3
 3540 0094 06D9     		bls	.L179
 3541              		.loc 1 2384 0 is_stmt 0 discriminator 1
 3542 0096 FB68     		ldr	r3, [r7, #12]
 3543 0098 DA6A     		ldr	r2, [r3, #44]
 3544 009a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3545 009e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3546 00a2 1A60     		str	r2, [r3, #0]
 3547              	.L179:
 3548              		.loc 1 2384 0 discriminator 2
 3549 00a4 FB68     		ldr	r3, [r7, #12]
 3550 00a6 DA6A     		ldr	r2, [r3, #44]
 3551 00a8 1346     		mov	r3, r2
 3552 00aa 4FEA8303 		lsl	r3, r3, #2
 3553 00ae 9B18     		adds	r3, r3, r2
 3554 00b0 4FEA8303 		lsl	r3, r3, #2
 3555 00b4 1A46     		mov	r2, r3
 3556 00b6 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3557 00ba C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3558 00be D218     		adds	r2, r2, r3
 3559 00c0 FB68     		ldr	r3, [r7, #12]
 3560 00c2 03F10403 		add	r3, r3, #4
 3561 00c6 1046     		mov	r0, r2
 3562 00c8 1946     		mov	r1, r3
 3563 00ca FFF7FEFF 		bl	vListInsertEnd
 3564 00ce 07E0     		b	.L174
 3565              	.L178:
2385:../FreeRTOS_Source/tasks.c **** 			}
2386:../FreeRTOS_Source/tasks.c **** 			else
2387:../FreeRTOS_Source/tasks.c **** 			{
2388:../FreeRTOS_Source/tasks.c **** 				/* Just inherit the priority. */
2389:../FreeRTOS_Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3566              		.loc 1 2389 0 is_stmt 1
 3567 00d0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3568 00d4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3569 00d8 1B68     		ldr	r3, [r3, #0]
 3570 00da DA6A     		ldr	r2, [r3, #44]
 3571 00dc FB68     		ldr	r3, [r7, #12]
 3572 00de DA62     		str	r2, [r3, #44]
 3573              	.L174:
2390:../FreeRTOS_Source/tasks.c **** 			}
2391:../FreeRTOS_Source/tasks.c **** 
2392:../FreeRTOS_Source/tasks.c **** 			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:../FreeRTOS_Source/tasks.c **** 		}
2394:../FreeRTOS_Source/tasks.c **** 	}
 3574              		.loc 1 2394 0
 3575 00e0 07F11007 		add	r7, r7, #16
 3576 00e4 BD46     		mov	sp, r7
 3577 00e6 80BD     		pop	{r7, pc}
 3578              		.cfi_endproc
 3579              	.LFE34:
 3581              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3582              		.align	2
 3583              		.global	vTaskPriorityDisinherit
 3584              		.thumb
 3585              		.thumb_func
 3587              	vTaskPriorityDisinherit:
 3588              	.LFB35:
2395:../FreeRTOS_Source/tasks.c **** 
2396:../FreeRTOS_Source/tasks.c **** #endif
2397:../FreeRTOS_Source/tasks.c **** /*-----------------------------------------------------------*/
2398:../FreeRTOS_Source/tasks.c **** 
2399:../FreeRTOS_Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2400:../FreeRTOS_Source/tasks.c **** 
2401:../FreeRTOS_Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:../FreeRTOS_Source/tasks.c **** 	{
 3589              		.loc 1 2402 0
 3590              		.cfi_startproc
 3591              		@ args = 0, pretend = 0, frame = 16
 3592              		@ frame_needed = 1, uses_anonymous_args = 0
 3593 0000 80B5     		push	{r7, lr}
 3594              	.LCFI101:
 3595              		.cfi_def_cfa_offset 8
 3596              		.cfi_offset 14, -4
 3597              		.cfi_offset 7, -8
 3598 0002 84B0     		sub	sp, sp, #16
 3599              	.LCFI102:
 3600              		.cfi_def_cfa_offset 24
 3601 0004 00AF     		add	r7, sp, #0
 3602              	.LCFI103:
 3603              		.cfi_def_cfa_register 7
 3604 0006 7860     		str	r0, [r7, #4]
2403:../FreeRTOS_Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3605              		.loc 1 2403 0
 3606 0008 7B68     		ldr	r3, [r7, #4]
 3607 000a FB60     		str	r3, [r7, #12]
2404:../FreeRTOS_Source/tasks.c **** 
2405:../FreeRTOS_Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3608              		.loc 1 2405 0
 3609 000c 7B68     		ldr	r3, [r7, #4]
 3610 000e 002B     		cmp	r3, #0
 3611 0010 3AD0     		beq	.L180
2406:../FreeRTOS_Source/tasks.c **** 		{
2407:../FreeRTOS_Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3612              		.loc 1 2407 0
 3613 0012 FB68     		ldr	r3, [r7, #12]
 3614 0014 DA6A     		ldr	r2, [r3, #44]
 3615 0016 FB68     		ldr	r3, [r7, #12]
 3616 0018 1B6C     		ldr	r3, [r3, #64]
 3617 001a 9A42     		cmp	r2, r3
 3618 001c 34D0     		beq	.L180
2408:../FreeRTOS_Source/tasks.c **** 			{
2409:../FreeRTOS_Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2410:../FreeRTOS_Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2411:../FreeRTOS_Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3619              		.loc 1 2411 0
 3620 001e FB68     		ldr	r3, [r7, #12]
 3621 0020 03F10403 		add	r3, r3, #4
 3622 0024 1846     		mov	r0, r3
 3623 0026 FFF7FEFF 		bl	vListRemove
2412:../FreeRTOS_Source/tasks.c **** 
2413:../FreeRTOS_Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2414:../FreeRTOS_Source/tasks.c **** 				ready list. */
2415:../FreeRTOS_Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:../FreeRTOS_Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3624              		.loc 1 2416 0
 3625 002a FB68     		ldr	r3, [r7, #12]
 3626 002c 1A6C     		ldr	r2, [r3, #64]
 3627 002e FB68     		ldr	r3, [r7, #12]
 3628 0030 DA62     		str	r2, [r3, #44]
2417:../FreeRTOS_Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3629              		.loc 1 2417 0
 3630 0032 FB68     		ldr	r3, [r7, #12]
 3631 0034 DB6A     		ldr	r3, [r3, #44]
 3632 0036 C3F10202 		rsb	r2, r3, #2
 3633 003a FB68     		ldr	r3, [r7, #12]
 3634 003c 9A61     		str	r2, [r3, #24]
2418:../FreeRTOS_Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3635              		.loc 1 2418 0
 3636 003e FB68     		ldr	r3, [r7, #12]
 3637 0040 DA6A     		ldr	r2, [r3, #44]
 3638 0042 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3639 0046 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3640 004a 1B68     		ldr	r3, [r3, #0]
 3641 004c 9A42     		cmp	r2, r3
 3642 004e 06D9     		bls	.L182
 3643              		.loc 1 2418 0 is_stmt 0 discriminator 1
 3644 0050 FB68     		ldr	r3, [r7, #12]
 3645 0052 DA6A     		ldr	r2, [r3, #44]
 3646 0054 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3647 0058 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3648 005c 1A60     		str	r2, [r3, #0]
 3649              	.L182:
 3650              		.loc 1 2418 0 discriminator 2
 3651 005e FB68     		ldr	r3, [r7, #12]
 3652 0060 DA6A     		ldr	r2, [r3, #44]
 3653 0062 1346     		mov	r3, r2
 3654 0064 4FEA8303 		lsl	r3, r3, #2
 3655 0068 9B18     		adds	r3, r3, r2
 3656 006a 4FEA8303 		lsl	r3, r3, #2
 3657 006e 1A46     		mov	r2, r3
 3658 0070 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3659 0074 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3660 0078 D218     		adds	r2, r2, r3
 3661 007a FB68     		ldr	r3, [r7, #12]
 3662 007c 03F10403 		add	r3, r3, #4
 3663 0080 1046     		mov	r0, r2
 3664 0082 1946     		mov	r1, r3
 3665 0084 FFF7FEFF 		bl	vListInsertEnd
 3666              	.L180:
2419:../FreeRTOS_Source/tasks.c **** 			}
2420:../FreeRTOS_Source/tasks.c **** 		}
2421:../FreeRTOS_Source/tasks.c **** 	}
 3667              		.loc 1 2421 0 is_stmt 1
 3668 0088 07F11007 		add	r7, r7, #16
 3669 008c BD46     		mov	sp, r7
 3670 008e 80BD     		pop	{r7, pc}
 3671              		.cfi_endproc
 3672              	.LFE35:
 3674              		.text
 3675              	.Letext0:
 3676              		.file 2 "c:\\tools\\codesourcery\\arm\\29-01-2012\\bin\\../lib/gcc/arm-none-eabi/4.6.1/include/std
 3677              		.file 3 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/projdefs.h"
 3678              		.file 4 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\portable\\GCC\\ARM_CM3/portmacro.
 3679              		.file 5 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/list.h"
 3680              		.file 6 "D:\\PALL\\workspace\\freertos_stm32_d\\FreeRTOS_Source\\include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:23     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:20     .bss.pxCurrentTCB:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:26     .bss.pxReadyTasksLists:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:29     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:32     .bss.xDelayedTaskList1:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:35     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:38     .bss.xDelayedTaskList2:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:41     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:44     .bss.pxDelayedTaskList:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:47     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:50     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:53     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:56     .bss.xPendingReadyList:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:59     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:62     .bss.xTasksWaitingTermination:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:65     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:68     .bss.uxTasksDeleted:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:71     .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:74     .bss.xSuspendedTaskList:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:77     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:80     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:83     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:86     .bss.xTickCount:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:89     .bss.xTickCount:00000000 xTickCount
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:92     .bss.uxTopUsedPriority:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:95     .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:98     .bss.uxTopReadyPriority:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:101    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:104    .bss.xSchedulerRunning:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:107    .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:110    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:113    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:116    .bss.uxMissedTicks:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:119    .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:122    .bss.xMissedYield:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:125    .bss.xMissedYield:00000000 xMissedYield
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:128    .bss.xNumOfOverflows:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:131    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:134    .bss.uxTCBNumber:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:137    .bss.uxTCBNumber:00000000 uxTCBNumber
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:140    .data.xNextTaskUnblockTime:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:143    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:146    .text.xTaskGenericCreate:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:151    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3231   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2890   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2973   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:434    .text.vTaskDelete:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:439    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:547    .text.vTaskDelayUntil:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:552    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1614   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3151   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1649   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:693    .text.vTaskDelay:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:698    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:761    .text.uxTaskPriorityGet:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:766    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:818    .text.vTaskPrioritySet:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:823    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1016   .text.vTaskSuspend:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1021   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2203   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1133   .text.xTaskIsTaskSuspended:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1138   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1212   .text.vTaskResume:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1217   .text.vTaskResume:00000000 vTaskResume
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1331   .text.xTaskResumeFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1336   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1472   .rodata:00000000 $d
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1473   .rodata:00000000 .LC0
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1476   .text.vTaskStartScheduler:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1481   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2847   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1570   .text.vTaskEndScheduler:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1575   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1609   .text.vTaskSuspendAll:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1644   .text.xTaskResumeAll:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1974   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1840   .text.xTaskGetTickCount:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1845   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1882   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1887   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1937   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1942   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:1969   .text.vTaskIncrementTick:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2198   .text.vTaskSwitchContext:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2328   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2333   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2416   .text.vTaskPlaceOnEventListRestricted:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2421   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2488   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2493   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2617   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2622   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2676   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2681   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2811   .text.vTaskMissedYield:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2816   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2843   .text.prvIdleTask:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3060   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2886   .text.prvInitialiseTCBVariables:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:2969   .text.prvInitialiseTaskLists:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3056   .text.prvCheckTasksWaitingTermination:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3315   .text.prvDeleteTCB:00000000 prvDeleteTCB
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3147   .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3227   .text.prvAllocateTCBAndStack:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3311   .text.prvDeleteTCB:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3349   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3354   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3388   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3393   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3448   .text.vTaskPriorityInherit:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3453   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3582   .text.vTaskPriorityDisinherit:00000000 $t
C:\Users\Palladin\AppData\Local\Temp\cc46BdIf.s:3587   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
