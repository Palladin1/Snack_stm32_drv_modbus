   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"portevent_m.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	xMasterOsEvent,4,4
  19              		.section	.bss.eQueuedEvent,"aw",%nobits
  22              	eQueuedEvent:
  23 0000 00       		.space	1
  24              		.section	.bss.xEventInQueue,"aw",%nobits
  27              	xEventInQueue:
  28 0000 00       		.space	1
  29              		.section	.bss.xMasterRunRes,"aw",%nobits
  32              	xMasterRunRes:
  33 0000 00       		.space	1
  34              		.section	.text.xMBMasterPortEventInit,"ax",%progbits
  35              		.align	2
  36              		.global	xMBMasterPortEventInit
  37              		.thumb
  38              		.thumb_func
  40              	xMBMasterPortEventInit:
  41              	.LFB29:
  42              		.file 1 "../FreeModbus/stm32/portevent_m.c"
   1:../FreeModbus/stm32/portevent_m.c **** /*
   2:../FreeModbus/stm32/portevent_m.c ****  * FreeModbus Libary: STM32 Port
   3:../FreeModbus/stm32/portevent_m.c ****  * Copyright (C) 2013 Armink <armink.ztl@gmail.com>
   4:../FreeModbus/stm32/portevent_m.c ****  *
   5:../FreeModbus/stm32/portevent_m.c ****  * This library is free software; you can redistribute it and/or
   6:../FreeModbus/stm32/portevent_m.c ****  * modify it under the terms of the GNU Lesser General Public
   7:../FreeModbus/stm32/portevent_m.c ****  * License as published by the Free Software Foundation; either
   8:../FreeModbus/stm32/portevent_m.c ****  * version 2.1 of the License, or (at your option) any later version.
   9:../FreeModbus/stm32/portevent_m.c ****  *
  10:../FreeModbus/stm32/portevent_m.c ****  * This library is distributed in the hope that it will be useful,
  11:../FreeModbus/stm32/portevent_m.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:../FreeModbus/stm32/portevent_m.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13:../FreeModbus/stm32/portevent_m.c ****  * Lesser General Public License for more details.
  14:../FreeModbus/stm32/portevent_m.c ****  *
  15:../FreeModbus/stm32/portevent_m.c ****  * You should have received a copy of the GNU Lesser General Public
  16:../FreeModbus/stm32/portevent_m.c ****  * License along with this library; if not, write to the Free Software
  17:../FreeModbus/stm32/portevent_m.c ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  18:../FreeModbus/stm32/portevent_m.c ****  *
  19:../FreeModbus/stm32/portevent_m.c ****  * File: $Id: portevent_m.c v 1.60 2013/08/13 15:07:05 Armink add Master Functions$
  20:../FreeModbus/stm32/portevent_m.c ****  */
  21:../FreeModbus/stm32/portevent_m.c **** 
  22:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Modbus includes ----------------------------------*/
  23:../FreeModbus/stm32/portevent_m.c **** #include "mb.h"
  24:../FreeModbus/stm32/portevent_m.c **** #include "mb_m.h"
  25:../FreeModbus/stm32/portevent_m.c **** #include "mbport.h"
  26:../FreeModbus/stm32/portevent_m.c **** #include "port.h"
  27:../FreeModbus/stm32/portevent_m.c **** 
  28:../FreeModbus/stm32/portevent_m.c **** #if MB_MASTER_RTU_ENABLED > 0 || MB_MASTER_ASCII_ENABLED > 0
  29:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Defines ------------------------------------------*/
  30:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Variables ----------------------------------------*/
  31:../FreeModbus/stm32/portevent_m.c **** //static struct rt_semaphore xMasterRunRes;
  32:../FreeModbus/stm32/portevent_m.c **** //static struct rt_event     xMasterOsEvent;
  33:../FreeModbus/stm32/portevent_m.c **** 
  34:../FreeModbus/stm32/portevent_m.c **** u32 xMasterOsEvent;
  35:../FreeModbus/stm32/portevent_m.c **** 
  36:../FreeModbus/stm32/portevent_m.c **** static eMBEventType eQueuedEvent;
  37:../FreeModbus/stm32/portevent_m.c **** static BOOL     xEventInQueue;
  38:../FreeModbus/stm32/portevent_m.c **** 
  39:../FreeModbus/stm32/portevent_m.c **** static BOOL xMasterRunRes;
  40:../FreeModbus/stm32/portevent_m.c **** 
  41:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Start implementation -----------------------------*/
  42:../FreeModbus/stm32/portevent_m.c **** BOOL
  43:../FreeModbus/stm32/portevent_m.c **** xMBMasterPortEventInit( void )
  44:../FreeModbus/stm32/portevent_m.c **** {
  43              		.loc 1 44 0
  44              		.cfi_startproc
  45              		@ args = 0, pretend = 0, frame = 0
  46              		@ frame_needed = 1, uses_anonymous_args = 0
  47              		@ link register save eliminated.
  48 0000 80B4     		push	{r7}
  49              		.cfi_def_cfa_offset 4
  50              		.cfi_offset 7, -4
  51 0002 00AF     		add	r7, sp, #0
  52              		.cfi_def_cfa_register 7
  45:../FreeModbus/stm32/portevent_m.c **** 	//rt_event_init(&xMasterOsEvent,"master event",RT_IPC_FLAG_PRIO);
  46:../FreeModbus/stm32/portevent_m.c **** 	xEventInQueue = FALSE;
  53              		.loc 1 46 0
  54 0004 40F20003 		movw	r3, #:lower16:xEventInQueue
  55 0008 C0F20003 		movt	r3, #:upper16:xEventInQueue
  56 000c 0022     		movs	r2, #0
  57 000e 1A70     		strb	r2, [r3]
  47:../FreeModbus/stm32/portevent_m.c ****     return TRUE;
  58              		.loc 1 47 0
  59 0010 0123     		movs	r3, #1
  48:../FreeModbus/stm32/portevent_m.c **** }
  60              		.loc 1 48 0
  61 0012 1846     		mov	r0, r3
  62 0014 BD46     		mov	sp, r7
  63              		@ sp needed
  64 0016 5DF8047B 		ldr	r7, [sp], #4
  65 001a 7047     		bx	lr
  66              		.cfi_endproc
  67              	.LFE29:
  69              		.section	.text.xMBMasterPortEventPost,"ax",%progbits
  70              		.align	2
  71              		.global	xMBMasterPortEventPost
  72              		.thumb
  73              		.thumb_func
  75              	xMBMasterPortEventPost:
  76              	.LFB30:
  49:../FreeModbus/stm32/portevent_m.c **** 
  50:../FreeModbus/stm32/portevent_m.c **** BOOL
  51:../FreeModbus/stm32/portevent_m.c **** xMBMasterPortEventPost( eMBMasterEventType eEvent )
  52:../FreeModbus/stm32/portevent_m.c **** {
  77              		.loc 1 52 0
  78              		.cfi_startproc
  79              		@ args = 0, pretend = 0, frame = 8
  80              		@ frame_needed = 1, uses_anonymous_args = 0
  81              		@ link register save eliminated.
  82 0000 80B4     		push	{r7}
  83              		.cfi_def_cfa_offset 4
  84              		.cfi_offset 7, -4
  85 0002 83B0     		sub	sp, sp, #12
  86              		.cfi_def_cfa_offset 16
  87 0004 00AF     		add	r7, sp, #0
  88              		.cfi_def_cfa_register 7
  89 0006 0346     		mov	r3, r0
  90 0008 FB80     		strh	r3, [r7, #6]	@ movhi
  53:../FreeModbus/stm32/portevent_m.c **** 	//rt_event_send(&xMasterOsEvent, eEvent);
  54:../FreeModbus/stm32/portevent_m.c ****     xEventInQueue = TRUE;
  91              		.loc 1 54 0
  92 000a 40F20003 		movw	r3, #:lower16:xEventInQueue
  93 000e C0F20003 		movt	r3, #:upper16:xEventInQueue
  94 0012 0122     		movs	r2, #1
  95 0014 1A70     		strb	r2, [r3]
  55:../FreeModbus/stm32/portevent_m.c ****     eQueuedEvent = eEvent;
  96              		.loc 1 55 0
  97 0016 FB88     		ldrh	r3, [r7, #6]	@ movhi
  98 0018 DAB2     		uxtb	r2, r3
  99 001a 40F20003 		movw	r3, #:lower16:eQueuedEvent
 100 001e C0F20003 		movt	r3, #:upper16:eQueuedEvent
 101 0022 1A70     		strb	r2, [r3]
  56:../FreeModbus/stm32/portevent_m.c ****     return TRUE;
 102              		.loc 1 56 0
 103 0024 0123     		movs	r3, #1
  57:../FreeModbus/stm32/portevent_m.c **** }
 104              		.loc 1 57 0
 105 0026 1846     		mov	r0, r3
 106 0028 0C37     		adds	r7, r7, #12
 107 002a BD46     		mov	sp, r7
 108              		@ sp needed
 109 002c 5DF8047B 		ldr	r7, [sp], #4
 110 0030 7047     		bx	lr
 111              		.cfi_endproc
 112              	.LFE30:
 114 0032 00BF     		.section	.text.xMBMasterPortEventGet,"ax",%progbits
 115              		.align	2
 116              		.global	xMBMasterPortEventGet
 117              		.thumb
 118              		.thumb_func
 120              	xMBMasterPortEventGet:
 121              	.LFB31:
  58:../FreeModbus/stm32/portevent_m.c **** 
  59:../FreeModbus/stm32/portevent_m.c **** BOOL
  60:../FreeModbus/stm32/portevent_m.c **** xMBMasterPortEventGet( eMBMasterEventType * eEvent )
  61:../FreeModbus/stm32/portevent_m.c **** {
 122              		.loc 1 61 0
 123              		.cfi_startproc
 124              		@ args = 0, pretend = 0, frame = 16
 125              		@ frame_needed = 1, uses_anonymous_args = 0
 126              		@ link register save eliminated.
 127 0000 80B4     		push	{r7}
 128              		.cfi_def_cfa_offset 4
 129              		.cfi_offset 7, -4
 130 0002 85B0     		sub	sp, sp, #20
 131              		.cfi_def_cfa_offset 24
 132 0004 00AF     		add	r7, sp, #0
 133              		.cfi_def_cfa_register 7
 134 0006 7860     		str	r0, [r7, #4]
  62:../FreeModbus/stm32/portevent_m.c **** 
  63:../FreeModbus/stm32/portevent_m.c **** 	 BOOL            xEventHappened = FALSE;
 135              		.loc 1 63 0
 136 0008 0023     		movs	r3, #0
 137 000a FB73     		strb	r3, [r7, #15]
  64:../FreeModbus/stm32/portevent_m.c **** 
  65:../FreeModbus/stm32/portevent_m.c **** 	    if( xEventInQueue )
 138              		.loc 1 65 0
 139 000c 40F20003 		movw	r3, #:lower16:xEventInQueue
 140 0010 C0F20003 		movt	r3, #:upper16:xEventInQueue
 141 0014 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 142 0016 002B     		cmp	r3, #0
 143 0018 0FD0     		beq	.L6
  66:../FreeModbus/stm32/portevent_m.c **** 	    {
  67:../FreeModbus/stm32/portevent_m.c **** 	        *eEvent = eQueuedEvent;
 144              		.loc 1 67 0
 145 001a 40F20003 		movw	r3, #:lower16:eQueuedEvent
 146 001e C0F20003 		movt	r3, #:upper16:eQueuedEvent
 147 0022 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 148 0024 1A46     		mov	r2, r3
 149 0026 7B68     		ldr	r3, [r7, #4]
 150 0028 1A80     		strh	r2, [r3]	@ movhi
  68:../FreeModbus/stm32/portevent_m.c **** 	        xEventInQueue = FALSE;
 151              		.loc 1 68 0
 152 002a 40F20003 		movw	r3, #:lower16:xEventInQueue
 153 002e C0F20003 		movt	r3, #:upper16:xEventInQueue
 154 0032 0022     		movs	r2, #0
 155 0034 1A70     		strb	r2, [r3]
  69:../FreeModbus/stm32/portevent_m.c **** 	        xEventHappened = TRUE;
 156              		.loc 1 69 0
 157 0036 0123     		movs	r3, #1
 158 0038 FB73     		strb	r3, [r7, #15]
 159              	.L6:
  70:../FreeModbus/stm32/portevent_m.c **** 	    }
  71:../FreeModbus/stm32/portevent_m.c **** 	    return xEventHappened;
 160              		.loc 1 71 0
 161 003a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
  72:../FreeModbus/stm32/portevent_m.c **** 
  73:../FreeModbus/stm32/portevent_m.c **** 	//rt_uint32_t recvedEvent;
  74:../FreeModbus/stm32/portevent_m.c ****     /* waiting forever OS event */
  75:../FreeModbus/stm32/portevent_m.c **** 	/*
  76:../FreeModbus/stm32/portevent_m.c **** 	rt_event_recv(&xMasterOsEvent,
  77:../FreeModbus/stm32/portevent_m.c **** 			EV_MASTER_READY | EV_MASTER_FRAME_RECEIVED | EV_MASTER_EXECUTE |
  78:../FreeModbus/stm32/portevent_m.c **** 			EV_MASTER_FRAME_SENT | EV_MASTER_ERROR_PROCESS,
  79:../FreeModbus/stm32/portevent_m.c **** 			RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER,
  80:../FreeModbus/stm32/portevent_m.c **** 			&recvedEvent);
  81:../FreeModbus/stm32/portevent_m.c **** 	*/
  82:../FreeModbus/stm32/portevent_m.c **** 	/* the enum type couldn't convert to int type */
  83:../FreeModbus/stm32/portevent_m.c **** 	/*
  84:../FreeModbus/stm32/portevent_m.c **** 	switch (recvedEvent)
  85:../FreeModbus/stm32/portevent_m.c **** 	{
  86:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_READY:
  87:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_READY;
  88:../FreeModbus/stm32/portevent_m.c **** 		break;
  89:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_FRAME_RECEIVED:
  90:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_FRAME_RECEIVED;
  91:../FreeModbus/stm32/portevent_m.c **** 		break;
  92:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_EXECUTE:
  93:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_EXECUTE;
  94:../FreeModbus/stm32/portevent_m.c **** 		break;
  95:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_FRAME_SENT:
  96:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_FRAME_SENT;
  97:../FreeModbus/stm32/portevent_m.c **** 		break;
  98:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_PROCESS:
  99:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_ERROR_PROCESS;
 100:../FreeModbus/stm32/portevent_m.c **** 		break;
 101:../FreeModbus/stm32/portevent_m.c **** 	}
 102:../FreeModbus/stm32/portevent_m.c ****     return TRUE;
 103:../FreeModbus/stm32/portevent_m.c ****     */
 104:../FreeModbus/stm32/portevent_m.c **** 
 105:../FreeModbus/stm32/portevent_m.c **** }
 162              		.loc 1 105 0
 163 003c 1846     		mov	r0, r3
 164 003e 1437     		adds	r7, r7, #20
 165 0040 BD46     		mov	sp, r7
 166              		@ sp needed
 167 0042 5DF8047B 		ldr	r7, [sp], #4
 168 0046 7047     		bx	lr
 169              		.cfi_endproc
 170              	.LFE31:
 172              		.section	.text.vMBMasterOsResInit,"ax",%progbits
 173              		.align	2
 174              		.global	vMBMasterOsResInit
 175              		.thumb
 176              		.thumb_func
 178              	vMBMasterOsResInit:
 179              	.LFB32:
 106:../FreeModbus/stm32/portevent_m.c **** /**
 107:../FreeModbus/stm32/portevent_m.c ****  * This function is initialize the OS resource for modbus master.
 108:../FreeModbus/stm32/portevent_m.c ****  * Note:The resource is define by OS.If you not use OS this function can be empty.
 109:../FreeModbus/stm32/portevent_m.c ****  *
 110:../FreeModbus/stm32/portevent_m.c ****  */
 111:../FreeModbus/stm32/portevent_m.c **** void vMBMasterOsResInit( void )
 112:../FreeModbus/stm32/portevent_m.c **** {
 180              		.loc 1 112 0
 181              		.cfi_startproc
 182              		@ args = 0, pretend = 0, frame = 0
 183              		@ frame_needed = 1, uses_anonymous_args = 0
 184 0000 80B5     		push	{r7, lr}
 185              		.cfi_def_cfa_offset 8
 186              		.cfi_offset 7, -8
 187              		.cfi_offset 14, -4
 188 0002 00AF     		add	r7, sp, #0
 189              		.cfi_def_cfa_register 7
 113:../FreeModbus/stm32/portevent_m.c **** //	rt_sem_init(&xMasterRunRes, "master res", 0x01 , RT_IPC_FLAG_PRIO);
 114:../FreeModbus/stm32/portevent_m.c **** 	ENTER_CRITICAL_SECTION( );
 190              		.loc 1 114 0
 191 0004 FFF7FEFF 		bl	vPortEnterCritical
 115:../FreeModbus/stm32/portevent_m.c **** 	xMasterRunRes = 1;
 192              		.loc 1 115 0
 193 0008 40F20003 		movw	r3, #:lower16:xMasterRunRes
 194 000c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 195 0010 0122     		movs	r2, #1
 196 0012 1A70     		strb	r2, [r3]
 116:../FreeModbus/stm32/portevent_m.c **** 	EXIT_CRITICAL_SECTION( );
 197              		.loc 1 116 0
 198 0014 FFF7FEFF 		bl	vPortExitCritical
 117:../FreeModbus/stm32/portevent_m.c **** }
 199              		.loc 1 117 0
 200 0018 80BD     		pop	{r7, pc}
 201              		.cfi_endproc
 202              	.LFE32:
 204 001a 00BF     		.section	.text.xMBMasterRunResTake,"ax",%progbits
 205              		.align	2
 206              		.global	xMBMasterRunResTake
 207              		.thumb
 208              		.thumb_func
 210              	xMBMasterRunResTake:
 211              	.LFB33:
 118:../FreeModbus/stm32/portevent_m.c **** 
 119:../FreeModbus/stm32/portevent_m.c **** /**
 120:../FreeModbus/stm32/portevent_m.c ****  * This function is take Mobus Master running resource.
 121:../FreeModbus/stm32/portevent_m.c ****  * Note:The resource is define by Operating System.If you not use OS this function can be just retu
 122:../FreeModbus/stm32/portevent_m.c ****  *
 123:../FreeModbus/stm32/portevent_m.c ****  * @param lTimeOut the waiting time.
 124:../FreeModbus/stm32/portevent_m.c ****  *
 125:../FreeModbus/stm32/portevent_m.c ****  * @return resource taked result
 126:../FreeModbus/stm32/portevent_m.c ****  */
 127:../FreeModbus/stm32/portevent_m.c **** BOOL xMBMasterRunResTake( LONG lTimeOut )
 128:../FreeModbus/stm32/portevent_m.c **** {
 212              		.loc 1 128 0
 213              		.cfi_startproc
 214              		@ args = 0, pretend = 0, frame = 8
 215              		@ frame_needed = 1, uses_anonymous_args = 0
 216 0000 80B5     		push	{r7, lr}
 217              		.cfi_def_cfa_offset 8
 218              		.cfi_offset 7, -8
 219              		.cfi_offset 14, -4
 220 0002 82B0     		sub	sp, sp, #8
 221              		.cfi_def_cfa_offset 16
 222 0004 00AF     		add	r7, sp, #0
 223              		.cfi_def_cfa_register 7
 224 0006 7860     		str	r0, [r7, #4]
 129:../FreeModbus/stm32/portevent_m.c **** 	/*If waiting time is -1 .It will wait forever */
 130:../FreeModbus/stm32/portevent_m.c **** //	return rt_sem_take(&xMasterRunRes, lTimeOut) ? FALSE : TRUE ;
 131:../FreeModbus/stm32/portevent_m.c **** 	ENTER_CRITICAL_SECTION( );
 225              		.loc 1 131 0
 226 0008 FFF7FEFF 		bl	vPortEnterCritical
 132:../FreeModbus/stm32/portevent_m.c ****     if ( xMasterRunRes >0 ) {
 227              		.loc 1 132 0
 228 000c 40F20003 		movw	r3, #:lower16:xMasterRunRes
 229 0010 C0F20003 		movt	r3, #:upper16:xMasterRunRes
 230 0014 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 231 0016 002B     		cmp	r3, #0
 232 0018 0FD0     		beq	.L10
 133:../FreeModbus/stm32/portevent_m.c ****     	xMasterRunRes--;
 233              		.loc 1 133 0
 234 001a 40F20003 		movw	r3, #:lower16:xMasterRunRes
 235 001e C0F20003 		movt	r3, #:upper16:xMasterRunRes
 236 0022 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 237 0024 013B     		subs	r3, r3, #1
 238 0026 DAB2     		uxtb	r2, r3
 239 0028 40F20003 		movw	r3, #:lower16:xMasterRunRes
 240 002c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 241 0030 1A70     		strb	r2, [r3]
 134:../FreeModbus/stm32/portevent_m.c ****     	EXIT_CRITICAL_SECTION( );
 242              		.loc 1 134 0
 243 0032 FFF7FEFF 		bl	vPortExitCritical
 135:../FreeModbus/stm32/portevent_m.c ****     }
 136:../FreeModbus/stm32/portevent_m.c ****     else {
 137:../FreeModbus/stm32/portevent_m.c ****       	EXIT_CRITICAL_SECTION( );
 138:../FreeModbus/stm32/portevent_m.c **** 
 139:../FreeModbus/stm32/portevent_m.c ****       	if ( lTimeOut == -1 ) {
 140:../FreeModbus/stm32/portevent_m.c **** 		    while ( !xMasterRunRes ) ;
 141:../FreeModbus/stm32/portevent_m.c **** 		        return  TRUE;
 142:../FreeModbus/stm32/portevent_m.c **** 	    }
 143:../FreeModbus/stm32/portevent_m.c **** 	    else {
 144:../FreeModbus/stm32/portevent_m.c **** 		    while ( 1 ) {
 145:../FreeModbus/stm32/portevent_m.c **** 
 146:../FreeModbus/stm32/portevent_m.c **** 			if ( lTimeOut == 0 )
 147:../FreeModbus/stm32/portevent_m.c **** 				break;
 148:../FreeModbus/stm32/portevent_m.c **** 
 149:../FreeModbus/stm32/portevent_m.c **** 			if ( xMasterRunRes )
 150:../FreeModbus/stm32/portevent_m.c **** 				return  TRUE;
 151:../FreeModbus/stm32/portevent_m.c **** 
 152:../FreeModbus/stm32/portevent_m.c **** 			lTimeOut--;
 153:../FreeModbus/stm32/portevent_m.c **** 		    }
 154:../FreeModbus/stm32/portevent_m.c **** 	    }
 155:../FreeModbus/stm32/portevent_m.c **** 
 156:../FreeModbus/stm32/portevent_m.c ****         return FALSE;
 157:../FreeModbus/stm32/portevent_m.c ****     }
 158:../FreeModbus/stm32/portevent_m.c **** 
 159:../FreeModbus/stm32/portevent_m.c **** 	return  TRUE;
 244              		.loc 1 159 0
 245 0036 0123     		movs	r3, #1
 246 0038 22E0     		b	.L14
 247              	.L10:
 137:../FreeModbus/stm32/portevent_m.c **** 
 248              		.loc 1 137 0
 249 003a FFF7FEFF 		bl	vPortExitCritical
 139:../FreeModbus/stm32/portevent_m.c **** 		    while ( !xMasterRunRes ) ;
 250              		.loc 1 139 0
 251 003e 7B68     		ldr	r3, [r7, #4]
 252 0040 B3F1FF3F 		cmp	r3, #-1
 253 0044 09D1     		bne	.L12
 140:../FreeModbus/stm32/portevent_m.c **** 		        return  TRUE;
 254              		.loc 1 140 0
 255 0046 00BF     		nop
 256              	.L13:
 140:../FreeModbus/stm32/portevent_m.c **** 		        return  TRUE;
 257              		.loc 1 140 0 is_stmt 0 discriminator 1
 258 0048 40F20003 		movw	r3, #:lower16:xMasterRunRes
 259 004c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 260 0050 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 261 0052 002B     		cmp	r3, #0
 262 0054 F8D0     		beq	.L13
 141:../FreeModbus/stm32/portevent_m.c **** 	    }
 263              		.loc 1 141 0 is_stmt 1
 264 0056 0123     		movs	r3, #1
 265 0058 12E0     		b	.L14
 266              	.L12:
 146:../FreeModbus/stm32/portevent_m.c **** 				break;
 267              		.loc 1 146 0
 268 005a 7B68     		ldr	r3, [r7, #4]
 269 005c 002B     		cmp	r3, #0
 270 005e 02D1     		bne	.L15
 147:../FreeModbus/stm32/portevent_m.c **** 
 271              		.loc 1 147 0
 272 0060 00BF     		nop
 156:../FreeModbus/stm32/portevent_m.c ****     }
 273              		.loc 1 156 0
 274 0062 0023     		movs	r3, #0
 275 0064 0CE0     		b	.L14
 276              	.L15:
 149:../FreeModbus/stm32/portevent_m.c **** 				return  TRUE;
 277              		.loc 1 149 0
 278 0066 40F20003 		movw	r3, #:lower16:xMasterRunRes
 279 006a C0F20003 		movt	r3, #:upper16:xMasterRunRes
 280 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 281 0070 002B     		cmp	r3, #0
 282 0072 01D0     		beq	.L17
 150:../FreeModbus/stm32/portevent_m.c **** 
 283              		.loc 1 150 0
 284 0074 0123     		movs	r3, #1
 285 0076 03E0     		b	.L14
 286              	.L17:
 152:../FreeModbus/stm32/portevent_m.c **** 		    }
 287              		.loc 1 152 0
 288 0078 7B68     		ldr	r3, [r7, #4]
 289 007a 013B     		subs	r3, r3, #1
 290 007c 7B60     		str	r3, [r7, #4]
 153:../FreeModbus/stm32/portevent_m.c **** 	    }
 291              		.loc 1 153 0
 292 007e ECE7     		b	.L12
 293              	.L14:
 160:../FreeModbus/stm32/portevent_m.c ****     //return  FALSE;
 161:../FreeModbus/stm32/portevent_m.c **** }
 294              		.loc 1 161 0
 295 0080 1846     		mov	r0, r3
 296 0082 0837     		adds	r7, r7, #8
 297 0084 BD46     		mov	sp, r7
 298              		@ sp needed
 299 0086 80BD     		pop	{r7, pc}
 300              		.cfi_endproc
 301              	.LFE33:
 303              		.section	.text.vMBMasterRunResRelease,"ax",%progbits
 304              		.align	2
 305              		.global	vMBMasterRunResRelease
 306              		.thumb
 307              		.thumb_func
 309              	vMBMasterRunResRelease:
 310              	.LFB34:
 162:../FreeModbus/stm32/portevent_m.c **** 
 163:../FreeModbus/stm32/portevent_m.c **** /**
 164:../FreeModbus/stm32/portevent_m.c ****  * This function is release Mobus Master running resource.
 165:../FreeModbus/stm32/portevent_m.c ****  * Note:The resource is define by Operating System.If you not use OS this function can be empty.
 166:../FreeModbus/stm32/portevent_m.c ****  *
 167:../FreeModbus/stm32/portevent_m.c ****  */
 168:../FreeModbus/stm32/portevent_m.c **** void vMBMasterRunResRelease( void )
 169:../FreeModbus/stm32/portevent_m.c **** {
 311              		.loc 1 169 0
 312              		.cfi_startproc
 313              		@ args = 0, pretend = 0, frame = 0
 314              		@ frame_needed = 1, uses_anonymous_args = 0
 315 0000 80B5     		push	{r7, lr}
 316              		.cfi_def_cfa_offset 8
 317              		.cfi_offset 7, -8
 318              		.cfi_offset 14, -4
 319 0002 00AF     		add	r7, sp, #0
 320              		.cfi_def_cfa_register 7
 170:../FreeModbus/stm32/portevent_m.c **** 	/* release resource */
 171:../FreeModbus/stm32/portevent_m.c **** //	rt_sem_release(&xMasterRunRes);
 172:../FreeModbus/stm32/portevent_m.c **** 	ENTER_CRITICAL_SECTION( );
 321              		.loc 1 172 0
 322 0004 FFF7FEFF 		bl	vPortEnterCritical
 173:../FreeModbus/stm32/portevent_m.c **** 	xMasterRunRes += 1;
 323              		.loc 1 173 0
 324 0008 40F20003 		movw	r3, #:lower16:xMasterRunRes
 325 000c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 326 0010 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 327 0012 0133     		adds	r3, r3, #1
 328 0014 DAB2     		uxtb	r2, r3
 329 0016 40F20003 		movw	r3, #:lower16:xMasterRunRes
 330 001a C0F20003 		movt	r3, #:upper16:xMasterRunRes
 331 001e 1A70     		strb	r2, [r3]
 174:../FreeModbus/stm32/portevent_m.c **** 	EXIT_CRITICAL_SECTION( );
 332              		.loc 1 174 0
 333 0020 FFF7FEFF 		bl	vPortExitCritical
 175:../FreeModbus/stm32/portevent_m.c **** }
 334              		.loc 1 175 0
 335 0024 80BD     		pop	{r7, pc}
 336              		.cfi_endproc
 337              	.LFE34:
 339 0026 00BF     		.section	.text.vMBMasterErrorCBRespondTimeout,"ax",%progbits
 340              		.align	2
 341              		.global	vMBMasterErrorCBRespondTimeout
 342              		.thumb
 343              		.thumb_func
 345              	vMBMasterErrorCBRespondTimeout:
 346              	.LFB35:
 176:../FreeModbus/stm32/portevent_m.c **** 
 177:../FreeModbus/stm32/portevent_m.c **** /**
 178:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master respond timeout error process callback function.
 179:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 180:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 181:../FreeModbus/stm32/portevent_m.c ****  *
 182:../FreeModbus/stm32/portevent_m.c ****  * @param ucDestAddress destination salve address
 183:../FreeModbus/stm32/portevent_m.c ****  * @param pucPDUData PDU buffer data
 184:../FreeModbus/stm32/portevent_m.c ****  * @param ucPDULength PDU buffer length
 185:../FreeModbus/stm32/portevent_m.c ****  *
 186:../FreeModbus/stm32/portevent_m.c ****  */
 187:../FreeModbus/stm32/portevent_m.c **** void vMBMasterErrorCBRespondTimeout(UCHAR ucDestAddress, const UCHAR* pucPDUData,
 188:../FreeModbus/stm32/portevent_m.c **** 		USHORT ucPDULength) {
 347              		.loc 1 188 0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 8
 350              		@ frame_needed = 1, uses_anonymous_args = 0
 351              		@ link register save eliminated.
 352 0000 80B4     		push	{r7}
 353              		.cfi_def_cfa_offset 4
 354              		.cfi_offset 7, -4
 355 0002 83B0     		sub	sp, sp, #12
 356              		.cfi_def_cfa_offset 16
 357 0004 00AF     		add	r7, sp, #0
 358              		.cfi_def_cfa_register 7
 359 0006 3960     		str	r1, [r7]
 360 0008 1346     		mov	r3, r2
 361 000a 0246     		mov	r2, r0
 362 000c FA71     		strb	r2, [r7, #7]
 363 000e BB80     		strh	r3, [r7, #4]	@ movhi
 189:../FreeModbus/stm32/portevent_m.c **** 	/**
 190:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 191:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 192:../FreeModbus/stm32/portevent_m.c **** 	 */
 193:../FreeModbus/stm32/portevent_m.c **** //	rt_event_send(&xMasterOsEvent, EV_MASTER_ERROR_RESPOND_TIMEOUT);
 194:../FreeModbus/stm32/portevent_m.c **** 	//xMBMasterPortEventPost( EV_MASTER_ERROR_RESPOND_TIMEOUT );
 195:../FreeModbus/stm32/portevent_m.c **** 	xMasterOsEvent = EV_MASTER_ERROR_RESPOND_TIMEOUT;
 364              		.loc 1 195 0
 365 0010 40F20003 		movw	r3, #:lower16:xMasterOsEvent
 366 0014 C0F20003 		movt	r3, #:upper16:xMasterOsEvent
 367 0018 4022     		movs	r2, #64
 368 001a 1A60     		str	r2, [r3]
 196:../FreeModbus/stm32/portevent_m.c **** 
 197:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 198:../FreeModbus/stm32/portevent_m.c **** 
 199:../FreeModbus/stm32/portevent_m.c **** }
 369              		.loc 1 199 0
 370 001c 0C37     		adds	r7, r7, #12
 371 001e BD46     		mov	sp, r7
 372              		@ sp needed
 373 0020 5DF8047B 		ldr	r7, [sp], #4
 374 0024 7047     		bx	lr
 375              		.cfi_endproc
 376              	.LFE35:
 378 0026 00BF     		.section	.text.vMBMasterErrorCBReceiveData,"ax",%progbits
 379              		.align	2
 380              		.global	vMBMasterErrorCBReceiveData
 381              		.thumb
 382              		.thumb_func
 384              	vMBMasterErrorCBReceiveData:
 385              	.LFB36:
 200:../FreeModbus/stm32/portevent_m.c **** 
 201:../FreeModbus/stm32/portevent_m.c **** /**
 202:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master receive data error process callback function.
 203:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 204:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 205:../FreeModbus/stm32/portevent_m.c ****  *
 206:../FreeModbus/stm32/portevent_m.c ****  * @param ucDestAddress destination salve address
 207:../FreeModbus/stm32/portevent_m.c ****  * @param pucPDUData PDU buffer data
 208:../FreeModbus/stm32/portevent_m.c ****  * @param ucPDULength PDU buffer length
 209:../FreeModbus/stm32/portevent_m.c ****  *
 210:../FreeModbus/stm32/portevent_m.c ****  */
 211:../FreeModbus/stm32/portevent_m.c **** void vMBMasterErrorCBReceiveData(UCHAR ucDestAddress, const UCHAR* pucPDUData,
 212:../FreeModbus/stm32/portevent_m.c **** 		USHORT ucPDULength) {
 386              		.loc 1 212 0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 8
 389              		@ frame_needed = 1, uses_anonymous_args = 0
 390              		@ link register save eliminated.
 391 0000 80B4     		push	{r7}
 392              		.cfi_def_cfa_offset 4
 393              		.cfi_offset 7, -4
 394 0002 83B0     		sub	sp, sp, #12
 395              		.cfi_def_cfa_offset 16
 396 0004 00AF     		add	r7, sp, #0
 397              		.cfi_def_cfa_register 7
 398 0006 3960     		str	r1, [r7]
 399 0008 1346     		mov	r3, r2
 400 000a 0246     		mov	r2, r0
 401 000c FA71     		strb	r2, [r7, #7]
 402 000e BB80     		strh	r3, [r7, #4]	@ movhi
 213:../FreeModbus/stm32/portevent_m.c **** 	/**
 214:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 215:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 216:../FreeModbus/stm32/portevent_m.c **** 	 */
 217:../FreeModbus/stm32/portevent_m.c **** //	rt_event_send(&xMasterOsEvent, EV_MASTER_ERROR_RECEIVE_DATA);
 218:../FreeModbus/stm32/portevent_m.c **** 	//xMBMasterPortEventPost( EV_MASTER_ERROR_RECEIVE_DATA);
 219:../FreeModbus/stm32/portevent_m.c **** 	xMasterOsEvent = EV_MASTER_ERROR_RECEIVE_DATA;
 403              		.loc 1 219 0
 404 0010 40F20003 		movw	r3, #:lower16:xMasterOsEvent
 405 0014 C0F20003 		movt	r3, #:upper16:xMasterOsEvent
 406 0018 8022     		movs	r2, #128
 407 001a 1A60     		str	r2, [r3]
 220:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 221:../FreeModbus/stm32/portevent_m.c **** 
 222:../FreeModbus/stm32/portevent_m.c **** }
 408              		.loc 1 222 0
 409 001c 0C37     		adds	r7, r7, #12
 410 001e BD46     		mov	sp, r7
 411              		@ sp needed
 412 0020 5DF8047B 		ldr	r7, [sp], #4
 413 0024 7047     		bx	lr
 414              		.cfi_endproc
 415              	.LFE36:
 417 0026 00BF     		.section	.text.vMBMasterErrorCBExecuteFunction,"ax",%progbits
 418              		.align	2
 419              		.global	vMBMasterErrorCBExecuteFunction
 420              		.thumb
 421              		.thumb_func
 423              	vMBMasterErrorCBExecuteFunction:
 424              	.LFB37:
 223:../FreeModbus/stm32/portevent_m.c **** 
 224:../FreeModbus/stm32/portevent_m.c **** /**
 225:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master execute function error process callback function.
 226:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 227:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 228:../FreeModbus/stm32/portevent_m.c ****  *
 229:../FreeModbus/stm32/portevent_m.c ****  * @param ucDestAddress destination salve address
 230:../FreeModbus/stm32/portevent_m.c ****  * @param pucPDUData PDU buffer data
 231:../FreeModbus/stm32/portevent_m.c ****  * @param ucPDULength PDU buffer length
 232:../FreeModbus/stm32/portevent_m.c ****  *
 233:../FreeModbus/stm32/portevent_m.c ****  */
 234:../FreeModbus/stm32/portevent_m.c **** void vMBMasterErrorCBExecuteFunction(UCHAR ucDestAddress, const UCHAR* pucPDUData,
 235:../FreeModbus/stm32/portevent_m.c **** 		USHORT ucPDULength) {
 425              		.loc 1 235 0
 426              		.cfi_startproc
 427              		@ args = 0, pretend = 0, frame = 8
 428              		@ frame_needed = 1, uses_anonymous_args = 0
 429              		@ link register save eliminated.
 430 0000 80B4     		push	{r7}
 431              		.cfi_def_cfa_offset 4
 432              		.cfi_offset 7, -4
 433 0002 83B0     		sub	sp, sp, #12
 434              		.cfi_def_cfa_offset 16
 435 0004 00AF     		add	r7, sp, #0
 436              		.cfi_def_cfa_register 7
 437 0006 3960     		str	r1, [r7]
 438 0008 1346     		mov	r3, r2
 439 000a 0246     		mov	r2, r0
 440 000c FA71     		strb	r2, [r7, #7]
 441 000e BB80     		strh	r3, [r7, #4]	@ movhi
 236:../FreeModbus/stm32/portevent_m.c **** 	/**
 237:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 238:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 239:../FreeModbus/stm32/portevent_m.c **** 	 */
 240:../FreeModbus/stm32/portevent_m.c **** 	//rt_event_send(&xMasterOsEvent, EV_MASTER_ERROR_EXECUTE_FUNCTION);
 241:../FreeModbus/stm32/portevent_m.c **** 	//xMBMasterPortEventPost( EV_MASTER_ERROR_EXECUTE_FUNCTION);
 242:../FreeModbus/stm32/portevent_m.c **** 	xMasterOsEvent = EV_MASTER_ERROR_EXECUTE_FUNCTION;
 442              		.loc 1 242 0
 443 0010 40F20003 		movw	r3, #:lower16:xMasterOsEvent
 444 0014 C0F20003 		movt	r3, #:upper16:xMasterOsEvent
 445 0018 4FF48072 		mov	r2, #256
 446 001c 1A60     		str	r2, [r3]
 243:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 244:../FreeModbus/stm32/portevent_m.c **** 
 245:../FreeModbus/stm32/portevent_m.c **** }
 447              		.loc 1 245 0
 448 001e 0C37     		adds	r7, r7, #12
 449 0020 BD46     		mov	sp, r7
 450              		@ sp needed
 451 0022 5DF8047B 		ldr	r7, [sp], #4
 452 0026 7047     		bx	lr
 453              		.cfi_endproc
 454              	.LFE37:
 456              		.section	.text.vMBMasterCBRequestSuccess,"ax",%progbits
 457              		.align	2
 458              		.global	vMBMasterCBRequestSuccess
 459              		.thumb
 460              		.thumb_func
 462              	vMBMasterCBRequestSuccess:
 463              	.LFB38:
 246:../FreeModbus/stm32/portevent_m.c **** 
 247:../FreeModbus/stm32/portevent_m.c **** /**
 248:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master request process success callback function.
 249:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 250:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 251:../FreeModbus/stm32/portevent_m.c ****  *
 252:../FreeModbus/stm32/portevent_m.c ****  */
 253:../FreeModbus/stm32/portevent_m.c **** void vMBMasterCBRequestSuccess( void ) {
 464              		.loc 1 253 0
 465              		.cfi_startproc
 466              		@ args = 0, pretend = 0, frame = 0
 467              		@ frame_needed = 1, uses_anonymous_args = 0
 468              		@ link register save eliminated.
 469 0000 80B4     		push	{r7}
 470              		.cfi_def_cfa_offset 4
 471              		.cfi_offset 7, -4
 472 0002 00AF     		add	r7, sp, #0
 473              		.cfi_def_cfa_register 7
 254:../FreeModbus/stm32/portevent_m.c **** 	/**
 255:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 256:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 257:../FreeModbus/stm32/portevent_m.c **** 	 */
 258:../FreeModbus/stm32/portevent_m.c **** //	rt_event_send(&xMasterOsEvent, EV_MASTER_PROCESS_SUCESS);
 259:../FreeModbus/stm32/portevent_m.c **** 	//xMBMasterPortEventPost( EV_MASTER_PROCESS_SUCESS);
 260:../FreeModbus/stm32/portevent_m.c **** 	xMasterOsEvent = EV_MASTER_PROCESS_SUCESS;
 474              		.loc 1 260 0
 475 0004 40F20003 		movw	r3, #:lower16:xMasterOsEvent
 476 0008 C0F20003 		movt	r3, #:upper16:xMasterOsEvent
 477 000c 2022     		movs	r2, #32
 478 000e 1A60     		str	r2, [r3]
 261:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 262:../FreeModbus/stm32/portevent_m.c **** 
 263:../FreeModbus/stm32/portevent_m.c **** }
 479              		.loc 1 263 0
 480 0010 BD46     		mov	sp, r7
 481              		@ sp needed
 482 0012 5DF8047B 		ldr	r7, [sp], #4
 483 0016 7047     		bx	lr
 484              		.cfi_endproc
 485              	.LFE38:
 487              		.section	.text.eMBMasterWaitRequestFinish,"ax",%progbits
 488              		.align	2
 489              		.global	eMBMasterWaitRequestFinish
 490              		.thumb
 491              		.thumb_func
 493              	eMBMasterWaitRequestFinish:
 494              	.LFB39:
 264:../FreeModbus/stm32/portevent_m.c **** 
 265:../FreeModbus/stm32/portevent_m.c **** /**
 266:../FreeModbus/stm32/portevent_m.c ****  * This function is wait for modbus master request finish and return result.
 267:../FreeModbus/stm32/portevent_m.c ****  * Waiting result include request process success, request respond timeout,
 268:../FreeModbus/stm32/portevent_m.c ****  * receive data error and execute function error.You can use the above callback function.
 269:../FreeModbus/stm32/portevent_m.c ****  * @note If you are use OS, you can use OS's event mechanism. Otherwise you have to run
 270:../FreeModbus/stm32/portevent_m.c ****  * much user custom delay for waiting.
 271:../FreeModbus/stm32/portevent_m.c ****  *
 272:../FreeModbus/stm32/portevent_m.c ****  * @return request error code
 273:../FreeModbus/stm32/portevent_m.c ****  */
 274:../FreeModbus/stm32/portevent_m.c **** eMBMasterReqErrCode eMBMasterWaitRequestFinish( void ) {
 495              		.loc 1 274 0
 496              		.cfi_startproc
 497              		@ args = 0, pretend = 0, frame = 16
 498              		@ frame_needed = 1, uses_anonymous_args = 0
 499              		@ link register save eliminated.
 500 0000 80B4     		push	{r7}
 501              		.cfi_def_cfa_offset 4
 502              		.cfi_offset 7, -4
 503 0002 85B0     		sub	sp, sp, #20
 504              		.cfi_def_cfa_offset 24
 505 0004 00AF     		add	r7, sp, #0
 506              		.cfi_def_cfa_register 7
 275:../FreeModbus/stm32/portevent_m.c **** 
 276:../FreeModbus/stm32/portevent_m.c **** 	eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
 507              		.loc 1 276 0
 508 0006 0023     		movs	r3, #0
 509 0008 FB73     		strb	r3, [r7, #15]
 277:../FreeModbus/stm32/portevent_m.c ****     uint32_t recvedEvent;
 278:../FreeModbus/stm32/portevent_m.c **** 
 279:../FreeModbus/stm32/portevent_m.c ****     u32 i;
 280:../FreeModbus/stm32/portevent_m.c ****     for ( i=0; i < 2400000; i++ );
 510              		.loc 1 280 0
 511 000a 0023     		movs	r3, #0
 512 000c BB60     		str	r3, [r7, #8]
 513 000e 02E0     		b	.L24
 514              	.L25:
 515              		.loc 1 280 0 is_stmt 0 discriminator 2
 516 0010 BB68     		ldr	r3, [r7, #8]
 517 0012 0133     		adds	r3, r3, #1
 518 0014 BB60     		str	r3, [r7, #8]
 519              	.L24:
 520              		.loc 1 280 0 discriminator 1
 521 0016 BA68     		ldr	r2, [r7, #8]
 522 0018 49F6FF63 		movw	r3, #40703
 523 001c C0F22403 		movt	r3, 36
 524 0020 9A42     		cmp	r2, r3
 525 0022 F5D9     		bls	.L25
 281:../FreeModbus/stm32/portevent_m.c ****     /* waiting for OS event */
 282:../FreeModbus/stm32/portevent_m.c **** //	rt_event_recv(&xMasterOsEvent,
 283:../FreeModbus/stm32/portevent_m.c **** //			EV_MASTER_PROCESS_SUCESS | EV_MASTER_ERROR_RESPOND_TIMEOUT
 284:../FreeModbus/stm32/portevent_m.c **** //					| EV_MASTER_ERROR_RECEIVE_DATA
 285:../FreeModbus/stm32/portevent_m.c **** //					| EV_MASTER_ERROR_EXECUTE_FUNCTION,
 286:../FreeModbus/stm32/portevent_m.c **** //			         &recvedEvent);
 287:../FreeModbus/stm32/portevent_m.c **** 
 288:../FreeModbus/stm32/portevent_m.c **** //  	    if( xEventInQueue )
 289:../FreeModbus/stm32/portevent_m.c **** //   	    {
 290:../FreeModbus/stm32/portevent_m.c **** //   	    	recvedEvent = eQueuedEvent;
 291:../FreeModbus/stm32/portevent_m.c **** //   	    }
 292:../FreeModbus/stm32/portevent_m.c ****     recvedEvent = xMasterOsEvent;
 526              		.loc 1 292 0 is_stmt 1
 527 0024 40F20003 		movw	r3, #:lower16:xMasterOsEvent
 528 0028 C0F20003 		movt	r3, #:upper16:xMasterOsEvent
 529 002c 1B68     		ldr	r3, [r3]
 530 002e 7B60     		str	r3, [r7, #4]
 293:../FreeModbus/stm32/portevent_m.c **** 	switch (recvedEvent)
 531              		.loc 1 293 0
 532 0030 7B68     		ldr	r3, [r7, #4]
 533 0032 402B     		cmp	r3, #64
 534 0034 09D0     		beq	.L27
 535 0036 402B     		cmp	r3, #64
 536 0038 01D8     		bhi	.L28
 537 003a 202B     		cmp	r3, #32
 294:../FreeModbus/stm32/portevent_m.c **** 	{
 295:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_PROCESS_SUCESS:
 296:../FreeModbus/stm32/portevent_m.c **** 		break;
 538              		.loc 1 296 0
 539 003c 0EE0     		b	.L26
 540              	.L28:
 293:../FreeModbus/stm32/portevent_m.c **** 	switch (recvedEvent)
 541              		.loc 1 293 0
 542 003e 802B     		cmp	r3, #128
 543 0040 06D0     		beq	.L30
 544 0042 B3F5807F 		cmp	r3, #256
 545 0046 06D0     		beq	.L31
 546 0048 08E0     		b	.L26
 547              	.L27:
 297:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_RESPOND_TIMEOUT:
 298:../FreeModbus/stm32/portevent_m.c **** 	{
 299:../FreeModbus/stm32/portevent_m.c **** 		eErrStatus = MB_MRE_TIMEDOUT;
 548              		.loc 1 299 0
 549 004a 0423     		movs	r3, #4
 550 004c FB73     		strb	r3, [r7, #15]
 300:../FreeModbus/stm32/portevent_m.c **** 		break;
 551              		.loc 1 300 0
 552 004e 05E0     		b	.L26
 553              	.L30:
 301:../FreeModbus/stm32/portevent_m.c **** 	}
 302:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_RECEIVE_DATA:
 303:../FreeModbus/stm32/portevent_m.c **** 	{
 304:../FreeModbus/stm32/portevent_m.c **** 		eErrStatus = MB_MRE_REV_DATA;
 554              		.loc 1 304 0
 555 0050 0323     		movs	r3, #3
 556 0052 FB73     		strb	r3, [r7, #15]
 305:../FreeModbus/stm32/portevent_m.c **** 		break;
 557              		.loc 1 305 0
 558 0054 02E0     		b	.L26
 559              	.L31:
 306:../FreeModbus/stm32/portevent_m.c **** 	}
 307:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_EXECUTE_FUNCTION:
 308:../FreeModbus/stm32/portevent_m.c **** 	{
 309:../FreeModbus/stm32/portevent_m.c **** 		eErrStatus = MB_MRE_EXE_FUN;
 560              		.loc 1 309 0
 561 0056 0623     		movs	r3, #6
 562 0058 FB73     		strb	r3, [r7, #15]
 310:../FreeModbus/stm32/portevent_m.c **** 		break;
 563              		.loc 1 310 0
 564 005a 00BF     		nop
 565              	.L26:
 311:../FreeModbus/stm32/portevent_m.c **** 	}
 312:../FreeModbus/stm32/portevent_m.c **** 	}
 313:../FreeModbus/stm32/portevent_m.c ****     return eErrStatus;
 566              		.loc 1 313 0
 567 005c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 314:../FreeModbus/stm32/portevent_m.c **** }
 568              		.loc 1 314 0
 569 005e 1846     		mov	r0, r3
 570 0060 1437     		adds	r7, r7, #20
 571 0062 BD46     		mov	sp, r7
 572              		@ sp needed
 573 0064 5DF8047B 		ldr	r7, [sp], #4
 574 0068 7047     		bx	lr
 575              		.cfi_endproc
 576              	.LFE39:
 578 006a 00BF     		.text
 579              	.Letext0:
 580              		.file 2 "c:\\tools\\arm-none-eabi\\include\\stdint.h"
 581              		.file 3 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\stm32/port.h"
 582              		.file 4 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\include/mbport.h"
 583              		.file 5 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\include/mb_m.h"
 584              		.file 6 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\Libraries\\CMSIS/core_cm3.h"
 585              		.file 7 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\Libraries\\CMSIS/stm32f10x.h"
DEFINED SYMBOLS
                            *ABS*:00000000 portevent_m.c
                            *COM*:00000004 xMasterOsEvent
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:22     .bss.eQueuedEvent:00000000 eQueuedEvent
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:23     .bss.eQueuedEvent:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:27     .bss.xEventInQueue:00000000 xEventInQueue
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:28     .bss.xEventInQueue:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:32     .bss.xMasterRunRes:00000000 xMasterRunRes
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:33     .bss.xMasterRunRes:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:35     .text.xMBMasterPortEventInit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:40     .text.xMBMasterPortEventInit:00000000 xMBMasterPortEventInit
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:70     .text.xMBMasterPortEventPost:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:75     .text.xMBMasterPortEventPost:00000000 xMBMasterPortEventPost
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:115    .text.xMBMasterPortEventGet:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:120    .text.xMBMasterPortEventGet:00000000 xMBMasterPortEventGet
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:173    .text.vMBMasterOsResInit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:178    .text.vMBMasterOsResInit:00000000 vMBMasterOsResInit
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:205    .text.xMBMasterRunResTake:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:210    .text.xMBMasterRunResTake:00000000 xMBMasterRunResTake
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:304    .text.vMBMasterRunResRelease:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:309    .text.vMBMasterRunResRelease:00000000 vMBMasterRunResRelease
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:340    .text.vMBMasterErrorCBRespondTimeout:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:345    .text.vMBMasterErrorCBRespondTimeout:00000000 vMBMasterErrorCBRespondTimeout
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:379    .text.vMBMasterErrorCBReceiveData:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:384    .text.vMBMasterErrorCBReceiveData:00000000 vMBMasterErrorCBReceiveData
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:418    .text.vMBMasterErrorCBExecuteFunction:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:423    .text.vMBMasterErrorCBExecuteFunction:00000000 vMBMasterErrorCBExecuteFunction
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:457    .text.vMBMasterCBRequestSuccess:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:462    .text.vMBMasterCBRequestSuccess:00000000 vMBMasterCBRequestSuccess
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:488    .text.eMBMasterWaitRequestFinish:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccgEFSOU.s:493    .text.eMBMasterWaitRequestFinish:00000000 eMBMasterWaitRequestFinish
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.98ffea2db242cfdb58f411f7407f2b59
                           .group:00000000 wm4.stm32f10x_conf.h.2.f1a8c33f0a763aeef696fee38b2b2dbc
                           .group:00000000 wm4.mbconfig.h.33.2e295d4ff98bc723e2405a40490b5ddb
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.183.aa62afef667fb61d15fa64c48beb2f14
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.assert.h.11.060c3dc511517628fd4f958fa9448dce
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.24.8137491c6995c2cb5d25f9bab92d7f64
                           .group:00000000 wm4.stm32f10x.h.51.b859cb68ed44ee02c916b41cb8c68f1c
                           .group:00000000 wm4.core_cm3.h.25.119fe996be41b62fbd915b59177e39d1
                           .group:00000000 wm4.stm32f10x.h.522.a925aafc848b1f088438cf0e9b167b78
                           .group:00000000 wm4.stm32f10x.h.8304.f7d8ad90959e99679b3257267c3aadfe
                           .group:00000000 wm4.stm32f10x_rcc.h.25.fe8897e7491f2eb0cff54551d08eb765
                           .group:00000000 wm4.portmacro.h.56.a47bdd86bc36d334ca6056492e2d709f
                           .group:00000000 wm4.port.h.38.a8cf679bb58c5ad1b387e726c220530e
                           .group:00000000 wm4.mbproto.h.32.da85c2bdd9bdb84e975a92c999a4b490
                           .group:00000000 wm4.mb_m.h.32.f0c90bdd8de56a09521e2eefafb4f11f

UNDEFINED SYMBOLS
vPortEnterCritical
vPortExitCritical
