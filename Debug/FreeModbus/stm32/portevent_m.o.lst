   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"portevent_m.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.bss.eQueuedEvent,"aw",%nobits
  21              	eQueuedEvent:
  22 0000 00       		.space	1
  23              		.section	.bss.xEventInQueue,"aw",%nobits
  26              	xEventInQueue:
  27 0000 00       		.space	1
  28              		.section	.bss.xMasterRunRes,"aw",%nobits
  31              	xMasterRunRes:
  32 0000 00       		.space	1
  33              		.section	.text.xMBMasterPortEventInit,"ax",%progbits
  34              		.align	2
  35              		.global	xMBMasterPortEventInit
  36              		.thumb
  37              		.thumb_func
  39              	xMBMasterPortEventInit:
  40              	.LFB29:
  41              		.file 1 "../FreeModbus/stm32/portevent_m.c"
   1:../FreeModbus/stm32/portevent_m.c **** /*
   2:../FreeModbus/stm32/portevent_m.c ****  * FreeModbus Libary: STM32 Port
   3:../FreeModbus/stm32/portevent_m.c ****  * Copyright (C) 2013 Armink <armink.ztl@gmail.com>
   4:../FreeModbus/stm32/portevent_m.c ****  *
   5:../FreeModbus/stm32/portevent_m.c ****  * This library is free software; you can redistribute it and/or
   6:../FreeModbus/stm32/portevent_m.c ****  * modify it under the terms of the GNU Lesser General Public
   7:../FreeModbus/stm32/portevent_m.c ****  * License as published by the Free Software Foundation; either
   8:../FreeModbus/stm32/portevent_m.c ****  * version 2.1 of the License, or (at your option) any later version.
   9:../FreeModbus/stm32/portevent_m.c ****  *
  10:../FreeModbus/stm32/portevent_m.c ****  * This library is distributed in the hope that it will be useful,
  11:../FreeModbus/stm32/portevent_m.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:../FreeModbus/stm32/portevent_m.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13:../FreeModbus/stm32/portevent_m.c ****  * Lesser General Public License for more details.
  14:../FreeModbus/stm32/portevent_m.c ****  *
  15:../FreeModbus/stm32/portevent_m.c ****  * You should have received a copy of the GNU Lesser General Public
  16:../FreeModbus/stm32/portevent_m.c ****  * License along with this library; if not, write to the Free Software
  17:../FreeModbus/stm32/portevent_m.c ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  18:../FreeModbus/stm32/portevent_m.c ****  *
  19:../FreeModbus/stm32/portevent_m.c ****  * File: $Id: portevent_m.c v 1.60 2013/08/13 15:07:05 Armink add Master Functions$
  20:../FreeModbus/stm32/portevent_m.c ****  */
  21:../FreeModbus/stm32/portevent_m.c **** 
  22:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Modbus includes ----------------------------------*/
  23:../FreeModbus/stm32/portevent_m.c **** #include "mb.h"
  24:../FreeModbus/stm32/portevent_m.c **** #include "mb_m.h"
  25:../FreeModbus/stm32/portevent_m.c **** #include "mbport.h"
  26:../FreeModbus/stm32/portevent_m.c **** #include "port.h"
  27:../FreeModbus/stm32/portevent_m.c **** 
  28:../FreeModbus/stm32/portevent_m.c **** #if MB_MASTER_RTU_ENABLED > 0 || MB_MASTER_ASCII_ENABLED > 0
  29:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Defines ------------------------------------------*/
  30:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Variables ----------------------------------------*/
  31:../FreeModbus/stm32/portevent_m.c **** //static struct rt_semaphore xMasterRunRes;
  32:../FreeModbus/stm32/portevent_m.c **** //static struct rt_event     xMasterOsEvent;
  33:../FreeModbus/stm32/portevent_m.c **** static eMBEventType eQueuedEvent;
  34:../FreeModbus/stm32/portevent_m.c **** static BOOL     xEventInQueue;
  35:../FreeModbus/stm32/portevent_m.c **** 
  36:../FreeModbus/stm32/portevent_m.c **** static BOOL xMasterRunRes;
  37:../FreeModbus/stm32/portevent_m.c **** 
  38:../FreeModbus/stm32/portevent_m.c **** /* ----------------------- Start implementation -----------------------------*/
  39:../FreeModbus/stm32/portevent_m.c **** BOOL
  40:../FreeModbus/stm32/portevent_m.c **** xMBMasterPortEventInit( void )
  41:../FreeModbus/stm32/portevent_m.c **** {
  42              		.loc 1 41 0
  43              		.cfi_startproc
  44              		@ args = 0, pretend = 0, frame = 0
  45              		@ frame_needed = 1, uses_anonymous_args = 0
  46              		@ link register save eliminated.
  47 0000 80B4     		push	{r7}
  48              		.cfi_def_cfa_offset 4
  49              		.cfi_offset 7, -4
  50 0002 00AF     		add	r7, sp, #0
  51              		.cfi_def_cfa_register 7
  42:../FreeModbus/stm32/portevent_m.c **** 	//rt_event_init(&xMasterOsEvent,"master event",RT_IPC_FLAG_PRIO);
  43:../FreeModbus/stm32/portevent_m.c **** 	xEventInQueue = FALSE;
  52              		.loc 1 43 0
  53 0004 40F20003 		movw	r3, #:lower16:xEventInQueue
  54 0008 C0F20003 		movt	r3, #:upper16:xEventInQueue
  55 000c 0022     		movs	r2, #0
  56 000e 1A70     		strb	r2, [r3]
  44:../FreeModbus/stm32/portevent_m.c ****     return TRUE;
  57              		.loc 1 44 0
  58 0010 0123     		movs	r3, #1
  45:../FreeModbus/stm32/portevent_m.c **** }
  59              		.loc 1 45 0
  60 0012 1846     		mov	r0, r3
  61 0014 BD46     		mov	sp, r7
  62              		@ sp needed
  63 0016 5DF8047B 		ldr	r7, [sp], #4
  64 001a 7047     		bx	lr
  65              		.cfi_endproc
  66              	.LFE29:
  68              		.section	.text.xMBMasterPortEventPost,"ax",%progbits
  69              		.align	2
  70              		.global	xMBMasterPortEventPost
  71              		.thumb
  72              		.thumb_func
  74              	xMBMasterPortEventPost:
  75              	.LFB30:
  46:../FreeModbus/stm32/portevent_m.c **** 
  47:../FreeModbus/stm32/portevent_m.c **** BOOL
  48:../FreeModbus/stm32/portevent_m.c **** xMBMasterPortEventPost( eMBMasterEventType eEvent )
  49:../FreeModbus/stm32/portevent_m.c **** {
  76              		.loc 1 49 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 8
  79              		@ frame_needed = 1, uses_anonymous_args = 0
  80              		@ link register save eliminated.
  81 0000 80B4     		push	{r7}
  82              		.cfi_def_cfa_offset 4
  83              		.cfi_offset 7, -4
  84 0002 83B0     		sub	sp, sp, #12
  85              		.cfi_def_cfa_offset 16
  86 0004 00AF     		add	r7, sp, #0
  87              		.cfi_def_cfa_register 7
  88 0006 0346     		mov	r3, r0
  89 0008 FB80     		strh	r3, [r7, #6]	@ movhi
  50:../FreeModbus/stm32/portevent_m.c **** 	//rt_event_send(&xMasterOsEvent, eEvent);
  51:../FreeModbus/stm32/portevent_m.c ****     xEventInQueue = TRUE;
  90              		.loc 1 51 0
  91 000a 40F20003 		movw	r3, #:lower16:xEventInQueue
  92 000e C0F20003 		movt	r3, #:upper16:xEventInQueue
  93 0012 0122     		movs	r2, #1
  94 0014 1A70     		strb	r2, [r3]
  52:../FreeModbus/stm32/portevent_m.c ****     eQueuedEvent = eEvent;
  95              		.loc 1 52 0
  96 0016 FB88     		ldrh	r3, [r7, #6]	@ movhi
  97 0018 DAB2     		uxtb	r2, r3
  98 001a 40F20003 		movw	r3, #:lower16:eQueuedEvent
  99 001e C0F20003 		movt	r3, #:upper16:eQueuedEvent
 100 0022 1A70     		strb	r2, [r3]
  53:../FreeModbus/stm32/portevent_m.c ****     return TRUE;
 101              		.loc 1 53 0
 102 0024 0123     		movs	r3, #1
  54:../FreeModbus/stm32/portevent_m.c **** }
 103              		.loc 1 54 0
 104 0026 1846     		mov	r0, r3
 105 0028 0C37     		adds	r7, r7, #12
 106 002a BD46     		mov	sp, r7
 107              		@ sp needed
 108 002c 5DF8047B 		ldr	r7, [sp], #4
 109 0030 7047     		bx	lr
 110              		.cfi_endproc
 111              	.LFE30:
 113 0032 00BF     		.section	.text.xMBMasterPortEventGet,"ax",%progbits
 114              		.align	2
 115              		.global	xMBMasterPortEventGet
 116              		.thumb
 117              		.thumb_func
 119              	xMBMasterPortEventGet:
 120              	.LFB31:
  55:../FreeModbus/stm32/portevent_m.c **** 
  56:../FreeModbus/stm32/portevent_m.c **** BOOL
  57:../FreeModbus/stm32/portevent_m.c **** xMBMasterPortEventGet( eMBMasterEventType * eEvent )
  58:../FreeModbus/stm32/portevent_m.c **** {
 121              		.loc 1 58 0
 122              		.cfi_startproc
 123              		@ args = 0, pretend = 0, frame = 16
 124              		@ frame_needed = 1, uses_anonymous_args = 0
 125              		@ link register save eliminated.
 126 0000 80B4     		push	{r7}
 127              		.cfi_def_cfa_offset 4
 128              		.cfi_offset 7, -4
 129 0002 85B0     		sub	sp, sp, #20
 130              		.cfi_def_cfa_offset 24
 131 0004 00AF     		add	r7, sp, #0
 132              		.cfi_def_cfa_register 7
 133 0006 7860     		str	r0, [r7, #4]
  59:../FreeModbus/stm32/portevent_m.c **** 
  60:../FreeModbus/stm32/portevent_m.c **** 	 BOOL            xEventHappened = FALSE;
 134              		.loc 1 60 0
 135 0008 0023     		movs	r3, #0
 136 000a FB73     		strb	r3, [r7, #15]
  61:../FreeModbus/stm32/portevent_m.c **** 
  62:../FreeModbus/stm32/portevent_m.c **** 	    if( xEventInQueue )
 137              		.loc 1 62 0
 138 000c 40F20003 		movw	r3, #:lower16:xEventInQueue
 139 0010 C0F20003 		movt	r3, #:upper16:xEventInQueue
 140 0014 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 141 0016 002B     		cmp	r3, #0
 142 0018 0FD0     		beq	.L6
  63:../FreeModbus/stm32/portevent_m.c **** 	    {
  64:../FreeModbus/stm32/portevent_m.c **** 	        *eEvent = eQueuedEvent;
 143              		.loc 1 64 0
 144 001a 40F20003 		movw	r3, #:lower16:eQueuedEvent
 145 001e C0F20003 		movt	r3, #:upper16:eQueuedEvent
 146 0022 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 147 0024 1A46     		mov	r2, r3
 148 0026 7B68     		ldr	r3, [r7, #4]
 149 0028 1A80     		strh	r2, [r3]	@ movhi
  65:../FreeModbus/stm32/portevent_m.c **** 	        xEventInQueue = FALSE;
 150              		.loc 1 65 0
 151 002a 40F20003 		movw	r3, #:lower16:xEventInQueue
 152 002e C0F20003 		movt	r3, #:upper16:xEventInQueue
 153 0032 0022     		movs	r2, #0
 154 0034 1A70     		strb	r2, [r3]
  66:../FreeModbus/stm32/portevent_m.c **** 	        xEventHappened = TRUE;
 155              		.loc 1 66 0
 156 0036 0123     		movs	r3, #1
 157 0038 FB73     		strb	r3, [r7, #15]
 158              	.L6:
  67:../FreeModbus/stm32/portevent_m.c **** 	    }
  68:../FreeModbus/stm32/portevent_m.c **** 	    return xEventHappened;
 159              		.loc 1 68 0
 160 003a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
  69:../FreeModbus/stm32/portevent_m.c **** 
  70:../FreeModbus/stm32/portevent_m.c **** 	//rt_uint32_t recvedEvent;
  71:../FreeModbus/stm32/portevent_m.c ****     /* waiting forever OS event */
  72:../FreeModbus/stm32/portevent_m.c **** 	/*
  73:../FreeModbus/stm32/portevent_m.c **** 	rt_event_recv(&xMasterOsEvent,
  74:../FreeModbus/stm32/portevent_m.c **** 			EV_MASTER_READY | EV_MASTER_FRAME_RECEIVED | EV_MASTER_EXECUTE |
  75:../FreeModbus/stm32/portevent_m.c **** 			EV_MASTER_FRAME_SENT | EV_MASTER_ERROR_PROCESS,
  76:../FreeModbus/stm32/portevent_m.c **** 			RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER,
  77:../FreeModbus/stm32/portevent_m.c **** 			&recvedEvent);
  78:../FreeModbus/stm32/portevent_m.c **** 	*/
  79:../FreeModbus/stm32/portevent_m.c **** 	/* the enum type couldn't convert to int type */
  80:../FreeModbus/stm32/portevent_m.c **** 	/*
  81:../FreeModbus/stm32/portevent_m.c **** 	switch (recvedEvent)
  82:../FreeModbus/stm32/portevent_m.c **** 	{
  83:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_READY:
  84:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_READY;
  85:../FreeModbus/stm32/portevent_m.c **** 		break;
  86:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_FRAME_RECEIVED:
  87:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_FRAME_RECEIVED;
  88:../FreeModbus/stm32/portevent_m.c **** 		break;
  89:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_EXECUTE:
  90:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_EXECUTE;
  91:../FreeModbus/stm32/portevent_m.c **** 		break;
  92:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_FRAME_SENT:
  93:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_FRAME_SENT;
  94:../FreeModbus/stm32/portevent_m.c **** 		break;
  95:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_PROCESS:
  96:../FreeModbus/stm32/portevent_m.c **** 		*eEvent = EV_MASTER_ERROR_PROCESS;
  97:../FreeModbus/stm32/portevent_m.c **** 		break;
  98:../FreeModbus/stm32/portevent_m.c **** 	}
  99:../FreeModbus/stm32/portevent_m.c ****     return TRUE;
 100:../FreeModbus/stm32/portevent_m.c ****     */
 101:../FreeModbus/stm32/portevent_m.c **** 
 102:../FreeModbus/stm32/portevent_m.c **** }
 161              		.loc 1 102 0
 162 003c 1846     		mov	r0, r3
 163 003e 1437     		adds	r7, r7, #20
 164 0040 BD46     		mov	sp, r7
 165              		@ sp needed
 166 0042 5DF8047B 		ldr	r7, [sp], #4
 167 0046 7047     		bx	lr
 168              		.cfi_endproc
 169              	.LFE31:
 171              		.section	.text.vMBMasterOsResInit,"ax",%progbits
 172              		.align	2
 173              		.global	vMBMasterOsResInit
 174              		.thumb
 175              		.thumb_func
 177              	vMBMasterOsResInit:
 178              	.LFB32:
 103:../FreeModbus/stm32/portevent_m.c **** /**
 104:../FreeModbus/stm32/portevent_m.c ****  * This function is initialize the OS resource for modbus master.
 105:../FreeModbus/stm32/portevent_m.c ****  * Note:The resource is define by OS.If you not use OS this function can be empty.
 106:../FreeModbus/stm32/portevent_m.c ****  *
 107:../FreeModbus/stm32/portevent_m.c ****  */
 108:../FreeModbus/stm32/portevent_m.c **** void vMBMasterOsResInit( void )
 109:../FreeModbus/stm32/portevent_m.c **** {
 179              		.loc 1 109 0
 180              		.cfi_startproc
 181              		@ args = 0, pretend = 0, frame = 0
 182              		@ frame_needed = 1, uses_anonymous_args = 0
 183 0000 80B5     		push	{r7, lr}
 184              		.cfi_def_cfa_offset 8
 185              		.cfi_offset 7, -8
 186              		.cfi_offset 14, -4
 187 0002 00AF     		add	r7, sp, #0
 188              		.cfi_def_cfa_register 7
 110:../FreeModbus/stm32/portevent_m.c **** //	rt_sem_init(&xMasterRunRes, "master res", 0x01 , RT_IPC_FLAG_PRIO);
 111:../FreeModbus/stm32/portevent_m.c **** 	ENTER_CRITICAL_SECTION( );
 189              		.loc 1 111 0
 190 0004 FFF7FEFF 		bl	vPortEnterCritical
 112:../FreeModbus/stm32/portevent_m.c **** 	xMasterRunRes = 1;
 191              		.loc 1 112 0
 192 0008 40F20003 		movw	r3, #:lower16:xMasterRunRes
 193 000c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 194 0010 0122     		movs	r2, #1
 195 0012 1A70     		strb	r2, [r3]
 113:../FreeModbus/stm32/portevent_m.c **** 	EXIT_CRITICAL_SECTION( );
 196              		.loc 1 113 0
 197 0014 FFF7FEFF 		bl	vPortExitCritical
 114:../FreeModbus/stm32/portevent_m.c **** }
 198              		.loc 1 114 0
 199 0018 80BD     		pop	{r7, pc}
 200              		.cfi_endproc
 201              	.LFE32:
 203 001a 00BF     		.section	.text.xMBMasterRunResTake,"ax",%progbits
 204              		.align	2
 205              		.global	xMBMasterRunResTake
 206              		.thumb
 207              		.thumb_func
 209              	xMBMasterRunResTake:
 210              	.LFB33:
 115:../FreeModbus/stm32/portevent_m.c **** 
 116:../FreeModbus/stm32/portevent_m.c **** /**
 117:../FreeModbus/stm32/portevent_m.c ****  * This function is take Mobus Master running resource.
 118:../FreeModbus/stm32/portevent_m.c ****  * Note:The resource is define by Operating System.If you not use OS this function can be just retu
 119:../FreeModbus/stm32/portevent_m.c ****  *
 120:../FreeModbus/stm32/portevent_m.c ****  * @param lTimeOut the waiting time.
 121:../FreeModbus/stm32/portevent_m.c ****  *
 122:../FreeModbus/stm32/portevent_m.c ****  * @return resource taked result
 123:../FreeModbus/stm32/portevent_m.c ****  */
 124:../FreeModbus/stm32/portevent_m.c **** BOOL xMBMasterRunResTake( LONG lTimeOut )
 125:../FreeModbus/stm32/portevent_m.c **** {
 211              		.loc 1 125 0
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 8
 214              		@ frame_needed = 1, uses_anonymous_args = 0
 215 0000 80B5     		push	{r7, lr}
 216              		.cfi_def_cfa_offset 8
 217              		.cfi_offset 7, -8
 218              		.cfi_offset 14, -4
 219 0002 82B0     		sub	sp, sp, #8
 220              		.cfi_def_cfa_offset 16
 221 0004 00AF     		add	r7, sp, #0
 222              		.cfi_def_cfa_register 7
 223 0006 7860     		str	r0, [r7, #4]
 126:../FreeModbus/stm32/portevent_m.c **** 	/*If waiting time is -1 .It will wait forever */
 127:../FreeModbus/stm32/portevent_m.c **** //	return rt_sem_take(&xMasterRunRes, lTimeOut) ? FALSE : TRUE ;
 128:../FreeModbus/stm32/portevent_m.c **** 	ENTER_CRITICAL_SECTION( );
 224              		.loc 1 128 0
 225 0008 FFF7FEFF 		bl	vPortEnterCritical
 129:../FreeModbus/stm32/portevent_m.c ****     if ( xMasterRunRes >0 ) {
 226              		.loc 1 129 0
 227 000c 40F20003 		movw	r3, #:lower16:xMasterRunRes
 228 0010 C0F20003 		movt	r3, #:upper16:xMasterRunRes
 229 0014 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 230 0016 002B     		cmp	r3, #0
 231 0018 0FD0     		beq	.L10
 130:../FreeModbus/stm32/portevent_m.c ****     	xMasterRunRes--;
 232              		.loc 1 130 0
 233 001a 40F20003 		movw	r3, #:lower16:xMasterRunRes
 234 001e C0F20003 		movt	r3, #:upper16:xMasterRunRes
 235 0022 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 236 0024 013B     		subs	r3, r3, #1
 237 0026 DAB2     		uxtb	r2, r3
 238 0028 40F20003 		movw	r3, #:lower16:xMasterRunRes
 239 002c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 240 0030 1A70     		strb	r2, [r3]
 131:../FreeModbus/stm32/portevent_m.c ****     	EXIT_CRITICAL_SECTION( );
 241              		.loc 1 131 0
 242 0032 FFF7FEFF 		bl	vPortExitCritical
 132:../FreeModbus/stm32/portevent_m.c ****     }
 133:../FreeModbus/stm32/portevent_m.c ****     else {
 134:../FreeModbus/stm32/portevent_m.c ****       	EXIT_CRITICAL_SECTION( );
 135:../FreeModbus/stm32/portevent_m.c **** 
 136:../FreeModbus/stm32/portevent_m.c ****       	if ( lTimeOut == -1 ) {
 137:../FreeModbus/stm32/portevent_m.c **** 		    while ( !xMasterRunRes ) ;
 138:../FreeModbus/stm32/portevent_m.c **** 		        return  TRUE;
 139:../FreeModbus/stm32/portevent_m.c **** 	    }
 140:../FreeModbus/stm32/portevent_m.c **** 	    else {
 141:../FreeModbus/stm32/portevent_m.c **** 		    while ( 1 ) {
 142:../FreeModbus/stm32/portevent_m.c **** 
 143:../FreeModbus/stm32/portevent_m.c **** 			if ( lTimeOut == 0 )
 144:../FreeModbus/stm32/portevent_m.c **** 				break;
 145:../FreeModbus/stm32/portevent_m.c **** 
 146:../FreeModbus/stm32/portevent_m.c **** 			if ( xMasterRunRes )
 147:../FreeModbus/stm32/portevent_m.c **** 				return  TRUE;
 148:../FreeModbus/stm32/portevent_m.c **** 
 149:../FreeModbus/stm32/portevent_m.c **** 			lTimeOut--;
 150:../FreeModbus/stm32/portevent_m.c **** 		    }
 151:../FreeModbus/stm32/portevent_m.c **** 	    }
 152:../FreeModbus/stm32/portevent_m.c **** 
 153:../FreeModbus/stm32/portevent_m.c ****         return FALSE;
 154:../FreeModbus/stm32/portevent_m.c ****     }
 155:../FreeModbus/stm32/portevent_m.c **** 
 156:../FreeModbus/stm32/portevent_m.c **** 	return  TRUE;
 243              		.loc 1 156 0
 244 0036 0123     		movs	r3, #1
 245 0038 22E0     		b	.L14
 246              	.L10:
 134:../FreeModbus/stm32/portevent_m.c **** 
 247              		.loc 1 134 0
 248 003a FFF7FEFF 		bl	vPortExitCritical
 136:../FreeModbus/stm32/portevent_m.c **** 		    while ( !xMasterRunRes ) ;
 249              		.loc 1 136 0
 250 003e 7B68     		ldr	r3, [r7, #4]
 251 0040 B3F1FF3F 		cmp	r3, #-1
 252 0044 09D1     		bne	.L12
 137:../FreeModbus/stm32/portevent_m.c **** 		        return  TRUE;
 253              		.loc 1 137 0
 254 0046 00BF     		nop
 255              	.L13:
 137:../FreeModbus/stm32/portevent_m.c **** 		        return  TRUE;
 256              		.loc 1 137 0 is_stmt 0 discriminator 1
 257 0048 40F20003 		movw	r3, #:lower16:xMasterRunRes
 258 004c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 259 0050 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 260 0052 002B     		cmp	r3, #0
 261 0054 F8D0     		beq	.L13
 138:../FreeModbus/stm32/portevent_m.c **** 	    }
 262              		.loc 1 138 0 is_stmt 1
 263 0056 0123     		movs	r3, #1
 264 0058 12E0     		b	.L14
 265              	.L12:
 143:../FreeModbus/stm32/portevent_m.c **** 				break;
 266              		.loc 1 143 0
 267 005a 7B68     		ldr	r3, [r7, #4]
 268 005c 002B     		cmp	r3, #0
 269 005e 02D1     		bne	.L15
 144:../FreeModbus/stm32/portevent_m.c **** 
 270              		.loc 1 144 0
 271 0060 00BF     		nop
 153:../FreeModbus/stm32/portevent_m.c ****     }
 272              		.loc 1 153 0
 273 0062 0023     		movs	r3, #0
 274 0064 0CE0     		b	.L14
 275              	.L15:
 146:../FreeModbus/stm32/portevent_m.c **** 				return  TRUE;
 276              		.loc 1 146 0
 277 0066 40F20003 		movw	r3, #:lower16:xMasterRunRes
 278 006a C0F20003 		movt	r3, #:upper16:xMasterRunRes
 279 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 280 0070 002B     		cmp	r3, #0
 281 0072 01D0     		beq	.L17
 147:../FreeModbus/stm32/portevent_m.c **** 
 282              		.loc 1 147 0
 283 0074 0123     		movs	r3, #1
 284 0076 03E0     		b	.L14
 285              	.L17:
 149:../FreeModbus/stm32/portevent_m.c **** 		    }
 286              		.loc 1 149 0
 287 0078 7B68     		ldr	r3, [r7, #4]
 288 007a 013B     		subs	r3, r3, #1
 289 007c 7B60     		str	r3, [r7, #4]
 150:../FreeModbus/stm32/portevent_m.c **** 	    }
 290              		.loc 1 150 0
 291 007e ECE7     		b	.L12
 292              	.L14:
 157:../FreeModbus/stm32/portevent_m.c ****     //return  FALSE;
 158:../FreeModbus/stm32/portevent_m.c **** }
 293              		.loc 1 158 0
 294 0080 1846     		mov	r0, r3
 295 0082 0837     		adds	r7, r7, #8
 296 0084 BD46     		mov	sp, r7
 297              		@ sp needed
 298 0086 80BD     		pop	{r7, pc}
 299              		.cfi_endproc
 300              	.LFE33:
 302              		.section	.text.vMBMasterRunResRelease,"ax",%progbits
 303              		.align	2
 304              		.global	vMBMasterRunResRelease
 305              		.thumb
 306              		.thumb_func
 308              	vMBMasterRunResRelease:
 309              	.LFB34:
 159:../FreeModbus/stm32/portevent_m.c **** 
 160:../FreeModbus/stm32/portevent_m.c **** /**
 161:../FreeModbus/stm32/portevent_m.c ****  * This function is release Mobus Master running resource.
 162:../FreeModbus/stm32/portevent_m.c ****  * Note:The resource is define by Operating System.If you not use OS this function can be empty.
 163:../FreeModbus/stm32/portevent_m.c ****  *
 164:../FreeModbus/stm32/portevent_m.c ****  */
 165:../FreeModbus/stm32/portevent_m.c **** void vMBMasterRunResRelease( void )
 166:../FreeModbus/stm32/portevent_m.c **** {
 310              		.loc 1 166 0
 311              		.cfi_startproc
 312              		@ args = 0, pretend = 0, frame = 0
 313              		@ frame_needed = 1, uses_anonymous_args = 0
 314 0000 80B5     		push	{r7, lr}
 315              		.cfi_def_cfa_offset 8
 316              		.cfi_offset 7, -8
 317              		.cfi_offset 14, -4
 318 0002 00AF     		add	r7, sp, #0
 319              		.cfi_def_cfa_register 7
 167:../FreeModbus/stm32/portevent_m.c **** 	/* release resource */
 168:../FreeModbus/stm32/portevent_m.c **** //	rt_sem_release(&xMasterRunRes);
 169:../FreeModbus/stm32/portevent_m.c **** 	ENTER_CRITICAL_SECTION( );
 320              		.loc 1 169 0
 321 0004 FFF7FEFF 		bl	vPortEnterCritical
 170:../FreeModbus/stm32/portevent_m.c **** 	xMasterRunRes += 1;
 322              		.loc 1 170 0
 323 0008 40F20003 		movw	r3, #:lower16:xMasterRunRes
 324 000c C0F20003 		movt	r3, #:upper16:xMasterRunRes
 325 0010 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 326 0012 0133     		adds	r3, r3, #1
 327 0014 DAB2     		uxtb	r2, r3
 328 0016 40F20003 		movw	r3, #:lower16:xMasterRunRes
 329 001a C0F20003 		movt	r3, #:upper16:xMasterRunRes
 330 001e 1A70     		strb	r2, [r3]
 171:../FreeModbus/stm32/portevent_m.c **** 	EXIT_CRITICAL_SECTION( );
 331              		.loc 1 171 0
 332 0020 FFF7FEFF 		bl	vPortExitCritical
 172:../FreeModbus/stm32/portevent_m.c **** }
 333              		.loc 1 172 0
 334 0024 80BD     		pop	{r7, pc}
 335              		.cfi_endproc
 336              	.LFE34:
 338 0026 00BF     		.section	.text.vMBMasterErrorCBRespondTimeout,"ax",%progbits
 339              		.align	2
 340              		.global	vMBMasterErrorCBRespondTimeout
 341              		.thumb
 342              		.thumb_func
 344              	vMBMasterErrorCBRespondTimeout:
 345              	.LFB35:
 173:../FreeModbus/stm32/portevent_m.c **** 
 174:../FreeModbus/stm32/portevent_m.c **** /**
 175:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master respond timeout error process callback function.
 176:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 177:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 178:../FreeModbus/stm32/portevent_m.c ****  *
 179:../FreeModbus/stm32/portevent_m.c ****  * @param ucDestAddress destination salve address
 180:../FreeModbus/stm32/portevent_m.c ****  * @param pucPDUData PDU buffer data
 181:../FreeModbus/stm32/portevent_m.c ****  * @param ucPDULength PDU buffer length
 182:../FreeModbus/stm32/portevent_m.c ****  *
 183:../FreeModbus/stm32/portevent_m.c ****  */
 184:../FreeModbus/stm32/portevent_m.c **** void vMBMasterErrorCBRespondTimeout(UCHAR ucDestAddress, const UCHAR* pucPDUData,
 185:../FreeModbus/stm32/portevent_m.c **** 		USHORT ucPDULength) {
 346              		.loc 1 185 0
 347              		.cfi_startproc
 348              		@ args = 0, pretend = 0, frame = 8
 349              		@ frame_needed = 1, uses_anonymous_args = 0
 350 0000 80B5     		push	{r7, lr}
 351              		.cfi_def_cfa_offset 8
 352              		.cfi_offset 7, -8
 353              		.cfi_offset 14, -4
 354 0002 82B0     		sub	sp, sp, #8
 355              		.cfi_def_cfa_offset 16
 356 0004 00AF     		add	r7, sp, #0
 357              		.cfi_def_cfa_register 7
 358 0006 3960     		str	r1, [r7]
 359 0008 1346     		mov	r3, r2
 360 000a 0246     		mov	r2, r0
 361 000c FA71     		strb	r2, [r7, #7]
 362 000e BB80     		strh	r3, [r7, #4]	@ movhi
 186:../FreeModbus/stm32/portevent_m.c **** 	/**
 187:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 188:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 189:../FreeModbus/stm32/portevent_m.c **** 	 */
 190:../FreeModbus/stm32/portevent_m.c **** //	rt_event_send(&xMasterOsEvent, EV_MASTER_ERROR_RESPOND_TIMEOUT);
 191:../FreeModbus/stm32/portevent_m.c **** 	xMBMasterPortEventPost( EV_MASTER_ERROR_RESPOND_TIMEOUT );
 363              		.loc 1 191 0
 364 0010 4020     		movs	r0, #64
 365 0012 FFF7FEFF 		bl	xMBMasterPortEventPost
 192:../FreeModbus/stm32/portevent_m.c **** 
 193:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 194:../FreeModbus/stm32/portevent_m.c **** 
 195:../FreeModbus/stm32/portevent_m.c **** }
 366              		.loc 1 195 0
 367 0016 0837     		adds	r7, r7, #8
 368 0018 BD46     		mov	sp, r7
 369              		@ sp needed
 370 001a 80BD     		pop	{r7, pc}
 371              		.cfi_endproc
 372              	.LFE35:
 374              		.section	.text.vMBMasterErrorCBReceiveData,"ax",%progbits
 375              		.align	2
 376              		.global	vMBMasterErrorCBReceiveData
 377              		.thumb
 378              		.thumb_func
 380              	vMBMasterErrorCBReceiveData:
 381              	.LFB36:
 196:../FreeModbus/stm32/portevent_m.c **** 
 197:../FreeModbus/stm32/portevent_m.c **** /**
 198:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master receive data error process callback function.
 199:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 200:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 201:../FreeModbus/stm32/portevent_m.c ****  *
 202:../FreeModbus/stm32/portevent_m.c ****  * @param ucDestAddress destination salve address
 203:../FreeModbus/stm32/portevent_m.c ****  * @param pucPDUData PDU buffer data
 204:../FreeModbus/stm32/portevent_m.c ****  * @param ucPDULength PDU buffer length
 205:../FreeModbus/stm32/portevent_m.c ****  *
 206:../FreeModbus/stm32/portevent_m.c ****  */
 207:../FreeModbus/stm32/portevent_m.c **** void vMBMasterErrorCBReceiveData(UCHAR ucDestAddress, const UCHAR* pucPDUData,
 208:../FreeModbus/stm32/portevent_m.c **** 		USHORT ucPDULength) {
 382              		.loc 1 208 0
 383              		.cfi_startproc
 384              		@ args = 0, pretend = 0, frame = 8
 385              		@ frame_needed = 1, uses_anonymous_args = 0
 386 0000 80B5     		push	{r7, lr}
 387              		.cfi_def_cfa_offset 8
 388              		.cfi_offset 7, -8
 389              		.cfi_offset 14, -4
 390 0002 82B0     		sub	sp, sp, #8
 391              		.cfi_def_cfa_offset 16
 392 0004 00AF     		add	r7, sp, #0
 393              		.cfi_def_cfa_register 7
 394 0006 3960     		str	r1, [r7]
 395 0008 1346     		mov	r3, r2
 396 000a 0246     		mov	r2, r0
 397 000c FA71     		strb	r2, [r7, #7]
 398 000e BB80     		strh	r3, [r7, #4]	@ movhi
 209:../FreeModbus/stm32/portevent_m.c **** 	/**
 210:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 211:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 212:../FreeModbus/stm32/portevent_m.c **** 	 */
 213:../FreeModbus/stm32/portevent_m.c **** //	rt_event_send(&xMasterOsEvent, EV_MASTER_ERROR_RECEIVE_DATA);
 214:../FreeModbus/stm32/portevent_m.c **** 	xMBMasterPortEventPost( EV_MASTER_ERROR_RECEIVE_DATA);
 399              		.loc 1 214 0
 400 0010 8020     		movs	r0, #128
 401 0012 FFF7FEFF 		bl	xMBMasterPortEventPost
 215:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 216:../FreeModbus/stm32/portevent_m.c **** 
 217:../FreeModbus/stm32/portevent_m.c **** }
 402              		.loc 1 217 0
 403 0016 0837     		adds	r7, r7, #8
 404 0018 BD46     		mov	sp, r7
 405              		@ sp needed
 406 001a 80BD     		pop	{r7, pc}
 407              		.cfi_endproc
 408              	.LFE36:
 410              		.section	.text.vMBMasterErrorCBExecuteFunction,"ax",%progbits
 411              		.align	2
 412              		.global	vMBMasterErrorCBExecuteFunction
 413              		.thumb
 414              		.thumb_func
 416              	vMBMasterErrorCBExecuteFunction:
 417              	.LFB37:
 218:../FreeModbus/stm32/portevent_m.c **** 
 219:../FreeModbus/stm32/portevent_m.c **** /**
 220:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master execute function error process callback function.
 221:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 222:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 223:../FreeModbus/stm32/portevent_m.c ****  *
 224:../FreeModbus/stm32/portevent_m.c ****  * @param ucDestAddress destination salve address
 225:../FreeModbus/stm32/portevent_m.c ****  * @param pucPDUData PDU buffer data
 226:../FreeModbus/stm32/portevent_m.c ****  * @param ucPDULength PDU buffer length
 227:../FreeModbus/stm32/portevent_m.c ****  *
 228:../FreeModbus/stm32/portevent_m.c ****  */
 229:../FreeModbus/stm32/portevent_m.c **** void vMBMasterErrorCBExecuteFunction(UCHAR ucDestAddress, const UCHAR* pucPDUData,
 230:../FreeModbus/stm32/portevent_m.c **** 		USHORT ucPDULength) {
 418              		.loc 1 230 0
 419              		.cfi_startproc
 420              		@ args = 0, pretend = 0, frame = 8
 421              		@ frame_needed = 1, uses_anonymous_args = 0
 422 0000 80B5     		push	{r7, lr}
 423              		.cfi_def_cfa_offset 8
 424              		.cfi_offset 7, -8
 425              		.cfi_offset 14, -4
 426 0002 82B0     		sub	sp, sp, #8
 427              		.cfi_def_cfa_offset 16
 428 0004 00AF     		add	r7, sp, #0
 429              		.cfi_def_cfa_register 7
 430 0006 3960     		str	r1, [r7]
 431 0008 1346     		mov	r3, r2
 432 000a 0246     		mov	r2, r0
 433 000c FA71     		strb	r2, [r7, #7]
 434 000e BB80     		strh	r3, [r7, #4]	@ movhi
 231:../FreeModbus/stm32/portevent_m.c **** 	/**
 232:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 233:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 234:../FreeModbus/stm32/portevent_m.c **** 	 */
 235:../FreeModbus/stm32/portevent_m.c **** 	//rt_event_send(&xMasterOsEvent, EV_MASTER_ERROR_EXECUTE_FUNCTION);
 236:../FreeModbus/stm32/portevent_m.c **** 	xMBMasterPortEventPost( EV_MASTER_ERROR_EXECUTE_FUNCTION);
 435              		.loc 1 236 0
 436 0010 4FF48070 		mov	r0, #256
 437 0014 FFF7FEFF 		bl	xMBMasterPortEventPost
 237:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 238:../FreeModbus/stm32/portevent_m.c **** 
 239:../FreeModbus/stm32/portevent_m.c **** }
 438              		.loc 1 239 0
 439 0018 0837     		adds	r7, r7, #8
 440 001a BD46     		mov	sp, r7
 441              		@ sp needed
 442 001c 80BD     		pop	{r7, pc}
 443              		.cfi_endproc
 444              	.LFE37:
 446 001e 00BF     		.section	.text.vMBMasterCBRequestSuccess,"ax",%progbits
 447              		.align	2
 448              		.global	vMBMasterCBRequestSuccess
 449              		.thumb
 450              		.thumb_func
 452              	vMBMasterCBRequestSuccess:
 453              	.LFB38:
 240:../FreeModbus/stm32/portevent_m.c **** 
 241:../FreeModbus/stm32/portevent_m.c **** /**
 242:../FreeModbus/stm32/portevent_m.c ****  * This is modbus master request process success callback function.
 243:../FreeModbus/stm32/portevent_m.c ****  * @note There functions will block modbus master poll while execute OS waiting.
 244:../FreeModbus/stm32/portevent_m.c ****  * So,for real-time of system.Do not execute too much waiting process.
 245:../FreeModbus/stm32/portevent_m.c ****  *
 246:../FreeModbus/stm32/portevent_m.c ****  */
 247:../FreeModbus/stm32/portevent_m.c **** void vMBMasterCBRequestSuccess( void ) {
 454              		.loc 1 247 0
 455              		.cfi_startproc
 456              		@ args = 0, pretend = 0, frame = 0
 457              		@ frame_needed = 1, uses_anonymous_args = 0
 458 0000 80B5     		push	{r7, lr}
 459              		.cfi_def_cfa_offset 8
 460              		.cfi_offset 7, -8
 461              		.cfi_offset 14, -4
 462 0002 00AF     		add	r7, sp, #0
 463              		.cfi_def_cfa_register 7
 248:../FreeModbus/stm32/portevent_m.c **** 	/**
 249:../FreeModbus/stm32/portevent_m.c **** 	 * @note This code is use OS's event mechanism for modbus master protocol stack.
 250:../FreeModbus/stm32/portevent_m.c **** 	 * If you don't use OS, you can change it.
 251:../FreeModbus/stm32/portevent_m.c **** 	 */
 252:../FreeModbus/stm32/portevent_m.c **** //	rt_event_send(&xMasterOsEvent, EV_MASTER_PROCESS_SUCESS);
 253:../FreeModbus/stm32/portevent_m.c **** 	xMBMasterPortEventPost( EV_MASTER_PROCESS_SUCESS);
 464              		.loc 1 253 0
 465 0004 2020     		movs	r0, #32
 466 0006 FFF7FEFF 		bl	xMBMasterPortEventPost
 254:../FreeModbus/stm32/portevent_m.c **** 	/* You can add your code under here. */
 255:../FreeModbus/stm32/portevent_m.c **** 
 256:../FreeModbus/stm32/portevent_m.c **** }
 467              		.loc 1 256 0
 468 000a 80BD     		pop	{r7, pc}
 469              		.cfi_endproc
 470              	.LFE38:
 472              		.section	.text.eMBMasterWaitRequestFinish,"ax",%progbits
 473              		.align	2
 474              		.global	eMBMasterWaitRequestFinish
 475              		.thumb
 476              		.thumb_func
 478              	eMBMasterWaitRequestFinish:
 479              	.LFB39:
 257:../FreeModbus/stm32/portevent_m.c **** 
 258:../FreeModbus/stm32/portevent_m.c **** /**
 259:../FreeModbus/stm32/portevent_m.c ****  * This function is wait for modbus master request finish and return result.
 260:../FreeModbus/stm32/portevent_m.c ****  * Waiting result include request process success, request respond timeout,
 261:../FreeModbus/stm32/portevent_m.c ****  * receive data error and execute function error.You can use the above callback function.
 262:../FreeModbus/stm32/portevent_m.c ****  * @note If you are use OS, you can use OS's event mechanism. Otherwise you have to run
 263:../FreeModbus/stm32/portevent_m.c ****  * much user custom delay for waiting.
 264:../FreeModbus/stm32/portevent_m.c ****  *
 265:../FreeModbus/stm32/portevent_m.c ****  * @return request error code
 266:../FreeModbus/stm32/portevent_m.c ****  */
 267:../FreeModbus/stm32/portevent_m.c **** eMBMasterReqErrCode eMBMasterWaitRequestFinish( void ) {
 480              		.loc 1 267 0
 481              		.cfi_startproc
 482              		@ args = 0, pretend = 0, frame = 8
 483              		@ frame_needed = 1, uses_anonymous_args = 0
 484              		@ link register save eliminated.
 485 0000 80B4     		push	{r7}
 486              		.cfi_def_cfa_offset 4
 487              		.cfi_offset 7, -4
 488 0002 83B0     		sub	sp, sp, #12
 489              		.cfi_def_cfa_offset 16
 490 0004 00AF     		add	r7, sp, #0
 491              		.cfi_def_cfa_register 7
 268:../FreeModbus/stm32/portevent_m.c **** 
 269:../FreeModbus/stm32/portevent_m.c **** 	eMBMasterReqErrCode    eErrStatus = MB_MRE_NO_ERR;
 492              		.loc 1 269 0
 493 0006 0023     		movs	r3, #0
 494 0008 FB71     		strb	r3, [r7, #7]
 270:../FreeModbus/stm32/portevent_m.c ****     uint32_t recvedEvent;
 271:../FreeModbus/stm32/portevent_m.c **** 
 272:../FreeModbus/stm32/portevent_m.c ****     //u32 i;
 273:../FreeModbus/stm32/portevent_m.c ****     //for (i=0;i<2400000;i++);
 274:../FreeModbus/stm32/portevent_m.c ****     /* waiting for OS event */
 275:../FreeModbus/stm32/portevent_m.c **** //	rt_event_recv(&xMasterOsEvent,
 276:../FreeModbus/stm32/portevent_m.c **** //			EV_MASTER_PROCESS_SUCESS | EV_MASTER_ERROR_RESPOND_TIMEOUT
 277:../FreeModbus/stm32/portevent_m.c **** //					| EV_MASTER_ERROR_RECEIVE_DATA
 278:../FreeModbus/stm32/portevent_m.c **** //					| EV_MASTER_ERROR_EXECUTE_FUNCTION,
 279:../FreeModbus/stm32/portevent_m.c **** //			         &recvedEvent);
 280:../FreeModbus/stm32/portevent_m.c **** 
 281:../FreeModbus/stm32/portevent_m.c ****    // BOOL            xEventHappened = FALSE;
 282:../FreeModbus/stm32/portevent_m.c **** 
 283:../FreeModbus/stm32/portevent_m.c ****     	    if( xEventInQueue )
 495              		.loc 1 283 0
 496 000a 40F20003 		movw	r3, #:lower16:xEventInQueue
 497 000e C0F20003 		movt	r3, #:upper16:xEventInQueue
 498 0012 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 499 0014 002B     		cmp	r3, #0
 500 0016 05D0     		beq	.L24
 284:../FreeModbus/stm32/portevent_m.c ****    	    {
 285:../FreeModbus/stm32/portevent_m.c ****    	    	recvedEvent = eQueuedEvent;
 501              		.loc 1 285 0
 502 0018 40F20003 		movw	r3, #:lower16:eQueuedEvent
 503 001c C0F20003 		movt	r3, #:upper16:eQueuedEvent
 504 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 505 0022 3B60     		str	r3, [r7]
 506              	.L24:
 286:../FreeModbus/stm32/portevent_m.c **** //   	        xEventInQueue = FALSE;
 287:../FreeModbus/stm32/portevent_m.c **** //   	        xEventHappened = TRUE;
 288:../FreeModbus/stm32/portevent_m.c ****    	    }
 289:../FreeModbus/stm32/portevent_m.c ****  //   	    return xEventHappened;
 290:../FreeModbus/stm32/portevent_m.c **** 
 291:../FreeModbus/stm32/portevent_m.c **** 	switch (recvedEvent)
 507              		.loc 1 291 0
 508 0024 3B68     		ldr	r3, [r7]
 509 0026 402B     		cmp	r3, #64
 510 0028 09D0     		beq	.L26
 511 002a 402B     		cmp	r3, #64
 512 002c 01D8     		bhi	.L27
 513 002e 202B     		cmp	r3, #32
 292:../FreeModbus/stm32/portevent_m.c **** 	{
 293:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_PROCESS_SUCESS:
 294:../FreeModbus/stm32/portevent_m.c **** 		break;
 514              		.loc 1 294 0
 515 0030 0EE0     		b	.L25
 516              	.L27:
 291:../FreeModbus/stm32/portevent_m.c **** 	{
 517              		.loc 1 291 0
 518 0032 802B     		cmp	r3, #128
 519 0034 06D0     		beq	.L29
 520 0036 B3F5807F 		cmp	r3, #256
 521 003a 06D0     		beq	.L30
 522 003c 08E0     		b	.L25
 523              	.L26:
 295:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_RESPOND_TIMEOUT:
 296:../FreeModbus/stm32/portevent_m.c **** 	{
 297:../FreeModbus/stm32/portevent_m.c **** 		eErrStatus = MB_MRE_TIMEDOUT;
 524              		.loc 1 297 0
 525 003e 0423     		movs	r3, #4
 526 0040 FB71     		strb	r3, [r7, #7]
 298:../FreeModbus/stm32/portevent_m.c **** 		break;
 527              		.loc 1 298 0
 528 0042 05E0     		b	.L25
 529              	.L29:
 299:../FreeModbus/stm32/portevent_m.c **** 	}
 300:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_RECEIVE_DATA:
 301:../FreeModbus/stm32/portevent_m.c **** 	{
 302:../FreeModbus/stm32/portevent_m.c **** 		eErrStatus = MB_MRE_REV_DATA;
 530              		.loc 1 302 0
 531 0044 0323     		movs	r3, #3
 532 0046 FB71     		strb	r3, [r7, #7]
 303:../FreeModbus/stm32/portevent_m.c **** 		break;
 533              		.loc 1 303 0
 534 0048 02E0     		b	.L25
 535              	.L30:
 304:../FreeModbus/stm32/portevent_m.c **** 	}
 305:../FreeModbus/stm32/portevent_m.c **** 	case EV_MASTER_ERROR_EXECUTE_FUNCTION:
 306:../FreeModbus/stm32/portevent_m.c **** 	{
 307:../FreeModbus/stm32/portevent_m.c **** 		eErrStatus = MB_MRE_EXE_FUN;
 536              		.loc 1 307 0
 537 004a 0623     		movs	r3, #6
 538 004c FB71     		strb	r3, [r7, #7]
 308:../FreeModbus/stm32/portevent_m.c **** 		break;
 539              		.loc 1 308 0
 540 004e 00BF     		nop
 541              	.L25:
 309:../FreeModbus/stm32/portevent_m.c **** 	}
 310:../FreeModbus/stm32/portevent_m.c **** 	}
 311:../FreeModbus/stm32/portevent_m.c ****     return eErrStatus;
 542              		.loc 1 311 0
 543 0050 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 312:../FreeModbus/stm32/portevent_m.c **** }
 544              		.loc 1 312 0
 545 0052 1846     		mov	r0, r3
 546 0054 0C37     		adds	r7, r7, #12
 547 0056 BD46     		mov	sp, r7
 548              		@ sp needed
 549 0058 5DF8047B 		ldr	r7, [sp], #4
 550 005c 7047     		bx	lr
 551              		.cfi_endproc
 552              	.LFE39:
 554 005e 00BF     		.text
 555              	.Letext0:
 556              		.file 2 "c:\\tools\\arm-none-eabi\\include\\stdint.h"
 557              		.file 3 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\stm32/port.h"
 558              		.file 4 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\include/mbport.h"
 559              		.file 5 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\include/mb_m.h"
 560              		.file 6 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\Libraries\\CMSIS/core_cm3.h"
DEFINED SYMBOLS
                            *ABS*:00000000 portevent_m.c
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:21     .bss.eQueuedEvent:00000000 eQueuedEvent
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:22     .bss.eQueuedEvent:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:26     .bss.xEventInQueue:00000000 xEventInQueue
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:27     .bss.xEventInQueue:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:31     .bss.xMasterRunRes:00000000 xMasterRunRes
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:32     .bss.xMasterRunRes:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:34     .text.xMBMasterPortEventInit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:39     .text.xMBMasterPortEventInit:00000000 xMBMasterPortEventInit
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:69     .text.xMBMasterPortEventPost:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:74     .text.xMBMasterPortEventPost:00000000 xMBMasterPortEventPost
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:114    .text.xMBMasterPortEventGet:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:119    .text.xMBMasterPortEventGet:00000000 xMBMasterPortEventGet
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:172    .text.vMBMasterOsResInit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:177    .text.vMBMasterOsResInit:00000000 vMBMasterOsResInit
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:204    .text.xMBMasterRunResTake:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:209    .text.xMBMasterRunResTake:00000000 xMBMasterRunResTake
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:303    .text.vMBMasterRunResRelease:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:308    .text.vMBMasterRunResRelease:00000000 vMBMasterRunResRelease
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:339    .text.vMBMasterErrorCBRespondTimeout:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:344    .text.vMBMasterErrorCBRespondTimeout:00000000 vMBMasterErrorCBRespondTimeout
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:375    .text.vMBMasterErrorCBReceiveData:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:380    .text.vMBMasterErrorCBReceiveData:00000000 vMBMasterErrorCBReceiveData
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:411    .text.vMBMasterErrorCBExecuteFunction:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:416    .text.vMBMasterErrorCBExecuteFunction:00000000 vMBMasterErrorCBExecuteFunction
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:447    .text.vMBMasterCBRequestSuccess:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:452    .text.vMBMasterCBRequestSuccess:00000000 vMBMasterCBRequestSuccess
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:473    .text.eMBMasterWaitRequestFinish:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cczmFldk.s:478    .text.eMBMasterWaitRequestFinish:00000000 eMBMasterWaitRequestFinish
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.98ffea2db242cfdb58f411f7407f2b59
                           .group:00000000 wm4.stm32f10x_conf.h.2.f1a8c33f0a763aeef696fee38b2b2dbc
                           .group:00000000 wm4.mbconfig.h.33.2e295d4ff98bc723e2405a40490b5ddb
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.183.aa62afef667fb61d15fa64c48beb2f14
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.assert.h.11.060c3dc511517628fd4f958fa9448dce
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.24.8137491c6995c2cb5d25f9bab92d7f64
                           .group:00000000 wm4.stm32f10x.h.51.b859cb68ed44ee02c916b41cb8c68f1c
                           .group:00000000 wm4.core_cm3.h.25.119fe996be41b62fbd915b59177e39d1
                           .group:00000000 wm4.stm32f10x.h.522.a925aafc848b1f088438cf0e9b167b78
                           .group:00000000 wm4.stm32f10x.h.8304.f7d8ad90959e99679b3257267c3aadfe
                           .group:00000000 wm4.stm32f10x_rcc.h.25.fe8897e7491f2eb0cff54551d08eb765
                           .group:00000000 wm4.portmacro.h.56.a47bdd86bc36d334ca6056492e2d709f
                           .group:00000000 wm4.port.h.38.a8cf679bb58c5ad1b387e726c220530e
                           .group:00000000 wm4.mbproto.h.32.da85c2bdd9bdb84e975a92c999a4b490
                           .group:00000000 wm4.mb_m.h.32.f0c90bdd8de56a09521e2eefafb4f11f

UNDEFINED SYMBOLS
vPortEnterCritical
vPortExitCritical
