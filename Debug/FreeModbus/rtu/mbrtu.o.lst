   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"mbrtu.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.bss.eSndState,"aw",%nobits
  21              	eSndState:
  22 0000 00       		.space	1
  23              		.section	.bss.eRcvState,"aw",%nobits
  26              	eRcvState:
  27 0000 00       		.space	1
  28              		.comm	ucRTUBuf,256,4
  29              		.section	.bss.pucSndBufferCur,"aw",%nobits
  30              		.align	2
  33              	pucSndBufferCur:
  34 0000 00000000 		.space	4
  35              		.section	.bss.usSndBufferCount,"aw",%nobits
  36              		.align	1
  39              	usSndBufferCount:
  40 0000 0000     		.space	2
  41              		.section	.bss.usRcvBufferPos,"aw",%nobits
  42              		.align	1
  45              	usRcvBufferPos:
  46 0000 0000     		.space	2
  47              		.section	.text.eMBRTUInit,"ax",%progbits
  48              		.align	2
  49              		.global	eMBRTUInit
  50              		.thumb
  51              		.thumb_func
  53              	eMBRTUInit:
  54              	.LFB29:
  55              		.file 1 "../FreeModbus/rtu/mbrtu.c"
   1:../FreeModbus/rtu/mbrtu.c **** /* 
   2:../FreeModbus/rtu/mbrtu.c ****  * FreeModbus Libary: A portable Modbus implementation for Modbus ASCII/RTU.
   3:../FreeModbus/rtu/mbrtu.c ****  * Copyright (c) 2006 Christian Walter <wolti@sil.at>
   4:../FreeModbus/rtu/mbrtu.c ****  * All rights reserved.
   5:../FreeModbus/rtu/mbrtu.c ****  *
   6:../FreeModbus/rtu/mbrtu.c ****  * Redistribution and use in source and binary forms, with or without
   7:../FreeModbus/rtu/mbrtu.c ****  * modification, are permitted provided that the following conditions
   8:../FreeModbus/rtu/mbrtu.c ****  * are met:
   9:../FreeModbus/rtu/mbrtu.c ****  * 1. Redistributions of source code must retain the above copyright
  10:../FreeModbus/rtu/mbrtu.c ****  *    notice, this list of conditions and the following disclaimer.
  11:../FreeModbus/rtu/mbrtu.c ****  * 2. Redistributions in binary form must reproduce the above copyright
  12:../FreeModbus/rtu/mbrtu.c ****  *    notice, this list of conditions and the following disclaimer in the
  13:../FreeModbus/rtu/mbrtu.c ****  *    documentation and/or other materials provided with the distribution.
  14:../FreeModbus/rtu/mbrtu.c ****  * 3. The name of the author may not be used to endorse or promote products
  15:../FreeModbus/rtu/mbrtu.c ****  *    derived from this software without specific prior written permission.
  16:../FreeModbus/rtu/mbrtu.c ****  *
  17:../FreeModbus/rtu/mbrtu.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  18:../FreeModbus/rtu/mbrtu.c ****  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  19:../FreeModbus/rtu/mbrtu.c ****  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  20:../FreeModbus/rtu/mbrtu.c ****  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
  21:../FreeModbus/rtu/mbrtu.c ****  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  22:../FreeModbus/rtu/mbrtu.c ****  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  23:../FreeModbus/rtu/mbrtu.c ****  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  24:../FreeModbus/rtu/mbrtu.c ****  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25:../FreeModbus/rtu/mbrtu.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26:../FreeModbus/rtu/mbrtu.c ****  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27:../FreeModbus/rtu/mbrtu.c ****  *
  28:../FreeModbus/rtu/mbrtu.c ****  * File: $Id: mbrtu.c,v 1.18 2007/09/12 10:15:56 wolti Exp $
  29:../FreeModbus/rtu/mbrtu.c ****  */
  30:../FreeModbus/rtu/mbrtu.c **** 
  31:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- System includes ----------------------------------*/
  32:../FreeModbus/rtu/mbrtu.c **** #include "stdlib.h"
  33:../FreeModbus/rtu/mbrtu.c **** #include "string.h"
  34:../FreeModbus/rtu/mbrtu.c **** 
  35:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- Platform includes --------------------------------*/
  36:../FreeModbus/rtu/mbrtu.c **** #include "port.h"
  37:../FreeModbus/rtu/mbrtu.c **** 
  38:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- Modbus includes ----------------------------------*/
  39:../FreeModbus/rtu/mbrtu.c **** #include "mb.h"
  40:../FreeModbus/rtu/mbrtu.c **** #include "mbrtu.h"
  41:../FreeModbus/rtu/mbrtu.c **** #include "mbframe.h"
  42:../FreeModbus/rtu/mbrtu.c **** 
  43:../FreeModbus/rtu/mbrtu.c **** #include "mbcrc.h"
  44:../FreeModbus/rtu/mbrtu.c **** #include "mbport.h"
  45:../FreeModbus/rtu/mbrtu.c **** 
  46:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- Defines ------------------------------------------*/
  47:../FreeModbus/rtu/mbrtu.c **** #define MB_SER_PDU_SIZE_MIN     4       /*!< Minimum size of a Modbus RTU frame. */
  48:../FreeModbus/rtu/mbrtu.c **** #define MB_SER_PDU_SIZE_MAX     256     /*!< Maximum size of a Modbus RTU frame. */
  49:../FreeModbus/rtu/mbrtu.c **** #define MB_SER_PDU_SIZE_CRC     2       /*!< Size of CRC field in PDU. */
  50:../FreeModbus/rtu/mbrtu.c **** #define MB_SER_PDU_ADDR_OFF     0       /*!< Offset of slave address in Ser-PDU. */
  51:../FreeModbus/rtu/mbrtu.c **** #define MB_SER_PDU_PDU_OFF      1       /*!< Offset of Modbus-PDU in Ser-PDU. */
  52:../FreeModbus/rtu/mbrtu.c **** 
  53:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- Type definitions ---------------------------------*/
  54:../FreeModbus/rtu/mbrtu.c **** typedef enum
  55:../FreeModbus/rtu/mbrtu.c **** {
  56:../FreeModbus/rtu/mbrtu.c ****     STATE_RX_INIT,              /*!< Receiver is in initial state. */
  57:../FreeModbus/rtu/mbrtu.c ****     STATE_RX_IDLE,              /*!< Receiver is in idle state. */
  58:../FreeModbus/rtu/mbrtu.c ****     STATE_RX_RCV,               /*!< Frame is beeing received. */
  59:../FreeModbus/rtu/mbrtu.c ****     STATE_RX_ERROR              /*!< If the frame is invalid. */
  60:../FreeModbus/rtu/mbrtu.c **** } eMBRcvState;
  61:../FreeModbus/rtu/mbrtu.c **** 
  62:../FreeModbus/rtu/mbrtu.c **** typedef enum
  63:../FreeModbus/rtu/mbrtu.c **** {
  64:../FreeModbus/rtu/mbrtu.c ****     STATE_TX_IDLE,              /*!< Transmitter is in idle state. */
  65:../FreeModbus/rtu/mbrtu.c ****     STATE_TX_XMIT               /*!< Transmitter is in transfer state. */
  66:../FreeModbus/rtu/mbrtu.c **** } eMBSndState;
  67:../FreeModbus/rtu/mbrtu.c **** 
  68:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- Static variables ---------------------------------*/
  69:../FreeModbus/rtu/mbrtu.c **** static volatile eMBSndState eSndState;
  70:../FreeModbus/rtu/mbrtu.c **** static volatile eMBRcvState eRcvState;
  71:../FreeModbus/rtu/mbrtu.c **** 
  72:../FreeModbus/rtu/mbrtu.c **** volatile UCHAR  ucRTUBuf[MB_SER_PDU_SIZE_MAX];
  73:../FreeModbus/rtu/mbrtu.c **** 
  74:../FreeModbus/rtu/mbrtu.c **** static volatile UCHAR *pucSndBufferCur;
  75:../FreeModbus/rtu/mbrtu.c **** static volatile USHORT usSndBufferCount;
  76:../FreeModbus/rtu/mbrtu.c **** 
  77:../FreeModbus/rtu/mbrtu.c **** static volatile USHORT usRcvBufferPos;
  78:../FreeModbus/rtu/mbrtu.c **** 
  79:../FreeModbus/rtu/mbrtu.c **** /* ----------------------- Start implementation -----------------------------*/
  80:../FreeModbus/rtu/mbrtu.c **** eMBErrorCode
  81:../FreeModbus/rtu/mbrtu.c **** eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
  82:../FreeModbus/rtu/mbrtu.c **** {
  56              		.loc 1 82 0
  57              		.cfi_startproc
  58              		@ args = 0, pretend = 0, frame = 16
  59              		@ frame_needed = 1, uses_anonymous_args = 0
  60 0000 80B5     		push	{r7, lr}
  61              		.cfi_def_cfa_offset 8
  62              		.cfi_offset 7, -8
  63              		.cfi_offset 14, -4
  64 0002 84B0     		sub	sp, sp, #16
  65              		.cfi_def_cfa_offset 24
  66 0004 00AF     		add	r7, sp, #0
  67              		.cfi_def_cfa_register 7
  68 0006 3A60     		str	r2, [r7]
  69 0008 0246     		mov	r2, r0
  70 000a FA71     		strb	r2, [r7, #7]
  71 000c 0A46     		mov	r2, r1
  72 000e BA71     		strb	r2, [r7, #6]
  73 0010 7B71     		strb	r3, [r7, #5]
  83:../FreeModbus/rtu/mbrtu.c ****     eMBErrorCode    eStatus = MB_ENOERR;
  74              		.loc 1 83 0
  75 0012 0023     		movs	r3, #0
  76 0014 FB73     		strb	r3, [r7, #15]
  84:../FreeModbus/rtu/mbrtu.c ****     ULONG           usTimerT35_50us;
  85:../FreeModbus/rtu/mbrtu.c **** 
  86:../FreeModbus/rtu/mbrtu.c ****     ( void )ucSlaveAddress;
  87:../FreeModbus/rtu/mbrtu.c ****     ENTER_CRITICAL_SECTION(  );
  77              		.loc 1 87 0
  78 0016 FFF7FEFF 		bl	vPortEnterCritical
  88:../FreeModbus/rtu/mbrtu.c **** 
  89:../FreeModbus/rtu/mbrtu.c ****     /* Modbus RTU uses 8 Databits. */
  90:../FreeModbus/rtu/mbrtu.c ****     if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
  79              		.loc 1 90 0
  80 001a BA79     		ldrb	r2, [r7, #6]	@ zero_extendqisi2
  81 001c 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
  82 001e 1046     		mov	r0, r2
  83 0020 3968     		ldr	r1, [r7]
  84 0022 0822     		movs	r2, #8
  85 0024 FFF7FEFF 		bl	xMBPortSerialInit
  86 0028 0346     		mov	r3, r0
  87 002a 012B     		cmp	r3, #1
  88 002c 02D0     		beq	.L2
  91:../FreeModbus/rtu/mbrtu.c ****     {
  92:../FreeModbus/rtu/mbrtu.c ****         eStatus = MB_EPORTERR;
  89              		.loc 1 92 0
  90 002e 0323     		movs	r3, #3
  91 0030 FB73     		strb	r3, [r7, #15]
  92 0032 19E0     		b	.L3
  93              	.L2:
  93:../FreeModbus/rtu/mbrtu.c ****     }
  94:../FreeModbus/rtu/mbrtu.c ****     else
  95:../FreeModbus/rtu/mbrtu.c ****     {
  96:../FreeModbus/rtu/mbrtu.c ****         /* If baudrate > 19200 then we should use the fixed timer values
  97:../FreeModbus/rtu/mbrtu.c ****          * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
  98:../FreeModbus/rtu/mbrtu.c ****          */
  99:../FreeModbus/rtu/mbrtu.c ****         if( ulBaudRate > 19200 )
  94              		.loc 1 99 0
  95 0034 3B68     		ldr	r3, [r7]
  96 0036 B3F5964F 		cmp	r3, #19200
  97 003a 02D9     		bls	.L4
 100:../FreeModbus/rtu/mbrtu.c ****         {
 101:../FreeModbus/rtu/mbrtu.c ****             usTimerT35_50us = 35;       /* 1800us. */
  98              		.loc 1 101 0
  99 003c 2323     		movs	r3, #35
 100 003e BB60     		str	r3, [r7, #8]
 101 0040 08E0     		b	.L5
 102              	.L4:
 102:../FreeModbus/rtu/mbrtu.c ****         }
 103:../FreeModbus/rtu/mbrtu.c ****         else
 104:../FreeModbus/rtu/mbrtu.c ****         {
 105:../FreeModbus/rtu/mbrtu.c ****             /* The timer reload value for a character is given by:
 106:../FreeModbus/rtu/mbrtu.c ****              *
 107:../FreeModbus/rtu/mbrtu.c ****              * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )
 108:../FreeModbus/rtu/mbrtu.c ****              *             = 11 * Ticks_per_1s / Baudrate
 109:../FreeModbus/rtu/mbrtu.c ****              *             = 220000 / Baudrate
 110:../FreeModbus/rtu/mbrtu.c ****              * The reload for t3.5 is 1.5 times this value and similary
 111:../FreeModbus/rtu/mbrtu.c ****              * for t3.5.
 112:../FreeModbus/rtu/mbrtu.c ****              */
 113:../FreeModbus/rtu/mbrtu.c ****             usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
 103              		.loc 1 113 0
 104 0042 3B68     		ldr	r3, [r7]
 105 0044 5A00     		lsls	r2, r3, #1
 106 0046 47F6A073 		movw	r3, #32672
 107 004a C0F21703 		movt	r3, 23
 108 004e B3FBF2F3 		udiv	r3, r3, r2
 109 0052 BB60     		str	r3, [r7, #8]
 110              	.L5:
 114:../FreeModbus/rtu/mbrtu.c ****         }
 115:../FreeModbus/rtu/mbrtu.c ****         if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
 111              		.loc 1 115 0
 112 0054 BB68     		ldr	r3, [r7, #8]
 113 0056 9BB2     		uxth	r3, r3
 114 0058 1846     		mov	r0, r3
 115 005a FFF7FEFF 		bl	xMBPortTimersInit
 116 005e 0346     		mov	r3, r0
 117 0060 012B     		cmp	r3, #1
 118 0062 01D0     		beq	.L3
 116:../FreeModbus/rtu/mbrtu.c ****         {
 117:../FreeModbus/rtu/mbrtu.c ****             eStatus = MB_EPORTERR;
 119              		.loc 1 117 0
 120 0064 0323     		movs	r3, #3
 121 0066 FB73     		strb	r3, [r7, #15]
 122              	.L3:
 118:../FreeModbus/rtu/mbrtu.c ****         }
 119:../FreeModbus/rtu/mbrtu.c ****     }
 120:../FreeModbus/rtu/mbrtu.c ****     EXIT_CRITICAL_SECTION(  );
 123              		.loc 1 120 0
 124 0068 FFF7FEFF 		bl	vPortExitCritical
 121:../FreeModbus/rtu/mbrtu.c **** 
 122:../FreeModbus/rtu/mbrtu.c ****     return eStatus;
 125              		.loc 1 122 0
 126 006c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 123:../FreeModbus/rtu/mbrtu.c **** }
 127              		.loc 1 123 0
 128 006e 1846     		mov	r0, r3
 129 0070 1037     		adds	r7, r7, #16
 130 0072 BD46     		mov	sp, r7
 131              		@ sp needed
 132 0074 80BD     		pop	{r7, pc}
 133              		.cfi_endproc
 134              	.LFE29:
 136 0076 00BF     		.section	.text.eMBRTUStart,"ax",%progbits
 137              		.align	2
 138              		.global	eMBRTUStart
 139              		.thumb
 140              		.thumb_func
 142              	eMBRTUStart:
 143              	.LFB30:
 124:../FreeModbus/rtu/mbrtu.c **** 
 125:../FreeModbus/rtu/mbrtu.c **** void
 126:../FreeModbus/rtu/mbrtu.c **** eMBRTUStart( void )
 127:../FreeModbus/rtu/mbrtu.c **** {
 144              		.loc 1 127 0
 145              		.cfi_startproc
 146              		@ args = 0, pretend = 0, frame = 0
 147              		@ frame_needed = 1, uses_anonymous_args = 0
 148 0000 80B5     		push	{r7, lr}
 149              		.cfi_def_cfa_offset 8
 150              		.cfi_offset 7, -8
 151              		.cfi_offset 14, -4
 152 0002 00AF     		add	r7, sp, #0
 153              		.cfi_def_cfa_register 7
 128:../FreeModbus/rtu/mbrtu.c ****     ENTER_CRITICAL_SECTION(  );
 154              		.loc 1 128 0
 155 0004 FFF7FEFF 		bl	vPortEnterCritical
 129:../FreeModbus/rtu/mbrtu.c ****     /* Initially the receiver is in the state STATE_RX_INIT. we start
 130:../FreeModbus/rtu/mbrtu.c ****      * the timer and if no character is received within t3.5 we change
 131:../FreeModbus/rtu/mbrtu.c ****      * to STATE_RX_IDLE. This makes sure that we delay startup of the
 132:../FreeModbus/rtu/mbrtu.c ****      * modbus protocol stack until the bus is free.
 133:../FreeModbus/rtu/mbrtu.c ****      */
 134:../FreeModbus/rtu/mbrtu.c ****     eRcvState = STATE_RX_INIT;
 156              		.loc 1 134 0
 157 0008 40F20003 		movw	r3, #:lower16:eRcvState
 158 000c C0F20003 		movt	r3, #:upper16:eRcvState
 159 0010 0022     		movs	r2, #0
 160 0012 1A70     		strb	r2, [r3]
 135:../FreeModbus/rtu/mbrtu.c ****     vMBPortSerialEnable( TRUE, FALSE );
 161              		.loc 1 135 0
 162 0014 0120     		movs	r0, #1
 163 0016 0021     		movs	r1, #0
 164 0018 FFF7FEFF 		bl	vMBPortSerialEnable
 136:../FreeModbus/rtu/mbrtu.c ****     vMBPortTimersEnable(  );
 165              		.loc 1 136 0
 166 001c FFF7FEFF 		bl	vMBPortTimersEnable
 137:../FreeModbus/rtu/mbrtu.c **** 
 138:../FreeModbus/rtu/mbrtu.c ****     EXIT_CRITICAL_SECTION(  );
 167              		.loc 1 138 0
 168 0020 FFF7FEFF 		bl	vPortExitCritical
 139:../FreeModbus/rtu/mbrtu.c **** }
 169              		.loc 1 139 0
 170 0024 80BD     		pop	{r7, pc}
 171              		.cfi_endproc
 172              	.LFE30:
 174 0026 00BF     		.section	.text.eMBRTUStop,"ax",%progbits
 175              		.align	2
 176              		.global	eMBRTUStop
 177              		.thumb
 178              		.thumb_func
 180              	eMBRTUStop:
 181              	.LFB31:
 140:../FreeModbus/rtu/mbrtu.c **** 
 141:../FreeModbus/rtu/mbrtu.c **** void
 142:../FreeModbus/rtu/mbrtu.c **** eMBRTUStop( void )
 143:../FreeModbus/rtu/mbrtu.c **** {
 182              		.loc 1 143 0
 183              		.cfi_startproc
 184              		@ args = 0, pretend = 0, frame = 0
 185              		@ frame_needed = 1, uses_anonymous_args = 0
 186 0000 80B5     		push	{r7, lr}
 187              		.cfi_def_cfa_offset 8
 188              		.cfi_offset 7, -8
 189              		.cfi_offset 14, -4
 190 0002 00AF     		add	r7, sp, #0
 191              		.cfi_def_cfa_register 7
 144:../FreeModbus/rtu/mbrtu.c ****     ENTER_CRITICAL_SECTION(  );
 192              		.loc 1 144 0
 193 0004 FFF7FEFF 		bl	vPortEnterCritical
 145:../FreeModbus/rtu/mbrtu.c ****     vMBPortSerialEnable( FALSE, FALSE );
 194              		.loc 1 145 0
 195 0008 0020     		movs	r0, #0
 196 000a 0021     		movs	r1, #0
 197 000c FFF7FEFF 		bl	vMBPortSerialEnable
 146:../FreeModbus/rtu/mbrtu.c ****     vMBPortTimersDisable(  );
 198              		.loc 1 146 0
 199 0010 FFF7FEFF 		bl	vMBPortTimersDisable
 147:../FreeModbus/rtu/mbrtu.c ****     EXIT_CRITICAL_SECTION(  );
 200              		.loc 1 147 0
 201 0014 FFF7FEFF 		bl	vPortExitCritical
 148:../FreeModbus/rtu/mbrtu.c **** }
 202              		.loc 1 148 0
 203 0018 80BD     		pop	{r7, pc}
 204              		.cfi_endproc
 205              	.LFE31:
 207 001a 00BF     		.section	.text.eMBRTUReceive,"ax",%progbits
 208              		.align	2
 209              		.global	eMBRTUReceive
 210              		.thumb
 211              		.thumb_func
 213              	eMBRTUReceive:
 214              	.LFB32:
 149:../FreeModbus/rtu/mbrtu.c **** 
 150:../FreeModbus/rtu/mbrtu.c **** eMBErrorCode
 151:../FreeModbus/rtu/mbrtu.c **** eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
 152:../FreeModbus/rtu/mbrtu.c **** {
 215              		.loc 1 152 0
 216              		.cfi_startproc
 217              		@ args = 0, pretend = 0, frame = 24
 218              		@ frame_needed = 1, uses_anonymous_args = 0
 219 0000 80B5     		push	{r7, lr}
 220              		.cfi_def_cfa_offset 8
 221              		.cfi_offset 7, -8
 222              		.cfi_offset 14, -4
 223 0002 86B0     		sub	sp, sp, #24
 224              		.cfi_def_cfa_offset 32
 225 0004 00AF     		add	r7, sp, #0
 226              		.cfi_def_cfa_register 7
 227 0006 F860     		str	r0, [r7, #12]
 228 0008 B960     		str	r1, [r7, #8]
 229 000a 7A60     		str	r2, [r7, #4]
 153:../FreeModbus/rtu/mbrtu.c ****     eMBErrorCode    eStatus = MB_ENOERR;
 230              		.loc 1 153 0
 231 000c 0023     		movs	r3, #0
 232 000e FB75     		strb	r3, [r7, #23]
 154:../FreeModbus/rtu/mbrtu.c **** 
 155:../FreeModbus/rtu/mbrtu.c ****     ENTER_CRITICAL_SECTION(  );
 233              		.loc 1 155 0
 234 0010 FFF7FEFF 		bl	vPortEnterCritical
 156:../FreeModbus/rtu/mbrtu.c ****     assert_param( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );
 157:../FreeModbus/rtu/mbrtu.c **** 
 158:../FreeModbus/rtu/mbrtu.c ****     /* Length and CRC check */
 159:../FreeModbus/rtu/mbrtu.c ****     if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
 235              		.loc 1 159 0
 236 0014 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 237 0018 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 238 001c 1B88     		ldrh	r3, [r3]	@ movhi
 239 001e 9BB2     		uxth	r3, r3
 240 0020 032B     		cmp	r3, #3
 241 0022 25D9     		bls	.L10
 160:../FreeModbus/rtu/mbrtu.c ****         && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
 242              		.loc 1 160 0
 243 0024 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 244 0028 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 245 002c 1B88     		ldrh	r3, [r3]	@ movhi
 246 002e 9BB2     		uxth	r3, r3
 247 0030 40F20000 		movw	r0, #:lower16:ucRTUBuf
 248 0034 C0F20000 		movt	r0, #:upper16:ucRTUBuf
 249 0038 1946     		mov	r1, r3
 250 003a FFF7FEFF 		bl	usMBCRC16
 251 003e 0346     		mov	r3, r0
 252 0040 002B     		cmp	r3, #0
 253 0042 15D1     		bne	.L10
 161:../FreeModbus/rtu/mbrtu.c ****     {
 162:../FreeModbus/rtu/mbrtu.c ****         /* Save the address field. All frames are passed to the upper layed
 163:../FreeModbus/rtu/mbrtu.c ****          * and the decision if a frame is used is done there.
 164:../FreeModbus/rtu/mbrtu.c ****          */
 165:../FreeModbus/rtu/mbrtu.c ****         *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
 254              		.loc 1 165 0
 255 0044 40F20003 		movw	r3, #:lower16:ucRTUBuf
 256 0048 C0F20003 		movt	r3, #:upper16:ucRTUBuf
 257 004c 1B78     		ldrb	r3, [r3]
 258 004e DAB2     		uxtb	r2, r3
 259 0050 FB68     		ldr	r3, [r7, #12]
 260 0052 1A70     		strb	r2, [r3]
 166:../FreeModbus/rtu/mbrtu.c **** 
 167:../FreeModbus/rtu/mbrtu.c ****         /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
 168:../FreeModbus/rtu/mbrtu.c ****          * size of address field and CRC checksum.
 169:../FreeModbus/rtu/mbrtu.c ****          */
 170:../FreeModbus/rtu/mbrtu.c ****         *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
 261              		.loc 1 170 0
 262 0054 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 263 0058 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 264 005c 1B88     		ldrh	r3, [r3]	@ movhi
 265 005e 9BB2     		uxth	r3, r3
 266 0060 033B     		subs	r3, r3, #3
 267 0062 9AB2     		uxth	r2, r3
 268 0064 7B68     		ldr	r3, [r7, #4]
 269 0066 1A80     		strh	r2, [r3]	@ movhi
 171:../FreeModbus/rtu/mbrtu.c **** 
 172:../FreeModbus/rtu/mbrtu.c ****         /* Return the start of the Modbus PDU to the caller. */
 173:../FreeModbus/rtu/mbrtu.c ****         *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
 270              		.loc 1 173 0
 271 0068 BB68     		ldr	r3, [r7, #8]
 272 006a 064A     		ldr	r2, .L13
 273 006c 1A60     		str	r2, [r3]
 274 006e 01E0     		b	.L11
 275              	.L10:
 174:../FreeModbus/rtu/mbrtu.c ****     }
 175:../FreeModbus/rtu/mbrtu.c ****     else
 176:../FreeModbus/rtu/mbrtu.c ****     {
 177:../FreeModbus/rtu/mbrtu.c ****         eStatus = MB_EIO;
 276              		.loc 1 177 0
 277 0070 0523     		movs	r3, #5
 278 0072 FB75     		strb	r3, [r7, #23]
 279              	.L11:
 178:../FreeModbus/rtu/mbrtu.c ****     }
 179:../FreeModbus/rtu/mbrtu.c **** 
 180:../FreeModbus/rtu/mbrtu.c ****     EXIT_CRITICAL_SECTION(  );
 280              		.loc 1 180 0
 281 0074 FFF7FEFF 		bl	vPortExitCritical
 181:../FreeModbus/rtu/mbrtu.c ****     return eStatus;
 282              		.loc 1 181 0
 283 0078 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 182:../FreeModbus/rtu/mbrtu.c **** }
 284              		.loc 1 182 0
 285 007a 1846     		mov	r0, r3
 286 007c 1837     		adds	r7, r7, #24
 287 007e BD46     		mov	sp, r7
 288              		@ sp needed
 289 0080 80BD     		pop	{r7, pc}
 290              	.L14:
 291 0082 00BF     		.align	2
 292              	.L13:
 293 0084 01000000 		.word	ucRTUBuf+1
 294              		.cfi_endproc
 295              	.LFE32:
 297              		.section	.text.eMBRTUSend,"ax",%progbits
 298              		.align	2
 299              		.global	eMBRTUSend
 300              		.thumb
 301              		.thumb_func
 303              	eMBRTUSend:
 304              	.LFB33:
 183:../FreeModbus/rtu/mbrtu.c **** 
 184:../FreeModbus/rtu/mbrtu.c **** eMBErrorCode
 185:../FreeModbus/rtu/mbrtu.c **** eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
 186:../FreeModbus/rtu/mbrtu.c **** {
 305              		.loc 1 186 0
 306              		.cfi_startproc
 307              		@ args = 0, pretend = 0, frame = 16
 308              		@ frame_needed = 1, uses_anonymous_args = 0
 309 0000 80B5     		push	{r7, lr}
 310              		.cfi_def_cfa_offset 8
 311              		.cfi_offset 7, -8
 312              		.cfi_offset 14, -4
 313 0002 84B0     		sub	sp, sp, #16
 314              		.cfi_def_cfa_offset 24
 315 0004 00AF     		add	r7, sp, #0
 316              		.cfi_def_cfa_register 7
 317 0006 3960     		str	r1, [r7]
 318 0008 1346     		mov	r3, r2
 319 000a 0246     		mov	r2, r0
 320 000c FA71     		strb	r2, [r7, #7]
 321 000e BB80     		strh	r3, [r7, #4]	@ movhi
 187:../FreeModbus/rtu/mbrtu.c ****     eMBErrorCode    eStatus = MB_ENOERR;
 322              		.loc 1 187 0
 323 0010 0023     		movs	r3, #0
 324 0012 FB73     		strb	r3, [r7, #15]
 188:../FreeModbus/rtu/mbrtu.c ****     USHORT          usCRC16;
 189:../FreeModbus/rtu/mbrtu.c **** 
 190:../FreeModbus/rtu/mbrtu.c ****     ENTER_CRITICAL_SECTION(  );
 325              		.loc 1 190 0
 326 0014 FFF7FEFF 		bl	vPortEnterCritical
 191:../FreeModbus/rtu/mbrtu.c **** 
 192:../FreeModbus/rtu/mbrtu.c ****     /* Check if the receiver is still in idle state. If not we where to
 193:../FreeModbus/rtu/mbrtu.c ****      * slow with processing the received frame and the master sent another
 194:../FreeModbus/rtu/mbrtu.c ****      * frame on the network. We have to abort sending the frame.
 195:../FreeModbus/rtu/mbrtu.c ****      */
 196:../FreeModbus/rtu/mbrtu.c ****     if( eRcvState == STATE_RX_IDLE )
 327              		.loc 1 196 0
 328 0018 40F20003 		movw	r3, #:lower16:eRcvState
 329 001c C0F20003 		movt	r3, #:upper16:eRcvState
 330 0020 1B78     		ldrb	r3, [r3]
 331 0022 DBB2     		uxtb	r3, r3
 332 0024 012B     		cmp	r3, #1
 333 0026 69D1     		bne	.L16
 197:../FreeModbus/rtu/mbrtu.c ****     {
 198:../FreeModbus/rtu/mbrtu.c ****         /* First byte before the Modbus-PDU is the slave address. */
 199:../FreeModbus/rtu/mbrtu.c ****         pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
 334              		.loc 1 199 0
 335 0028 3B68     		ldr	r3, [r7]
 336 002a 5A1E     		subs	r2, r3, #1
 337 002c 40F20003 		movw	r3, #:lower16:pucSndBufferCur
 338 0030 C0F20003 		movt	r3, #:upper16:pucSndBufferCur
 339 0034 1A60     		str	r2, [r3]
 200:../FreeModbus/rtu/mbrtu.c ****         usSndBufferCount = 1;
 340              		.loc 1 200 0
 341 0036 40F20003 		movw	r3, #:lower16:usSndBufferCount
 342 003a C0F20003 		movt	r3, #:upper16:usSndBufferCount
 343 003e 0122     		movs	r2, #1
 344 0040 1A80     		strh	r2, [r3]	@ movhi
 201:../FreeModbus/rtu/mbrtu.c **** 
 202:../FreeModbus/rtu/mbrtu.c ****         /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
 203:../FreeModbus/rtu/mbrtu.c ****         pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
 345              		.loc 1 203 0
 346 0042 40F20003 		movw	r3, #:lower16:pucSndBufferCur
 347 0046 C0F20003 		movt	r3, #:upper16:pucSndBufferCur
 348 004a 1B68     		ldr	r3, [r3]
 349 004c FA79     		ldrb	r2, [r7, #7]
 350 004e 1A70     		strb	r2, [r3]
 204:../FreeModbus/rtu/mbrtu.c ****         usSndBufferCount += usLength;
 351              		.loc 1 204 0
 352 0050 40F20003 		movw	r3, #:lower16:usSndBufferCount
 353 0054 C0F20003 		movt	r3, #:upper16:usSndBufferCount
 354 0058 1B88     		ldrh	r3, [r3]	@ movhi
 355 005a 9AB2     		uxth	r2, r3
 356 005c BB88     		ldrh	r3, [r7, #4]	@ movhi
 357 005e 1344     		add	r3, r3, r2
 358 0060 9AB2     		uxth	r2, r3
 359 0062 40F20003 		movw	r3, #:lower16:usSndBufferCount
 360 0066 C0F20003 		movt	r3, #:upper16:usSndBufferCount
 361 006a 1A80     		strh	r2, [r3]	@ movhi
 205:../FreeModbus/rtu/mbrtu.c **** 
 206:../FreeModbus/rtu/mbrtu.c ****         /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
 207:../FreeModbus/rtu/mbrtu.c ****         usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
 362              		.loc 1 207 0
 363 006c 40F20003 		movw	r3, #:lower16:pucSndBufferCur
 364 0070 C0F20003 		movt	r3, #:upper16:pucSndBufferCur
 365 0074 1A68     		ldr	r2, [r3]
 366 0076 40F20003 		movw	r3, #:lower16:usSndBufferCount
 367 007a C0F20003 		movt	r3, #:upper16:usSndBufferCount
 368 007e 1B88     		ldrh	r3, [r3]	@ movhi
 369 0080 9BB2     		uxth	r3, r3
 370 0082 1046     		mov	r0, r2
 371 0084 1946     		mov	r1, r3
 372 0086 FFF7FEFF 		bl	usMBCRC16
 373 008a 0346     		mov	r3, r0
 374 008c BB81     		strh	r3, [r7, #12]	@ movhi
 208:../FreeModbus/rtu/mbrtu.c ****         ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
 375              		.loc 1 208 0
 376 008e 40F20003 		movw	r3, #:lower16:usSndBufferCount
 377 0092 C0F20003 		movt	r3, #:upper16:usSndBufferCount
 378 0096 1B88     		ldrh	r3, [r3]	@ movhi
 379 0098 9BB2     		uxth	r3, r3
 380 009a 1A46     		mov	r2, r3
 381 009c 531C     		adds	r3, r2, #1
 382 009e 99B2     		uxth	r1, r3
 383 00a0 40F20003 		movw	r3, #:lower16:usSndBufferCount
 384 00a4 C0F20003 		movt	r3, #:upper16:usSndBufferCount
 385 00a8 1980     		strh	r1, [r3]	@ movhi
 386 00aa BB89     		ldrh	r3, [r7, #12]	@ movhi
 387 00ac D9B2     		uxtb	r1, r3
 388 00ae 40F20003 		movw	r3, #:lower16:ucRTUBuf
 389 00b2 C0F20003 		movt	r3, #:upper16:ucRTUBuf
 390 00b6 9954     		strb	r1, [r3, r2]
 209:../FreeModbus/rtu/mbrtu.c ****         ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
 391              		.loc 1 209 0
 392 00b8 40F20003 		movw	r3, #:lower16:usSndBufferCount
 393 00bc C0F20003 		movt	r3, #:upper16:usSndBufferCount
 394 00c0 1B88     		ldrh	r3, [r3]	@ movhi
 395 00c2 9BB2     		uxth	r3, r3
 396 00c4 1A46     		mov	r2, r3
 397 00c6 531C     		adds	r3, r2, #1
 398 00c8 99B2     		uxth	r1, r3
 399 00ca 40F20003 		movw	r3, #:lower16:usSndBufferCount
 400 00ce C0F20003 		movt	r3, #:upper16:usSndBufferCount
 401 00d2 1980     		strh	r1, [r3]	@ movhi
 402 00d4 BB89     		ldrh	r3, [r7, #12]
 403 00d6 1B0A     		lsrs	r3, r3, #8
 404 00d8 9BB2     		uxth	r3, r3
 405 00da D9B2     		uxtb	r1, r3
 406 00dc 40F20003 		movw	r3, #:lower16:ucRTUBuf
 407 00e0 C0F20003 		movt	r3, #:upper16:ucRTUBuf
 408 00e4 9954     		strb	r1, [r3, r2]
 210:../FreeModbus/rtu/mbrtu.c **** 
 211:../FreeModbus/rtu/mbrtu.c ****         /* Activate the transmitter. */
 212:../FreeModbus/rtu/mbrtu.c ****         eSndState = STATE_TX_XMIT;
 409              		.loc 1 212 0
 410 00e6 40F20003 		movw	r3, #:lower16:eSndState
 411 00ea C0F20003 		movt	r3, #:upper16:eSndState
 412 00ee 0122     		movs	r2, #1
 413 00f0 1A70     		strb	r2, [r3]
 213:../FreeModbus/rtu/mbrtu.c ****         vMBPortSerialEnable( FALSE, TRUE );
 414              		.loc 1 213 0
 415 00f2 0020     		movs	r0, #0
 416 00f4 0121     		movs	r1, #1
 417 00f6 FFF7FEFF 		bl	vMBPortSerialEnable
 418 00fa 01E0     		b	.L17
 419              	.L16:
 214:../FreeModbus/rtu/mbrtu.c ****     }
 215:../FreeModbus/rtu/mbrtu.c ****     else
 216:../FreeModbus/rtu/mbrtu.c ****     {
 217:../FreeModbus/rtu/mbrtu.c ****         eStatus = MB_EIO;
 420              		.loc 1 217 0
 421 00fc 0523     		movs	r3, #5
 422 00fe FB73     		strb	r3, [r7, #15]
 423              	.L17:
 218:../FreeModbus/rtu/mbrtu.c ****     }
 219:../FreeModbus/rtu/mbrtu.c ****     EXIT_CRITICAL_SECTION(  );
 424              		.loc 1 219 0
 425 0100 FFF7FEFF 		bl	vPortExitCritical
 220:../FreeModbus/rtu/mbrtu.c ****     return eStatus;
 426              		.loc 1 220 0
 427 0104 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 221:../FreeModbus/rtu/mbrtu.c **** }
 428              		.loc 1 221 0
 429 0106 1846     		mov	r0, r3
 430 0108 1037     		adds	r7, r7, #16
 431 010a BD46     		mov	sp, r7
 432              		@ sp needed
 433 010c 80BD     		pop	{r7, pc}
 434              		.cfi_endproc
 435              	.LFE33:
 437 010e 00BF     		.section	.text.xMBRTUReceiveFSM,"ax",%progbits
 438              		.align	2
 439              		.global	xMBRTUReceiveFSM
 440              		.thumb
 441              		.thumb_func
 443              	xMBRTUReceiveFSM:
 444              	.LFB34:
 222:../FreeModbus/rtu/mbrtu.c **** 
 223:../FreeModbus/rtu/mbrtu.c **** BOOL
 224:../FreeModbus/rtu/mbrtu.c **** xMBRTUReceiveFSM( void )
 225:../FreeModbus/rtu/mbrtu.c **** {
 445              		.loc 1 225 0
 446              		.cfi_startproc
 447              		@ args = 0, pretend = 0, frame = 8
 448              		@ frame_needed = 1, uses_anonymous_args = 0
 449 0000 80B5     		push	{r7, lr}
 450              		.cfi_def_cfa_offset 8
 451              		.cfi_offset 7, -8
 452              		.cfi_offset 14, -4
 453 0002 82B0     		sub	sp, sp, #8
 454              		.cfi_def_cfa_offset 16
 455 0004 00AF     		add	r7, sp, #0
 456              		.cfi_def_cfa_register 7
 226:../FreeModbus/rtu/mbrtu.c ****     BOOL            xTaskNeedSwitch = FALSE;
 457              		.loc 1 226 0
 458 0006 0023     		movs	r3, #0
 459 0008 FB71     		strb	r3, [r7, #7]
 227:../FreeModbus/rtu/mbrtu.c ****     UCHAR           ucByte;
 228:../FreeModbus/rtu/mbrtu.c **** 
 229:../FreeModbus/rtu/mbrtu.c ****     assert_param( eSndState == STATE_TX_IDLE );
 230:../FreeModbus/rtu/mbrtu.c **** 
 231:../FreeModbus/rtu/mbrtu.c ****     /* Always read the character. */
 232:../FreeModbus/rtu/mbrtu.c ****     ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
 460              		.loc 1 232 0
 461 000a BB1D     		adds	r3, r7, #6
 462 000c 1846     		mov	r0, r3
 463 000e FFF7FEFF 		bl	xMBPortSerialGetByte
 233:../FreeModbus/rtu/mbrtu.c **** 
 234:../FreeModbus/rtu/mbrtu.c ****     switch ( eRcvState )
 464              		.loc 1 234 0
 465 0012 40F20003 		movw	r3, #:lower16:eRcvState
 466 0016 C0F20003 		movt	r3, #:upper16:eRcvState
 467 001a 1B78     		ldrb	r3, [r3]
 468 001c DBB2     		uxtb	r3, r3
 469 001e 032B     		cmp	r3, #3
 470 0020 59D8     		bhi	.L20
 471 0022 01A2     		adr	r2, .L22
 472 0024 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 473              		.p2align 2
 474              	.L22:
 475 0028 39000000 		.word	.L21+1
 476 002c 45000000 		.word	.L23+1
 477 0030 8B000000 		.word	.L24+1
 478 0034 3F000000 		.word	.L25+1
 479              	.L21:
 235:../FreeModbus/rtu/mbrtu.c ****     {
 236:../FreeModbus/rtu/mbrtu.c ****         /* If we have received a character in the init state we have to
 237:../FreeModbus/rtu/mbrtu.c ****          * wait until the frame is finished.
 238:../FreeModbus/rtu/mbrtu.c ****          */
 239:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_INIT:
 240:../FreeModbus/rtu/mbrtu.c ****         vMBPortTimersEnable( );
 480              		.loc 1 240 0
 481 0038 FFF7FEFF 		bl	vMBPortTimersEnable
 241:../FreeModbus/rtu/mbrtu.c ****         break;
 482              		.loc 1 241 0
 483 003c 4BE0     		b	.L20
 484              	.L25:
 242:../FreeModbus/rtu/mbrtu.c **** 
 243:../FreeModbus/rtu/mbrtu.c ****         /* In the error state we wait until all characters in the
 244:../FreeModbus/rtu/mbrtu.c ****          * damaged frame are transmitted.
 245:../FreeModbus/rtu/mbrtu.c ****          */
 246:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_ERROR:
 247:../FreeModbus/rtu/mbrtu.c ****         vMBPortTimersEnable( );
 485              		.loc 1 247 0
 486 003e FFF7FEFF 		bl	vMBPortTimersEnable
 248:../FreeModbus/rtu/mbrtu.c ****         break;
 487              		.loc 1 248 0
 488 0042 48E0     		b	.L20
 489              	.L23:
 249:../FreeModbus/rtu/mbrtu.c **** 
 250:../FreeModbus/rtu/mbrtu.c ****         /* In the idle state we wait for a new character. If a character
 251:../FreeModbus/rtu/mbrtu.c ****          * is received the t1.5 and t3.5 timers are started and the
 252:../FreeModbus/rtu/mbrtu.c ****          * receiver is in the state STATE_RX_RECEIVCE.
 253:../FreeModbus/rtu/mbrtu.c ****          */
 254:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_IDLE:
 255:../FreeModbus/rtu/mbrtu.c ****         usRcvBufferPos = 0;
 490              		.loc 1 255 0
 491 0044 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 492 0048 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 493 004c 0022     		movs	r2, #0
 494 004e 1A80     		strh	r2, [r3]	@ movhi
 256:../FreeModbus/rtu/mbrtu.c ****         ucRTUBuf[usRcvBufferPos++] = ucByte;
 495              		.loc 1 256 0
 496 0050 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 497 0054 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 498 0058 1B88     		ldrh	r3, [r3]	@ movhi
 499 005a 9BB2     		uxth	r3, r3
 500 005c 1A46     		mov	r2, r3
 501 005e 531C     		adds	r3, r2, #1
 502 0060 99B2     		uxth	r1, r3
 503 0062 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 504 0066 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 505 006a 1980     		strh	r1, [r3]	@ movhi
 506 006c B979     		ldrb	r1, [r7, #6]	@ zero_extendqisi2
 507 006e 40F20003 		movw	r3, #:lower16:ucRTUBuf
 508 0072 C0F20003 		movt	r3, #:upper16:ucRTUBuf
 509 0076 9954     		strb	r1, [r3, r2]
 257:../FreeModbus/rtu/mbrtu.c ****         eRcvState = STATE_RX_RCV;
 510              		.loc 1 257 0
 511 0078 40F20003 		movw	r3, #:lower16:eRcvState
 512 007c C0F20003 		movt	r3, #:upper16:eRcvState
 513 0080 0222     		movs	r2, #2
 514 0082 1A70     		strb	r2, [r3]
 258:../FreeModbus/rtu/mbrtu.c **** 
 259:../FreeModbus/rtu/mbrtu.c ****         /* Enable t3.5 timers. */
 260:../FreeModbus/rtu/mbrtu.c ****         vMBPortTimersEnable( );
 515              		.loc 1 260 0
 516 0084 FFF7FEFF 		bl	vMBPortTimersEnable
 261:../FreeModbus/rtu/mbrtu.c ****         break;
 517              		.loc 1 261 0
 518 0088 25E0     		b	.L20
 519              	.L24:
 262:../FreeModbus/rtu/mbrtu.c **** 
 263:../FreeModbus/rtu/mbrtu.c ****         /* We are currently receiving a frame. Reset the timer after
 264:../FreeModbus/rtu/mbrtu.c ****          * every character received. If more than the maximum possible
 265:../FreeModbus/rtu/mbrtu.c ****          * number of bytes in a modbus frame is received the frame is
 266:../FreeModbus/rtu/mbrtu.c ****          * ignored.
 267:../FreeModbus/rtu/mbrtu.c ****          */
 268:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_RCV:
 269:../FreeModbus/rtu/mbrtu.c ****         if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
 520              		.loc 1 269 0
 521 008a 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 522 008e C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 523 0092 1B88     		ldrh	r3, [r3]	@ movhi
 524 0094 9BB2     		uxth	r3, r3
 525 0096 FF2B     		cmp	r3, #255
 526 0098 14D8     		bhi	.L26
 270:../FreeModbus/rtu/mbrtu.c ****         {
 271:../FreeModbus/rtu/mbrtu.c ****             ucRTUBuf[usRcvBufferPos++] = ucByte;
 527              		.loc 1 271 0
 528 009a 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 529 009e C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 530 00a2 1B88     		ldrh	r3, [r3]	@ movhi
 531 00a4 9BB2     		uxth	r3, r3
 532 00a6 1A46     		mov	r2, r3
 533 00a8 531C     		adds	r3, r2, #1
 534 00aa 99B2     		uxth	r1, r3
 535 00ac 40F20003 		movw	r3, #:lower16:usRcvBufferPos
 536 00b0 C0F20003 		movt	r3, #:upper16:usRcvBufferPos
 537 00b4 1980     		strh	r1, [r3]	@ movhi
 538 00b6 B979     		ldrb	r1, [r7, #6]	@ zero_extendqisi2
 539 00b8 40F20003 		movw	r3, #:lower16:ucRTUBuf
 540 00bc C0F20003 		movt	r3, #:upper16:ucRTUBuf
 541 00c0 9954     		strb	r1, [r3, r2]
 542 00c2 05E0     		b	.L27
 543              	.L26:
 272:../FreeModbus/rtu/mbrtu.c ****         }
 273:../FreeModbus/rtu/mbrtu.c ****         else
 274:../FreeModbus/rtu/mbrtu.c ****         {
 275:../FreeModbus/rtu/mbrtu.c ****             eRcvState = STATE_RX_ERROR;
 544              		.loc 1 275 0
 545 00c4 40F20003 		movw	r3, #:lower16:eRcvState
 546 00c8 C0F20003 		movt	r3, #:upper16:eRcvState
 547 00cc 0322     		movs	r2, #3
 548 00ce 1A70     		strb	r2, [r3]
 549              	.L27:
 276:../FreeModbus/rtu/mbrtu.c ****         }
 277:../FreeModbus/rtu/mbrtu.c ****         vMBPortTimersEnable();
 550              		.loc 1 277 0
 551 00d0 FFF7FEFF 		bl	vMBPortTimersEnable
 278:../FreeModbus/rtu/mbrtu.c ****         break;
 552              		.loc 1 278 0
 553 00d4 00BF     		nop
 554              	.L20:
 279:../FreeModbus/rtu/mbrtu.c ****     }
 280:../FreeModbus/rtu/mbrtu.c ****     return xTaskNeedSwitch;
 555              		.loc 1 280 0
 556 00d6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 281:../FreeModbus/rtu/mbrtu.c **** }
 557              		.loc 1 281 0
 558 00d8 1846     		mov	r0, r3
 559 00da 0837     		adds	r7, r7, #8
 560 00dc BD46     		mov	sp, r7
 561              		@ sp needed
 562 00de 80BD     		pop	{r7, pc}
 563              		.cfi_endproc
 564              	.LFE34:
 566              		.section	.text.xMBRTUTransmitFSM,"ax",%progbits
 567              		.align	2
 568              		.global	xMBRTUTransmitFSM
 569              		.thumb
 570              		.thumb_func
 572              	xMBRTUTransmitFSM:
 573              	.LFB35:
 282:../FreeModbus/rtu/mbrtu.c **** 
 283:../FreeModbus/rtu/mbrtu.c **** BOOL
 284:../FreeModbus/rtu/mbrtu.c **** xMBRTUTransmitFSM( void )
 285:../FreeModbus/rtu/mbrtu.c **** {
 574              		.loc 1 285 0
 575              		.cfi_startproc
 576              		@ args = 0, pretend = 0, frame = 8
 577              		@ frame_needed = 1, uses_anonymous_args = 0
 578 0000 80B5     		push	{r7, lr}
 579              		.cfi_def_cfa_offset 8
 580              		.cfi_offset 7, -8
 581              		.cfi_offset 14, -4
 582 0002 82B0     		sub	sp, sp, #8
 583              		.cfi_def_cfa_offset 16
 584 0004 00AF     		add	r7, sp, #0
 585              		.cfi_def_cfa_register 7
 286:../FreeModbus/rtu/mbrtu.c ****     BOOL            xNeedPoll = FALSE;
 586              		.loc 1 286 0
 587 0006 0023     		movs	r3, #0
 588 0008 FB71     		strb	r3, [r7, #7]
 287:../FreeModbus/rtu/mbrtu.c **** 
 288:../FreeModbus/rtu/mbrtu.c ****     assert_param( eRcvState == STATE_RX_IDLE );
 289:../FreeModbus/rtu/mbrtu.c **** 
 290:../FreeModbus/rtu/mbrtu.c ****     switch ( eSndState )
 589              		.loc 1 290 0
 590 000a 40F20003 		movw	r3, #:lower16:eSndState
 591 000e C0F20003 		movt	r3, #:upper16:eSndState
 592 0012 1B78     		ldrb	r3, [r3]
 593 0014 DBB2     		uxtb	r3, r3
 594 0016 002B     		cmp	r3, #0
 595 0018 02D0     		beq	.L31
 596 001a 012B     		cmp	r3, #1
 597 001c 05D0     		beq	.L32
 598 001e 3FE0     		b	.L30
 599              	.L31:
 291:../FreeModbus/rtu/mbrtu.c ****     {
 292:../FreeModbus/rtu/mbrtu.c ****         /* We should not get a transmitter event if the transmitter is in
 293:../FreeModbus/rtu/mbrtu.c ****          * idle state.  */
 294:../FreeModbus/rtu/mbrtu.c ****     case STATE_TX_IDLE:
 295:../FreeModbus/rtu/mbrtu.c ****         /* enable receiver/disable transmitter. */
 296:../FreeModbus/rtu/mbrtu.c ****         vMBPortSerialEnable( TRUE, FALSE );
 600              		.loc 1 296 0
 601 0020 0120     		movs	r0, #1
 602 0022 0021     		movs	r1, #0
 603 0024 FFF7FEFF 		bl	vMBPortSerialEnable
 297:../FreeModbus/rtu/mbrtu.c ****         break;
 604              		.loc 1 297 0
 605 0028 3AE0     		b	.L30
 606              	.L32:
 298:../FreeModbus/rtu/mbrtu.c **** 
 299:../FreeModbus/rtu/mbrtu.c ****     case STATE_TX_XMIT:
 300:../FreeModbus/rtu/mbrtu.c ****         /* check if we are finished. */
 301:../FreeModbus/rtu/mbrtu.c ****         if( usSndBufferCount != 0 )
 607              		.loc 1 301 0
 608 002a 40F20003 		movw	r3, #:lower16:usSndBufferCount
 609 002e C0F20003 		movt	r3, #:upper16:usSndBufferCount
 610 0032 1B88     		ldrh	r3, [r3]	@ movhi
 611 0034 9BB2     		uxth	r3, r3
 612 0036 002B     		cmp	r3, #0
 613 0038 22D0     		beq	.L33
 302:../FreeModbus/rtu/mbrtu.c ****         {
 303:../FreeModbus/rtu/mbrtu.c ****             xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
 614              		.loc 1 303 0
 615 003a 40F20003 		movw	r3, #:lower16:pucSndBufferCur
 616 003e C0F20003 		movt	r3, #:upper16:pucSndBufferCur
 617 0042 1B68     		ldr	r3, [r3]
 618 0044 1B78     		ldrb	r3, [r3]
 619 0046 DBB2     		uxtb	r3, r3
 620 0048 1846     		mov	r0, r3
 621 004a FFF7FEFF 		bl	xMBPortSerialPutByte
 304:../FreeModbus/rtu/mbrtu.c ****             pucSndBufferCur++;  /* next byte in sendbuffer. */
 622              		.loc 1 304 0
 623 004e 40F20003 		movw	r3, #:lower16:pucSndBufferCur
 624 0052 C0F20003 		movt	r3, #:upper16:pucSndBufferCur
 625 0056 1B68     		ldr	r3, [r3]
 626 0058 5A1C     		adds	r2, r3, #1
 627 005a 40F20003 		movw	r3, #:lower16:pucSndBufferCur
 628 005e C0F20003 		movt	r3, #:upper16:pucSndBufferCur
 629 0062 1A60     		str	r2, [r3]
 305:../FreeModbus/rtu/mbrtu.c ****             usSndBufferCount--;
 630              		.loc 1 305 0
 631 0064 40F20003 		movw	r3, #:lower16:usSndBufferCount
 632 0068 C0F20003 		movt	r3, #:upper16:usSndBufferCount
 633 006c 1B88     		ldrh	r3, [r3]	@ movhi
 634 006e 9BB2     		uxth	r3, r3
 635 0070 013B     		subs	r3, r3, #1
 636 0072 9AB2     		uxth	r2, r3
 637 0074 40F20003 		movw	r3, #:lower16:usSndBufferCount
 638 0078 C0F20003 		movt	r3, #:upper16:usSndBufferCount
 639 007c 1A80     		strh	r2, [r3]	@ movhi
 306:../FreeModbus/rtu/mbrtu.c ****         }
 307:../FreeModbus/rtu/mbrtu.c ****         else
 308:../FreeModbus/rtu/mbrtu.c ****         {
 309:../FreeModbus/rtu/mbrtu.c ****             xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
 310:../FreeModbus/rtu/mbrtu.c ****             /* Disable transmitter. This prevents another transmit buffer
 311:../FreeModbus/rtu/mbrtu.c ****              * empty interrupt. */
 312:../FreeModbus/rtu/mbrtu.c ****             vMBPortSerialEnable( TRUE, FALSE );
 313:../FreeModbus/rtu/mbrtu.c ****             eSndState = STATE_TX_IDLE;
 314:../FreeModbus/rtu/mbrtu.c ****         }
 315:../FreeModbus/rtu/mbrtu.c ****         break;
 640              		.loc 1 315 0
 641 007e 0EE0     		b	.L36
 642              	.L33:
 309:../FreeModbus/rtu/mbrtu.c ****             /* Disable transmitter. This prevents another transmit buffer
 643              		.loc 1 309 0
 644 0080 0320     		movs	r0, #3
 645 0082 FFF7FEFF 		bl	xMBPortEventPost
 646 0086 0346     		mov	r3, r0
 647 0088 FB71     		strb	r3, [r7, #7]
 312:../FreeModbus/rtu/mbrtu.c ****             eSndState = STATE_TX_IDLE;
 648              		.loc 1 312 0
 649 008a 0120     		movs	r0, #1
 650 008c 0021     		movs	r1, #0
 651 008e FFF7FEFF 		bl	vMBPortSerialEnable
 313:../FreeModbus/rtu/mbrtu.c ****         }
 652              		.loc 1 313 0
 653 0092 40F20003 		movw	r3, #:lower16:eSndState
 654 0096 C0F20003 		movt	r3, #:upper16:eSndState
 655 009a 0022     		movs	r2, #0
 656 009c 1A70     		strb	r2, [r3]
 657              	.L36:
 658              		.loc 1 315 0
 659 009e 00BF     		nop
 660              	.L30:
 316:../FreeModbus/rtu/mbrtu.c ****     }
 317:../FreeModbus/rtu/mbrtu.c **** 
 318:../FreeModbus/rtu/mbrtu.c ****     return xNeedPoll;
 661              		.loc 1 318 0
 662 00a0 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 319:../FreeModbus/rtu/mbrtu.c **** }
 663              		.loc 1 319 0
 664 00a2 1846     		mov	r0, r3
 665 00a4 0837     		adds	r7, r7, #8
 666 00a6 BD46     		mov	sp, r7
 667              		@ sp needed
 668 00a8 80BD     		pop	{r7, pc}
 669              		.cfi_endproc
 670              	.LFE35:
 672 00aa 00BF     		.section	.text.xMBRTUTimerT35Expired,"ax",%progbits
 673              		.align	2
 674              		.global	xMBRTUTimerT35Expired
 675              		.thumb
 676              		.thumb_func
 678              	xMBRTUTimerT35Expired:
 679              	.LFB36:
 320:../FreeModbus/rtu/mbrtu.c **** 
 321:../FreeModbus/rtu/mbrtu.c **** BOOL
 322:../FreeModbus/rtu/mbrtu.c **** xMBRTUTimerT35Expired( void )
 323:../FreeModbus/rtu/mbrtu.c **** {
 680              		.loc 1 323 0
 681              		.cfi_startproc
 682              		@ args = 0, pretend = 0, frame = 8
 683              		@ frame_needed = 1, uses_anonymous_args = 0
 684 0000 80B5     		push	{r7, lr}
 685              		.cfi_def_cfa_offset 8
 686              		.cfi_offset 7, -8
 687              		.cfi_offset 14, -4
 688 0002 82B0     		sub	sp, sp, #8
 689              		.cfi_def_cfa_offset 16
 690 0004 00AF     		add	r7, sp, #0
 691              		.cfi_def_cfa_register 7
 324:../FreeModbus/rtu/mbrtu.c ****     BOOL            xNeedPoll = FALSE;
 692              		.loc 1 324 0
 693 0006 0023     		movs	r3, #0
 694 0008 FB71     		strb	r3, [r7, #7]
 325:../FreeModbus/rtu/mbrtu.c **** 
 326:../FreeModbus/rtu/mbrtu.c ****     switch ( eRcvState )
 695              		.loc 1 326 0
 696 000a 40F20003 		movw	r3, #:lower16:eRcvState
 697 000e C0F20003 		movt	r3, #:upper16:eRcvState
 698 0012 1B78     		ldrb	r3, [r3]
 699 0014 DBB2     		uxtb	r3, r3
 700 0016 022B     		cmp	r3, #2
 701 0018 0AD0     		beq	.L39
 702 001a 032B     		cmp	r3, #3
 703 001c 0ED0     		beq	.L44
 704 001e 002B     		cmp	r3, #0
 705 0020 00D0     		beq	.L41
 327:../FreeModbus/rtu/mbrtu.c ****     {
 328:../FreeModbus/rtu/mbrtu.c ****         /* Timer t35 expired. Startup phase is finished. */
 329:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_INIT:
 330:../FreeModbus/rtu/mbrtu.c ****         xNeedPoll = xMBPortEventPost( EV_READY );
 331:../FreeModbus/rtu/mbrtu.c ****         break;
 332:../FreeModbus/rtu/mbrtu.c **** 
 333:../FreeModbus/rtu/mbrtu.c ****         /* A frame was received and t35 expired. Notify the listener that
 334:../FreeModbus/rtu/mbrtu.c ****          * a new frame was received. */
 335:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_RCV:
 336:../FreeModbus/rtu/mbrtu.c ****         xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
 337:../FreeModbus/rtu/mbrtu.c ****         break;
 338:../FreeModbus/rtu/mbrtu.c **** 
 339:../FreeModbus/rtu/mbrtu.c ****         /* An error occured while receiving the frame. */
 340:../FreeModbus/rtu/mbrtu.c ****     case STATE_RX_ERROR:
 341:../FreeModbus/rtu/mbrtu.c ****         break;
 342:../FreeModbus/rtu/mbrtu.c **** 
 343:../FreeModbus/rtu/mbrtu.c ****         /* Function called in an illegal state. */
 344:../FreeModbus/rtu/mbrtu.c ****     default:
 345:../FreeModbus/rtu/mbrtu.c ****         assert_param( ( eRcvState == STATE_RX_INIT ) ||
 346:../FreeModbus/rtu/mbrtu.c ****                 ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
 347:../FreeModbus/rtu/mbrtu.c ****          break;
 706              		.loc 1 347 0
 707 0022 0CE0     		b	.L42
 708              	.L41:
 330:../FreeModbus/rtu/mbrtu.c ****         break;
 709              		.loc 1 330 0
 710 0024 0020     		movs	r0, #0
 711 0026 FFF7FEFF 		bl	xMBPortEventPost
 712 002a 0346     		mov	r3, r0
 713 002c FB71     		strb	r3, [r7, #7]
 331:../FreeModbus/rtu/mbrtu.c **** 
 714              		.loc 1 331 0
 715 002e 06E0     		b	.L42
 716              	.L39:
 336:../FreeModbus/rtu/mbrtu.c ****         break;
 717              		.loc 1 336 0
 718 0030 0120     		movs	r0, #1
 719 0032 FFF7FEFF 		bl	xMBPortEventPost
 720 0036 0346     		mov	r3, r0
 721 0038 FB71     		strb	r3, [r7, #7]
 337:../FreeModbus/rtu/mbrtu.c **** 
 722              		.loc 1 337 0
 723 003a 00E0     		b	.L42
 724              	.L44:
 341:../FreeModbus/rtu/mbrtu.c **** 
 725              		.loc 1 341 0
 726 003c 00BF     		nop
 727              	.L42:
 348:../FreeModbus/rtu/mbrtu.c ****     }
 349:../FreeModbus/rtu/mbrtu.c **** 
 350:../FreeModbus/rtu/mbrtu.c ****     vMBPortTimersDisable(  );
 728              		.loc 1 350 0
 729 003e FFF7FEFF 		bl	vMBPortTimersDisable
 351:../FreeModbus/rtu/mbrtu.c ****     eRcvState = STATE_RX_IDLE;
 730              		.loc 1 351 0
 731 0042 40F20003 		movw	r3, #:lower16:eRcvState
 732 0046 C0F20003 		movt	r3, #:upper16:eRcvState
 733 004a 0122     		movs	r2, #1
 734 004c 1A70     		strb	r2, [r3]
 352:../FreeModbus/rtu/mbrtu.c **** 
 353:../FreeModbus/rtu/mbrtu.c ****     return xNeedPoll;
 735              		.loc 1 353 0
 736 004e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 354:../FreeModbus/rtu/mbrtu.c **** }
 737              		.loc 1 354 0
 738 0050 1846     		mov	r0, r3
 739 0052 0837     		adds	r7, r7, #8
 740 0054 BD46     		mov	sp, r7
 741              		@ sp needed
 742 0056 80BD     		pop	{r7, pc}
 743              		.cfi_endproc
 744              	.LFE36:
 746              		.text
 747              	.Letext0:
 748              		.file 2 "c:\\tools\\arm-none-eabi\\include\\stdint.h"
 749              		.file 3 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\stm32/port.h"
 750              		.file 4 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\include/mbport.h"
 751              		.file 5 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeModbus\\include/mb.h"
 752              		.file 6 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\Libraries\\CMSIS/core_cm3.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mbrtu.c
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:21     .bss.eSndState:00000000 eSndState
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:22     .bss.eSndState:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:26     .bss.eRcvState:00000000 eRcvState
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:27     .bss.eRcvState:00000000 $d
                            *COM*:00000100 ucRTUBuf
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:30     .bss.pucSndBufferCur:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:33     .bss.pucSndBufferCur:00000000 pucSndBufferCur
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:36     .bss.usSndBufferCount:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:39     .bss.usSndBufferCount:00000000 usSndBufferCount
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:42     .bss.usRcvBufferPos:00000000 $d
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:45     .bss.usRcvBufferPos:00000000 usRcvBufferPos
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:48     .text.eMBRTUInit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:53     .text.eMBRTUInit:00000000 eMBRTUInit
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:137    .text.eMBRTUStart:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:142    .text.eMBRTUStart:00000000 eMBRTUStart
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:175    .text.eMBRTUStop:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:180    .text.eMBRTUStop:00000000 eMBRTUStop
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:208    .text.eMBRTUReceive:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:213    .text.eMBRTUReceive:00000000 eMBRTUReceive
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:293    .text.eMBRTUReceive:00000084 $d
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:298    .text.eMBRTUSend:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:303    .text.eMBRTUSend:00000000 eMBRTUSend
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:438    .text.xMBRTUReceiveFSM:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:443    .text.xMBRTUReceiveFSM:00000000 xMBRTUReceiveFSM
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:475    .text.xMBRTUReceiveFSM:00000028 $d
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:481    .text.xMBRTUReceiveFSM:00000038 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:567    .text.xMBRTUTransmitFSM:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:572    .text.xMBRTUTransmitFSM:00000000 xMBRTUTransmitFSM
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:673    .text.xMBRTUTimerT35Expired:00000000 $t
C:\Users\Alex\AppData\Local\Temp\ccU52hpV.s:678    .text.xMBRTUTimerT35Expired:00000000 xMBRTUTimerT35Expired
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.98ffea2db242cfdb58f411f7407f2b59
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.183.aa62afef667fb61d15fa64c48beb2f14
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.stdlib.h.18.8bab2fb43ac4e90235390733c30a4530
                           .group:00000000 wm4.stddef.h.184.aa65fb7281d578229bbad41b91862635
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.59.db8450f33c1f6150c0372fa1091a887a
                           .group:00000000 wm4.stddef.h.348.9a99de77b6ba3b4278b57e9cc6d6e349
                           .group:00000000 wm4.reent.h.16.567d760e6ae9ad7f917851a308bd7a57
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.7091a050e07f1c4abd225630fe3d62f1
                           .group:00000000 wm4.stddef.h.39.d0197034aa5fd947cae140b9289e6734
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.cdefs.h.56.efab90f4d89fbc41d6b3a5c5fb0d3d0f
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.stm32f10x_conf.h.2.f1a8c33f0a763aeef696fee38b2b2dbc
                           .group:00000000 wm4.mbconfig.h.33.2e295d4ff98bc723e2405a40490b5ddb
                           .group:00000000 wm4.assert.h.11.060c3dc511517628fd4f958fa9448dce
                           .group:00000000 wm4.inttypes.h.14.48280a9a5aa6f2f2d5302e2988897736
                           .group:00000000 wm4.inttypes.h.24.8137491c6995c2cb5d25f9bab92d7f64
                           .group:00000000 wm4.stm32f10x.h.51.b859cb68ed44ee02c916b41cb8c68f1c
                           .group:00000000 wm4.core_cm3.h.25.119fe996be41b62fbd915b59177e39d1
                           .group:00000000 wm4.stm32f10x.h.522.a925aafc848b1f088438cf0e9b167b78
                           .group:00000000 wm4.stm32f10x.h.8304.f7d8ad90959e99679b3257267c3aadfe
                           .group:00000000 wm4.stm32f10x_rcc.h.25.fe8897e7491f2eb0cff54551d08eb765
                           .group:00000000 wm4.portmacro.h.56.a47bdd86bc36d334ca6056492e2d709f
                           .group:00000000 wm4.port.h.38.e5d12e3086604499e6922efe9c85cac5
                           .group:00000000 wm4.mbproto.h.32.da85c2bdd9bdb84e975a92c999a4b490
                           .group:00000000 wm4.mbframe.h.32.cb3fc2a5a44fcaf8fe721dce49a4ba3c

UNDEFINED SYMBOLS
vPortEnterCritical
xMBPortSerialInit
xMBPortTimersInit
vPortExitCritical
vMBPortSerialEnable
vMBPortTimersEnable
vMBPortTimersDisable
usMBCRC16
xMBPortSerialGetByte
xMBPortSerialPutByte
xMBPortEventPost
