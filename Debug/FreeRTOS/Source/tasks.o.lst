   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.section	.bss.pxCurrentTCB,"aw",%nobits
  20              		.align	2
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  26              		.align	2
  29              	pxReadyTasksLists:
  30 0000 00000000 		.space	100
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  32              		.align	2
  35              	xDelayedTaskList1:
  36 0000 00000000 		.space	20
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  38              		.align	2
  41              	xDelayedTaskList2:
  42 0000 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  44              		.align	2
  47              	pxDelayedTaskList:
  48 0000 00000000 		.space	4
  49              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  50              		.align	2
  53              	pxOverflowDelayedTaskList:
  54 0000 00000000 		.space	4
  55              		.section	.bss.xPendingReadyList,"aw",%nobits
  56              		.align	2
  59              	xPendingReadyList:
  60 0000 00000000 		.space	20
  60      00000000 
  60      00000000 
  60      00000000 
  60      00000000 
  61              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  62              		.align	2
  65              	xTasksWaitingTermination:
  66 0000 00000000 		.space	20
  66      00000000 
  66      00000000 
  66      00000000 
  66      00000000 
  67              		.section	.bss.uxTasksDeleted,"aw",%nobits
  68              		.align	2
  71              	uxTasksDeleted:
  72 0000 00000000 		.space	4
  73              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  74              		.align	2
  77              	xSuspendedTaskList:
  78 0000 00000000 		.space	20
  78      00000000 
  78      00000000 
  78      00000000 
  78      00000000 
  79              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  80              		.align	2
  83              	uxCurrentNumberOfTasks:
  84 0000 00000000 		.space	4
  85              		.section	.bss.xTickCount,"aw",%nobits
  86              		.align	2
  89              	xTickCount:
  90 0000 00000000 		.space	4
  91              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  92              		.align	2
  95              	uxTopUsedPriority:
  96 0000 00000000 		.space	4
  97              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  98              		.align	2
 101              	uxTopReadyPriority:
 102 0000 00000000 		.space	4
 103              		.section	.bss.xSchedulerRunning,"aw",%nobits
 104              		.align	2
 107              	xSchedulerRunning:
 108 0000 00000000 		.space	4
 109              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 110              		.align	2
 113              	uxSchedulerSuspended:
 114 0000 00000000 		.space	4
 115              		.section	.bss.uxMissedTicks,"aw",%nobits
 116              		.align	2
 119              	uxMissedTicks:
 120 0000 00000000 		.space	4
 121              		.section	.bss.xMissedYield,"aw",%nobits
 122              		.align	2
 125              	xMissedYield:
 126 0000 00000000 		.space	4
 127              		.section	.bss.xNumOfOverflows,"aw",%nobits
 128              		.align	2
 131              	xNumOfOverflows:
 132 0000 00000000 		.space	4
 133              		.section	.bss.uxTCBNumber,"aw",%nobits
 134              		.align	2
 137              	uxTCBNumber:
 138 0000 00000000 		.space	4
 139              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 140              		.align	2
 143              	xNextTaskUnblockTime:
 144 0000 FFFFFFFF 		.word	-1
 145              		.section	.text.xTaskGenericCreate,"ax",%progbits
 146              		.align	2
 147              		.global	xTaskGenericCreate
 148              		.thumb
 149              		.thumb_func
 151              	xTaskGenericCreate:
 152              	.LFB0:
 153              		.file 1 "../FreeRTOS/Source/tasks.c"
   1:../FreeRTOS/Source/tasks.c **** /*
   2:../FreeRTOS/Source/tasks.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../FreeRTOS/Source/tasks.c **** 	
   4:../FreeRTOS/Source/tasks.c **** 
   5:../FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:../FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:../FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:../FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:../FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:../FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:../FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:../FreeRTOS/Source/tasks.c **** 
  24:../FreeRTOS/Source/tasks.c **** 
  25:../FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../FreeRTOS/Source/tasks.c **** 
  27:../FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:../FreeRTOS/Source/tasks.c **** 
  42:../FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:../FreeRTOS/Source/tasks.c **** 
  44:../FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../FreeRTOS/Source/tasks.c ****     contact details.
  46:../FreeRTOS/Source/tasks.c **** 
  47:../FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../FreeRTOS/Source/tasks.c ****     critical systems.
  49:../FreeRTOS/Source/tasks.c **** 
  50:../FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:../FreeRTOS/Source/tasks.c **** */
  53:../FreeRTOS/Source/tasks.c **** 
  54:../FreeRTOS/Source/tasks.c **** 
  55:../FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:../FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:../FreeRTOS/Source/tasks.c **** #include <string.h>
  58:../FreeRTOS/Source/tasks.c **** 
  59:../FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:../FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../FreeRTOS/Source/tasks.c **** 
  64:../FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:../FreeRTOS/Source/tasks.c **** #include "task.h"
  66:../FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:../FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:../FreeRTOS/Source/tasks.c **** 
  69:../FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../FreeRTOS/Source/tasks.c **** 
  71:../FreeRTOS/Source/tasks.c **** /*
  72:../FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../FreeRTOS/Source/tasks.c ****  */
  74:../FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../FreeRTOS/Source/tasks.c **** 
  76:../FreeRTOS/Source/tasks.c **** /*
  77:../FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:../FreeRTOS/Source/tasks.c ****  */
  80:../FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:../FreeRTOS/Source/tasks.c **** {
  82:../FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../FreeRTOS/Source/tasks.c **** 
  84:../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../FreeRTOS/Source/tasks.c **** 	#endif	
  87:../FreeRTOS/Source/tasks.c **** 	
  88:../FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../FreeRTOS/Source/tasks.c **** 
  94:../FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../FreeRTOS/Source/tasks.c **** 	#endif
  97:../FreeRTOS/Source/tasks.c **** 
  98:../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../FreeRTOS/Source/tasks.c **** 	#endif
 101:../FreeRTOS/Source/tasks.c **** 
 102:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 104:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 105:../FreeRTOS/Source/tasks.c **** 	#endif
 106:../FreeRTOS/Source/tasks.c **** 
 107:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:../FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:../FreeRTOS/Source/tasks.c **** 	#endif
 110:../FreeRTOS/Source/tasks.c **** 
 111:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:../FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:../FreeRTOS/Source/tasks.c **** 	#endif
 114:../FreeRTOS/Source/tasks.c **** 
 115:../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:../FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:../FreeRTOS/Source/tasks.c **** 	#endif
 118:../FreeRTOS/Source/tasks.c **** 
 119:../FreeRTOS/Source/tasks.c **** } tskTCB;
 120:../FreeRTOS/Source/tasks.c **** 
 121:../FreeRTOS/Source/tasks.c **** 
 122:../FreeRTOS/Source/tasks.c **** /*
 123:../FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:../FreeRTOS/Source/tasks.c ****  * than file scope.
 125:../FreeRTOS/Source/tasks.c ****  */
 126:../FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:../FreeRTOS/Source/tasks.c **** 	#define static
 128:../FreeRTOS/Source/tasks.c **** #endif
 129:../FreeRTOS/Source/tasks.c **** 
 130:../FreeRTOS/Source/tasks.c **** /*lint -e956 */
 131:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:../FreeRTOS/Source/tasks.c **** 
 133:../FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:../FreeRTOS/Source/tasks.c **** 
 135:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:../FreeRTOS/Source/tasks.c **** 
 142:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:../FreeRTOS/Source/tasks.c **** 
 144:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 145:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:../FreeRTOS/Source/tasks.c **** 
 147:../FreeRTOS/Source/tasks.c **** #endif
 148:../FreeRTOS/Source/tasks.c **** 
 149:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:../FreeRTOS/Source/tasks.c **** 
 151:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:../FreeRTOS/Source/tasks.c **** 
 153:../FreeRTOS/Source/tasks.c **** #endif
 154:../FreeRTOS/Source/tasks.c **** 
 155:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 156:../FreeRTOS/Source/tasks.c **** 	
 157:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 158:../FreeRTOS/Source/tasks.c **** 	
 159:../FreeRTOS/Source/tasks.c **** #endif
 160:../FreeRTOS/Source/tasks.c **** 
 161:../FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 162:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 163:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 164:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 165:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 166:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 167:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 168:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 169:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 170:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 171:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
 172:../FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 173:../FreeRTOS/Source/tasks.c **** 
 174:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 175:../FreeRTOS/Source/tasks.c **** 
 176:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 177:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 178:../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 179:../FreeRTOS/Source/tasks.c **** 
 180:../FreeRTOS/Source/tasks.c **** #endif
 181:../FreeRTOS/Source/tasks.c **** 
 182:../FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 183:../FreeRTOS/Source/tasks.c **** 
 184:../FreeRTOS/Source/tasks.c **** /*
 185:../FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 186:../FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 187:../FreeRTOS/Source/tasks.c ****  */
 188:../FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 189:../FreeRTOS/Source/tasks.c **** 
 190:../FreeRTOS/Source/tasks.c **** /*
 191:../FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 192:../FreeRTOS/Source/tasks.c ****  */
 193:../FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 194:../FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 195:../FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 196:../FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 197:../FreeRTOS/Source/tasks.c **** 
 198:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 199:../FreeRTOS/Source/tasks.c **** 
 200:../FreeRTOS/Source/tasks.c **** /*
 201:../FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 202:../FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 203:../FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 204:../FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 205:../FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 206:../FreeRTOS/Source/tasks.c ****  */
 207:../FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 208:../FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 209:../FreeRTOS/Source/tasks.c **** 	{																													\
 210:../FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 211:../FreeRTOS/Source/tasks.c **** 	}																													\
 212:../FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 213:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 214:../FreeRTOS/Source/tasks.c **** 
 215:../FreeRTOS/Source/tasks.c **** /*
 216:../FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 217:../FreeRTOS/Source/tasks.c ****  * any require waking.
 218:../FreeRTOS/Source/tasks.c ****  *
 219:../FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 220:../FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 221:../FreeRTOS/Source/tasks.c ****  * any further down the list.
 222:../FreeRTOS/Source/tasks.c ****  */
 223:../FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 224:../FreeRTOS/Source/tasks.c **** {																						\
 225:../FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 226:../FreeRTOS/Source/tasks.c **** 																						\
 227:../FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 228:../FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 229:../FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 230:../FreeRTOS/Source/tasks.c **** 	{																					\
 231:../FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 232:../FreeRTOS/Source/tasks.c **** 		{																				\
 233:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 234:../FreeRTOS/Source/tasks.c **** 			{																			\
 235:../FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 236:../FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 237:../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 238:../FreeRTOS/Source/tasks.c **** 				time through. */														\
 239:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 240:../FreeRTOS/Source/tasks.c **** 				break;																	\
 241:../FreeRTOS/Source/tasks.c **** 			}																			\
 242:../FreeRTOS/Source/tasks.c **** 			else																		\
 243:../FreeRTOS/Source/tasks.c **** 			{																			\
 244:../FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 245:../FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 246:../FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 247:../FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 248:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 249:../FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 250:../FreeRTOS/Source/tasks.c **** 																						\
 251:../FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 252:../FreeRTOS/Source/tasks.c **** 				{																		\
 253:../FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 254:../FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 255:../FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 256:../FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 257:../FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 258:../FreeRTOS/Source/tasks.c **** 					break;																\
 259:../FreeRTOS/Source/tasks.c **** 				}																		\
 260:../FreeRTOS/Source/tasks.c **** 																						\
 261:../FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 262:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 263:../FreeRTOS/Source/tasks.c **** 																						\
 264:../FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 265:../FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 266:../FreeRTOS/Source/tasks.c **** 				{																		\
 267:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 268:../FreeRTOS/Source/tasks.c **** 				}																		\
 269:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 270:../FreeRTOS/Source/tasks.c **** 			}																			\
 271:../FreeRTOS/Source/tasks.c **** 		}																				\
 272:../FreeRTOS/Source/tasks.c **** 	}																					\
 273:../FreeRTOS/Source/tasks.c **** }
 274:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 275:../FreeRTOS/Source/tasks.c **** 
 276:../FreeRTOS/Source/tasks.c **** /*
 277:../FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 278:../FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 279:../FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 280:../FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 281:../FreeRTOS/Source/tasks.c ****  */
 282:../FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 283:../FreeRTOS/Source/tasks.c **** 
 284:../FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 285:../FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 286:../FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 287:../FreeRTOS/Source/tasks.c **** 		
 288:../FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 289:../FreeRTOS/Source/tasks.c **** 
 290:../FreeRTOS/Source/tasks.c **** /*
 291:../FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 292:../FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 293:../FreeRTOS/Source/tasks.c ****  */
 294:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 295:../FreeRTOS/Source/tasks.c **** 
 296:../FreeRTOS/Source/tasks.c **** /*
 297:../FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 298:../FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 299:../FreeRTOS/Source/tasks.c ****  */
 300:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 301:../FreeRTOS/Source/tasks.c **** 
 302:../FreeRTOS/Source/tasks.c **** /*
 303:../FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 304:../FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 305:../FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 306:../FreeRTOS/Source/tasks.c ****  *
 307:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 308:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 309:../FreeRTOS/Source/tasks.c ****  *
 310:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 311:../FreeRTOS/Source/tasks.c ****  *
 312:../FreeRTOS/Source/tasks.c ****  */
 313:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 314:../FreeRTOS/Source/tasks.c **** 
 315:../FreeRTOS/Source/tasks.c **** /*
 316:../FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 317:../FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 318:../FreeRTOS/Source/tasks.c ****  *
 319:../FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 320:../FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 321:../FreeRTOS/Source/tasks.c ****  */
 322:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 323:../FreeRTOS/Source/tasks.c **** 
 324:../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 325:../FreeRTOS/Source/tasks.c **** 
 326:../FreeRTOS/Source/tasks.c **** #endif
 327:../FreeRTOS/Source/tasks.c **** 
 328:../FreeRTOS/Source/tasks.c **** /*
 329:../FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 330:../FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 331:../FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 332:../FreeRTOS/Source/tasks.c ****  */
 333:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 334:../FreeRTOS/Source/tasks.c **** 
 335:../FreeRTOS/Source/tasks.c **** /*
 336:../FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 337:../FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 338:../FreeRTOS/Source/tasks.c ****  */
 339:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 340:../FreeRTOS/Source/tasks.c **** 
 341:../FreeRTOS/Source/tasks.c **** /*
 342:../FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 343:../FreeRTOS/Source/tasks.c ****  * allocation was successful.
 344:../FreeRTOS/Source/tasks.c ****  */
 345:../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 346:../FreeRTOS/Source/tasks.c **** 
 347:../FreeRTOS/Source/tasks.c **** /*
 348:../FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 349:../FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 350:../FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 351:../FreeRTOS/Source/tasks.c ****  * within just that list.
 352:../FreeRTOS/Source/tasks.c ****  *
 353:../FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 354:../FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 355:../FreeRTOS/Source/tasks.c ****  */
 356:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 357:../FreeRTOS/Source/tasks.c **** 
 358:../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 359:../FreeRTOS/Source/tasks.c **** 
 360:../FreeRTOS/Source/tasks.c **** #endif
 361:../FreeRTOS/Source/tasks.c **** 
 362:../FreeRTOS/Source/tasks.c **** /*
 363:../FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 364:../FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 365:../FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 366:../FreeRTOS/Source/tasks.c ****  */
 367:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 368:../FreeRTOS/Source/tasks.c **** 
 369:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 370:../FreeRTOS/Source/tasks.c **** 
 371:../FreeRTOS/Source/tasks.c **** #endif
 372:../FreeRTOS/Source/tasks.c **** 
 373:../FreeRTOS/Source/tasks.c **** 
 374:../FreeRTOS/Source/tasks.c **** /*lint +e956 */
 375:../FreeRTOS/Source/tasks.c **** 
 376:../FreeRTOS/Source/tasks.c **** 
 377:../FreeRTOS/Source/tasks.c **** 
 378:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 379:../FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 380:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 381:../FreeRTOS/Source/tasks.c **** 
 382:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 383:../FreeRTOS/Source/tasks.c **** {
 154              		.loc 1 383 0
 155              		.cfi_startproc
 156              		@ args = 16, pretend = 0, frame = 32
 157              		@ frame_needed = 1, uses_anonymous_args = 0
 158 0000 80B5     		push	{r7, lr}
 159              		.cfi_def_cfa_offset 8
 160              		.cfi_offset 7, -8
 161              		.cfi_offset 14, -4
 162 0002 8AB0     		sub	sp, sp, #40
 163              		.cfi_def_cfa_offset 48
 164 0004 02AF     		add	r7, sp, #8
 165              		.cfi_def_cfa 7, 40
 166 0006 F860     		str	r0, [r7, #12]
 167 0008 B960     		str	r1, [r7, #8]
 168 000a 3B60     		str	r3, [r7]
 169 000c 1346     		mov	r3, r2	@ movhi
 170 000e FB80     		strh	r3, [r7, #6]	@ movhi
 384:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 385:../FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 386:../FreeRTOS/Source/tasks.c **** 
 387:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 171              		.loc 1 387 0
 172 0010 FB68     		ldr	r3, [r7, #12]
 173 0012 002B     		cmp	r3, #0
 174 0014 04D1     		bne	.L2
 175              		.loc 1 387 0 is_stmt 0 discriminator 1
 176              	@ 387 "../FreeRTOS/Source/tasks.c" 1
 177 0016 4FF05000 			mov r0, #80								
 178 001a 80F31188 		msr basepri, r0							
 179              	
 180              	@ 0 "" 2
 181              		.thumb
 182              	.L3:
 183 001e FEE7     		b	.L3
 184              	.L2:
 388:../FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 185              		.loc 1 388 0 is_stmt 1
 186 0020 BB6A     		ldr	r3, [r7, #40]
 187 0022 042B     		cmp	r3, #4
 188 0024 04D9     		bls	.L4
 189              		.loc 1 388 0 is_stmt 0 discriminator 1
 190              	@ 388 "../FreeRTOS/Source/tasks.c" 1
 191 0026 4FF05000 			mov r0, #80								
 192 002a 80F31188 		msr basepri, r0							
 193              	
 194              	@ 0 "" 2
 195              		.thumb
 196              	.L5:
 197 002e FEE7     		b	.L5
 198              	.L4:
 389:../FreeRTOS/Source/tasks.c **** 
 390:../FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 391:../FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 392:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 199              		.loc 1 392 0 is_stmt 1
 200 0030 FB88     		ldrh	r3, [r7, #6]
 201 0032 1846     		mov	r0, r3
 202 0034 396B     		ldr	r1, [r7, #48]
 203 0036 FFF7FEFF 		bl	prvAllocateTCBAndStack
 204 003a B861     		str	r0, [r7, #24]
 393:../FreeRTOS/Source/tasks.c **** 
 394:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 205              		.loc 1 394 0
 206 003c BB69     		ldr	r3, [r7, #24]
 207 003e 002B     		cmp	r3, #0
 208 0040 00F0B380 		beq	.L6
 209              	.LBB2:
 395:../FreeRTOS/Source/tasks.c **** 	{
 396:../FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 397:../FreeRTOS/Source/tasks.c **** 
 398:../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 399:../FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 400:../FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 401:../FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 402:../FreeRTOS/Source/tasks.c **** 			{
 403:../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 404:../FreeRTOS/Source/tasks.c **** 			}
 405:../FreeRTOS/Source/tasks.c **** 			else
 406:../FreeRTOS/Source/tasks.c **** 			{
 407:../FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 408:../FreeRTOS/Source/tasks.c **** 			}
 409:../FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 410:../FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 411:../FreeRTOS/Source/tasks.c **** 
 412:../FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 413:../FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 414:../FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 415:../FreeRTOS/Source/tasks.c **** 		required by the port. */
 416:../FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 417:../FreeRTOS/Source/tasks.c **** 		{
 418:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 210              		.loc 1 418 0
 211 0044 BB69     		ldr	r3, [r7, #24]
 212 0046 1A6B     		ldr	r2, [r3, #48]
 213 0048 FB88     		ldrh	r3, [r7, #6]
 214 004a 03F18043 		add	r3, r3, #1073741824
 215 004e 013B     		subs	r3, r3, #1
 216 0050 9B00     		lsls	r3, r3, #2
 217 0052 1344     		add	r3, r3, r2
 218 0054 7B61     		str	r3, [r7, #20]
 419:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 219              		.loc 1 419 0
 220 0056 7B69     		ldr	r3, [r7, #20]
 221 0058 23F00703 		bic	r3, r3, #7
 222 005c 7B61     		str	r3, [r7, #20]
 420:../FreeRTOS/Source/tasks.c **** 
 421:../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 422:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 223              		.loc 1 422 0
 224 005e 7B69     		ldr	r3, [r7, #20]
 225 0060 03F00703 		and	r3, r3, #7
 226 0064 002B     		cmp	r3, #0
 227 0066 04D0     		beq	.L7
 228              		.loc 1 422 0 is_stmt 0 discriminator 1
 229              	@ 422 "../FreeRTOS/Source/tasks.c" 1
 230 0068 4FF05000 			mov r0, #80								
 231 006c 80F31188 		msr basepri, r0							
 232              	
 233              	@ 0 "" 2
 234              		.thumb
 235              	.L8:
 236 0070 FEE7     		b	.L8
 237              	.L7:
 423:../FreeRTOS/Source/tasks.c **** 		}
 424:../FreeRTOS/Source/tasks.c **** 		#else
 425:../FreeRTOS/Source/tasks.c **** 		{
 426:../FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:../FreeRTOS/Source/tasks.c **** 			
 428:../FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 429:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 430:../FreeRTOS/Source/tasks.c **** 
 431:../FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 432:../FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 433:../FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 434:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 435:../FreeRTOS/Source/tasks.c **** 		}
 436:../FreeRTOS/Source/tasks.c **** 		#endif
 437:../FreeRTOS/Source/tasks.c **** 
 438:../FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 439:../FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 238              		.loc 1 439 0 is_stmt 1
 239 0072 FB88     		ldrh	r3, [r7, #6]
 240 0074 0093     		str	r3, [sp]
 241 0076 B869     		ldr	r0, [r7, #24]
 242 0078 B968     		ldr	r1, [r7, #8]
 243 007a BA6A     		ldr	r2, [r7, #40]
 244 007c 7B6B     		ldr	r3, [r7, #52]
 245 007e FFF7FEFF 		bl	prvInitialiseTCBVariables
 440:../FreeRTOS/Source/tasks.c **** 
 441:../FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 442:../FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 443:../FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 444:../FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 445:../FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 446:../FreeRTOS/Source/tasks.c **** 		{
 447:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 448:../FreeRTOS/Source/tasks.c **** 		}
 449:../FreeRTOS/Source/tasks.c **** 		#else
 450:../FreeRTOS/Source/tasks.c **** 		{
 451:../FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 246              		.loc 1 451 0
 247 0082 7869     		ldr	r0, [r7, #20]
 248 0084 F968     		ldr	r1, [r7, #12]
 249 0086 3A68     		ldr	r2, [r7]
 250 0088 FFF7FEFF 		bl	pxPortInitialiseStack
 251 008c 0246     		mov	r2, r0
 252 008e BB69     		ldr	r3, [r7, #24]
 253 0090 1A60     		str	r2, [r3]
 452:../FreeRTOS/Source/tasks.c **** 		}
 453:../FreeRTOS/Source/tasks.c **** 		#endif
 454:../FreeRTOS/Source/tasks.c **** 
 455:../FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 456:../FreeRTOS/Source/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 254              		.loc 1 456 0
 255 0092 BB69     		ldr	r3, [r7, #24]
 256 0094 1B68     		ldr	r3, [r3]
 257 0096 03F00703 		and	r3, r3, #7
 258 009a 002B     		cmp	r3, #0
 259 009c 04D0     		beq	.L9
 260              		.loc 1 456 0 is_stmt 0 discriminator 1
 261              	@ 456 "../FreeRTOS/Source/tasks.c" 1
 262 009e 4FF05000 			mov r0, #80								
 263 00a2 80F31188 		msr basepri, r0							
 264              	
 265              	@ 0 "" 2
 266              		.thumb
 267              	.L10:
 268 00a6 FEE7     		b	.L10
 269              	.L9:
 457:../FreeRTOS/Source/tasks.c **** 
 458:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 270              		.loc 1 458 0 is_stmt 1
 271 00a8 FB6A     		ldr	r3, [r7, #44]
 272 00aa 002B     		cmp	r3, #0
 273 00ac 02D0     		beq	.L11
 459:../FreeRTOS/Source/tasks.c **** 		{
 460:../FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 461:../FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 462:../FreeRTOS/Source/tasks.c **** 			required.*/
 463:../FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 274              		.loc 1 463 0
 275 00ae FB6A     		ldr	r3, [r7, #44]
 276 00b0 BA69     		ldr	r2, [r7, #24]
 277 00b2 1A60     		str	r2, [r3]
 278              	.L11:
 464:../FreeRTOS/Source/tasks.c **** 		}
 465:../FreeRTOS/Source/tasks.c **** 		
 466:../FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 467:../FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 468:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 279              		.loc 1 468 0
 280 00b4 FFF7FEFF 		bl	vPortEnterCritical
 469:../FreeRTOS/Source/tasks.c **** 		{
 470:../FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 281              		.loc 1 470 0
 282 00b8 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 283 00bc C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 284 00c0 1B68     		ldr	r3, [r3]
 285 00c2 5A1C     		adds	r2, r3, #1
 286 00c4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 287 00c8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 288 00cc 1A60     		str	r2, [r3]
 471:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 289              		.loc 1 471 0
 290 00ce 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 291 00d2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 292 00d6 1B68     		ldr	r3, [r3]
 293 00d8 002B     		cmp	r3, #0
 294 00da 0FD1     		bne	.L12
 472:../FreeRTOS/Source/tasks.c **** 			{
 473:../FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 474:../FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 475:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 295              		.loc 1 475 0
 296 00dc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 297 00e0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 298 00e4 BA69     		ldr	r2, [r7, #24]
 299 00e6 1A60     		str	r2, [r3]
 476:../FreeRTOS/Source/tasks.c **** 
 477:../FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 300              		.loc 1 477 0
 301 00e8 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 302 00ec C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 303 00f0 1B68     		ldr	r3, [r3]
 304 00f2 012B     		cmp	r3, #1
 305 00f4 18D1     		bne	.L14
 478:../FreeRTOS/Source/tasks.c **** 				{
 479:../FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 480:../FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 481:../FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 482:../FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 306              		.loc 1 482 0
 307 00f6 FFF7FEFF 		bl	prvInitialiseTaskLists
 308 00fa 15E0     		b	.L14
 309              	.L12:
 483:../FreeRTOS/Source/tasks.c **** 				}
 484:../FreeRTOS/Source/tasks.c **** 			}
 485:../FreeRTOS/Source/tasks.c **** 			else
 486:../FreeRTOS/Source/tasks.c **** 			{
 487:../FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 488:../FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 489:../FreeRTOS/Source/tasks.c **** 				so far. */
 490:../FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 310              		.loc 1 490 0
 311 00fc 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 312 0100 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 313 0104 1B68     		ldr	r3, [r3]
 314 0106 002B     		cmp	r3, #0
 315 0108 0ED1     		bne	.L14
 491:../FreeRTOS/Source/tasks.c **** 				{
 492:../FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 316              		.loc 1 492 0
 317 010a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 318 010e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 319 0112 1B68     		ldr	r3, [r3]
 320 0114 DA6A     		ldr	r2, [r3, #44]
 321 0116 BB6A     		ldr	r3, [r7, #40]
 322 0118 9A42     		cmp	r2, r3
 323 011a 05D8     		bhi	.L14
 493:../FreeRTOS/Source/tasks.c **** 					{
 494:../FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 324              		.loc 1 494 0
 325 011c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 326 0120 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 327 0124 BA69     		ldr	r2, [r7, #24]
 328 0126 1A60     		str	r2, [r3]
 329              	.L14:
 495:../FreeRTOS/Source/tasks.c **** 					}
 496:../FreeRTOS/Source/tasks.c **** 				}
 497:../FreeRTOS/Source/tasks.c **** 			}
 498:../FreeRTOS/Source/tasks.c **** 
 499:../FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 500:../FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 501:../FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 330              		.loc 1 501 0
 331 0128 BB69     		ldr	r3, [r7, #24]
 332 012a DA6A     		ldr	r2, [r3, #44]
 333 012c 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 334 0130 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 335 0134 1B68     		ldr	r3, [r3]
 336 0136 9A42     		cmp	r2, r3
 337 0138 06D9     		bls	.L15
 502:../FreeRTOS/Source/tasks.c **** 			{
 503:../FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 338              		.loc 1 503 0
 339 013a BB69     		ldr	r3, [r7, #24]
 340 013c DA6A     		ldr	r2, [r3, #44]
 341 013e 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 342 0142 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 343 0146 1A60     		str	r2, [r3]
 344              	.L15:
 504:../FreeRTOS/Source/tasks.c **** 			}
 505:../FreeRTOS/Source/tasks.c **** 
 506:../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 507:../FreeRTOS/Source/tasks.c **** 			{
 508:../FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 509:../FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTCBNumber;
 510:../FreeRTOS/Source/tasks.c **** 			}
 511:../FreeRTOS/Source/tasks.c **** 			#endif
 512:../FreeRTOS/Source/tasks.c **** 			uxTCBNumber++;
 345              		.loc 1 512 0
 346 0148 40F20003 		movw	r3, #:lower16:uxTCBNumber
 347 014c C0F20003 		movt	r3, #:upper16:uxTCBNumber
 348 0150 1B68     		ldr	r3, [r3]
 349 0152 5A1C     		adds	r2, r3, #1
 350 0154 40F20003 		movw	r3, #:lower16:uxTCBNumber
 351 0158 C0F20003 		movt	r3, #:upper16:uxTCBNumber
 352 015c 1A60     		str	r2, [r3]
 513:../FreeRTOS/Source/tasks.c **** 
 514:../FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 353              		.loc 1 514 0
 354 015e BB69     		ldr	r3, [r7, #24]
 355 0160 DA6A     		ldr	r2, [r3, #44]
 356 0162 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 357 0166 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 358 016a 1B68     		ldr	r3, [r3]
 359 016c 9A42     		cmp	r2, r3
 360 016e 06D9     		bls	.L16
 361              		.loc 1 514 0 is_stmt 0 discriminator 1
 362 0170 BB69     		ldr	r3, [r7, #24]
 363 0172 DA6A     		ldr	r2, [r3, #44]
 364 0174 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 365 0178 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 366 017c 1A60     		str	r2, [r3]
 367              	.L16:
 368              		.loc 1 514 0 discriminator 2
 369 017e BB69     		ldr	r3, [r7, #24]
 370 0180 DA6A     		ldr	r2, [r3, #44]
 371 0182 1346     		mov	r3, r2
 372 0184 9B00     		lsls	r3, r3, #2
 373 0186 1344     		add	r3, r3, r2
 374 0188 9B00     		lsls	r3, r3, #2
 375 018a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 376 018e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 377 0192 1A44     		add	r2, r2, r3
 378 0194 BB69     		ldr	r3, [r7, #24]
 379 0196 0433     		adds	r3, r3, #4
 380 0198 1046     		mov	r0, r2
 381 019a 1946     		mov	r1, r3
 382 019c FFF7FEFF 		bl	vListInsertEnd
 515:../FreeRTOS/Source/tasks.c **** 
 516:../FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 383              		.loc 1 516 0 is_stmt 1 discriminator 2
 384 01a0 0123     		movs	r3, #1
 385 01a2 FB61     		str	r3, [r7, #28]
 517:../FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 518:../FreeRTOS/Source/tasks.c **** 		}
 519:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 386              		.loc 1 519 0 discriminator 2
 387 01a4 FFF7FEFF 		bl	vPortExitCritical
 388              	.LBE2:
 389 01a8 02E0     		b	.L17
 390              	.L6:
 520:../FreeRTOS/Source/tasks.c **** 	}
 521:../FreeRTOS/Source/tasks.c **** 	else
 522:../FreeRTOS/Source/tasks.c **** 	{
 523:../FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 391              		.loc 1 523 0
 392 01aa 4FF0FF33 		mov	r3, #-1
 393 01ae FB61     		str	r3, [r7, #28]
 394              	.L17:
 524:../FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 525:../FreeRTOS/Source/tasks.c **** 	}
 526:../FreeRTOS/Source/tasks.c **** 
 527:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 395              		.loc 1 527 0
 396 01b0 FB69     		ldr	r3, [r7, #28]
 397 01b2 012B     		cmp	r3, #1
 398 01b4 11D1     		bne	.L18
 528:../FreeRTOS/Source/tasks.c **** 	{
 529:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 399              		.loc 1 529 0
 400 01b6 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 401 01ba C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 402 01be 1B68     		ldr	r3, [r3]
 403 01c0 002B     		cmp	r3, #0
 404 01c2 0AD0     		beq	.L18
 530:../FreeRTOS/Source/tasks.c **** 		{
 531:../FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 532:../FreeRTOS/Source/tasks.c **** 			then it should run now. */
 533:../FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 405              		.loc 1 533 0
 406 01c4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 407 01c8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 408 01cc 1B68     		ldr	r3, [r3]
 409 01ce DA6A     		ldr	r2, [r3, #44]
 410 01d0 BB6A     		ldr	r3, [r7, #40]
 411 01d2 9A42     		cmp	r2, r3
 412 01d4 01D2     		bcs	.L18
 534:../FreeRTOS/Source/tasks.c **** 			{
 535:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 413              		.loc 1 535 0
 414 01d6 FFF7FEFF 		bl	vPortYieldFromISR
 415              	.L18:
 536:../FreeRTOS/Source/tasks.c **** 			}
 537:../FreeRTOS/Source/tasks.c **** 		}
 538:../FreeRTOS/Source/tasks.c **** 	}
 539:../FreeRTOS/Source/tasks.c **** 
 540:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 416              		.loc 1 540 0
 417 01da FB69     		ldr	r3, [r7, #28]
 541:../FreeRTOS/Source/tasks.c **** }
 418              		.loc 1 541 0
 419 01dc 1846     		mov	r0, r3
 420 01de 2037     		adds	r7, r7, #32
 421 01e0 BD46     		mov	sp, r7
 422              		@ sp needed
 423 01e2 80BD     		pop	{r7, pc}
 424              		.cfi_endproc
 425              	.LFE0:
 427              		.section	.text.vTaskDelete,"ax",%progbits
 428              		.align	2
 429              		.global	vTaskDelete
 430              		.thumb
 431              		.thumb_func
 433              	vTaskDelete:
 434              	.LFB1:
 542:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 543:../FreeRTOS/Source/tasks.c **** 
 544:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 545:../FreeRTOS/Source/tasks.c **** 
 546:../FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 547:../FreeRTOS/Source/tasks.c **** 	{
 435              		.loc 1 547 0
 436              		.cfi_startproc
 437              		@ args = 0, pretend = 0, frame = 16
 438              		@ frame_needed = 1, uses_anonymous_args = 0
 439 0000 80B5     		push	{r7, lr}
 440              		.cfi_def_cfa_offset 8
 441              		.cfi_offset 7, -8
 442              		.cfi_offset 14, -4
 443 0002 84B0     		sub	sp, sp, #16
 444              		.cfi_def_cfa_offset 24
 445 0004 00AF     		add	r7, sp, #0
 446              		.cfi_def_cfa_register 7
 447 0006 7860     		str	r0, [r7, #4]
 548:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 549:../FreeRTOS/Source/tasks.c **** 
 550:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 448              		.loc 1 550 0
 449 0008 FFF7FEFF 		bl	vPortEnterCritical
 551:../FreeRTOS/Source/tasks.c **** 		{
 552:../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 553:../FreeRTOS/Source/tasks.c **** 			deleted. */
 554:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 450              		.loc 1 554 0
 451 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 452 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 453 0014 1B68     		ldr	r3, [r3]
 454 0016 7A68     		ldr	r2, [r7, #4]
 455 0018 9A42     		cmp	r2, r3
 456 001a 01D1     		bne	.L21
 555:../FreeRTOS/Source/tasks.c **** 			{
 556:../FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 457              		.loc 1 556 0
 458 001c 0023     		movs	r3, #0
 459 001e 7B60     		str	r3, [r7, #4]
 460              	.L21:
 557:../FreeRTOS/Source/tasks.c **** 			}
 558:../FreeRTOS/Source/tasks.c **** 
 559:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 560:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 461              		.loc 1 560 0
 462 0020 7B68     		ldr	r3, [r7, #4]
 463 0022 002B     		cmp	r3, #0
 464 0024 05D1     		bne	.L22
 465              		.loc 1 560 0 is_stmt 0 discriminator 1
 466 0026 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 467 002a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 468 002e 1B68     		ldr	r3, [r3]
 469 0030 00E0     		b	.L23
 470              	.L22:
 471              		.loc 1 560 0 discriminator 2
 472 0032 7B68     		ldr	r3, [r7, #4]
 473              	.L23:
 474              		.loc 1 560 0 discriminator 3
 475 0034 FB60     		str	r3, [r7, #12]
 561:../FreeRTOS/Source/tasks.c **** 
 562:../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 563:../FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 564:../FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 565:../FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 566:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 476              		.loc 1 566 0 is_stmt 1 discriminator 3
 477 0036 FB68     		ldr	r3, [r7, #12]
 478 0038 0433     		adds	r3, r3, #4
 479 003a 1846     		mov	r0, r3
 480 003c FFF7FEFF 		bl	vListRemove
 567:../FreeRTOS/Source/tasks.c **** 
 568:../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 569:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 481              		.loc 1 569 0 discriminator 3
 482 0040 FB68     		ldr	r3, [r7, #12]
 483 0042 9B6A     		ldr	r3, [r3, #40]
 484 0044 002B     		cmp	r3, #0
 485 0046 04D0     		beq	.L24
 570:../FreeRTOS/Source/tasks.c **** 			{
 571:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 486              		.loc 1 571 0
 487 0048 FB68     		ldr	r3, [r7, #12]
 488 004a 1833     		adds	r3, r3, #24
 489 004c 1846     		mov	r0, r3
 490 004e FFF7FEFF 		bl	vListRemove
 491              	.L24:
 572:../FreeRTOS/Source/tasks.c **** 			}
 573:../FreeRTOS/Source/tasks.c **** 
 574:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 492              		.loc 1 574 0
 493 0052 FB68     		ldr	r3, [r7, #12]
 494 0054 0433     		adds	r3, r3, #4
 495 0056 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 496 005a C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 497 005e 1946     		mov	r1, r3
 498 0060 FFF7FEFF 		bl	vListInsertEnd
 575:../FreeRTOS/Source/tasks.c **** 
 576:../FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 577:../FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 578:../FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 579:../FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 499              		.loc 1 579 0
 500 0064 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 501 0068 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 502 006c 1B68     		ldr	r3, [r3]
 503 006e 5A1C     		adds	r2, r3, #1
 504 0070 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 505 0074 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 506 0078 1A60     		str	r2, [r3]
 580:../FreeRTOS/Source/tasks.c **** 
 581:../FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 582:../FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 583:../FreeRTOS/Source/tasks.c **** 			uxTCBNumber++;
 507              		.loc 1 583 0
 508 007a 40F20003 		movw	r3, #:lower16:uxTCBNumber
 509 007e C0F20003 		movt	r3, #:upper16:uxTCBNumber
 510 0082 1B68     		ldr	r3, [r3]
 511 0084 5A1C     		adds	r2, r3, #1
 512 0086 40F20003 		movw	r3, #:lower16:uxTCBNumber
 513 008a C0F20003 		movt	r3, #:upper16:uxTCBNumber
 514 008e 1A60     		str	r2, [r3]
 584:../FreeRTOS/Source/tasks.c **** 
 585:../FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 586:../FreeRTOS/Source/tasks.c **** 		}
 587:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 515              		.loc 1 587 0
 516 0090 FFF7FEFF 		bl	vPortExitCritical
 588:../FreeRTOS/Source/tasks.c **** 
 589:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 590:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 517              		.loc 1 590 0
 518 0094 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 519 0098 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 520 009c 1B68     		ldr	r3, [r3]
 521 009e 002B     		cmp	r3, #0
 522 00a0 04D0     		beq	.L20
 591:../FreeRTOS/Source/tasks.c **** 		{
 592:../FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 523              		.loc 1 592 0
 524 00a2 7B68     		ldr	r3, [r7, #4]
 525 00a4 002B     		cmp	r3, #0
 526 00a6 01D1     		bne	.L20
 593:../FreeRTOS/Source/tasks.c **** 			{
 594:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 527              		.loc 1 594 0
 528 00a8 FFF7FEFF 		bl	vPortYieldFromISR
 529              	.L20:
 595:../FreeRTOS/Source/tasks.c **** 			}
 596:../FreeRTOS/Source/tasks.c **** 		}
 597:../FreeRTOS/Source/tasks.c **** 	}
 530              		.loc 1 597 0
 531 00ac 1037     		adds	r7, r7, #16
 532 00ae BD46     		mov	sp, r7
 533              		@ sp needed
 534 00b0 80BD     		pop	{r7, pc}
 535              		.cfi_endproc
 536              	.LFE1:
 538 00b2 00BF     		.section	.text.vTaskDelayUntil,"ax",%progbits
 539              		.align	2
 540              		.global	vTaskDelayUntil
 541              		.thumb
 542              		.thumb_func
 544              	vTaskDelayUntil:
 545              	.LFB2:
 598:../FreeRTOS/Source/tasks.c **** 
 599:../FreeRTOS/Source/tasks.c **** #endif
 600:../FreeRTOS/Source/tasks.c **** 
 601:../FreeRTOS/Source/tasks.c **** 
 602:../FreeRTOS/Source/tasks.c **** 
 603:../FreeRTOS/Source/tasks.c **** 
 604:../FreeRTOS/Source/tasks.c **** 
 605:../FreeRTOS/Source/tasks.c **** 
 606:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 607:../FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 608:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 609:../FreeRTOS/Source/tasks.c **** 
 610:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 611:../FreeRTOS/Source/tasks.c **** 
 612:../FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 613:../FreeRTOS/Source/tasks.c **** 	{
 546              		.loc 1 613 0
 547              		.cfi_startproc
 548              		@ args = 0, pretend = 0, frame = 24
 549              		@ frame_needed = 1, uses_anonymous_args = 0
 550 0000 80B5     		push	{r7, lr}
 551              		.cfi_def_cfa_offset 8
 552              		.cfi_offset 7, -8
 553              		.cfi_offset 14, -4
 554 0002 86B0     		sub	sp, sp, #24
 555              		.cfi_def_cfa_offset 32
 556 0004 00AF     		add	r7, sp, #0
 557              		.cfi_def_cfa_register 7
 558 0006 7860     		str	r0, [r7, #4]
 559 0008 3960     		str	r1, [r7]
 614:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 615:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 560              		.loc 1 615 0
 561 000a 0023     		movs	r3, #0
 562 000c 7B61     		str	r3, [r7, #20]
 616:../FreeRTOS/Source/tasks.c **** 
 617:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 563              		.loc 1 617 0
 564 000e 7B68     		ldr	r3, [r7, #4]
 565 0010 002B     		cmp	r3, #0
 566 0012 04D1     		bne	.L27
 567              		.loc 1 617 0 is_stmt 0 discriminator 1
 568              	@ 617 "../FreeRTOS/Source/tasks.c" 1
 569 0014 4FF05000 			mov r0, #80								
 570 0018 80F31188 		msr basepri, r0							
 571              	
 572              	@ 0 "" 2
 573              		.thumb
 574              	.L28:
 575 001c FEE7     		b	.L28
 576              	.L27:
 618:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 577              		.loc 1 618 0 is_stmt 1
 578 001e 3B68     		ldr	r3, [r7]
 579 0020 002B     		cmp	r3, #0
 580 0022 04D1     		bne	.L29
 581              		.loc 1 618 0 is_stmt 0 discriminator 1
 582              	@ 618 "../FreeRTOS/Source/tasks.c" 1
 583 0024 4FF05000 			mov r0, #80								
 584 0028 80F31188 		msr basepri, r0							
 585              	
 586              	@ 0 "" 2
 587              		.thumb
 588              	.L30:
 589 002c FEE7     		b	.L30
 590              	.L29:
 619:../FreeRTOS/Source/tasks.c **** 
 620:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 591              		.loc 1 620 0 is_stmt 1
 592 002e FFF7FEFF 		bl	vTaskSuspendAll
 621:../FreeRTOS/Source/tasks.c **** 		{
 622:../FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 623:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 593              		.loc 1 623 0
 594 0032 7B68     		ldr	r3, [r7, #4]
 595 0034 1A68     		ldr	r2, [r3]
 596 0036 3B68     		ldr	r3, [r7]
 597 0038 1344     		add	r3, r3, r2
 598 003a 3B61     		str	r3, [r7, #16]
 624:../FreeRTOS/Source/tasks.c **** 
 625:../FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 599              		.loc 1 625 0
 600 003c 7B68     		ldr	r3, [r7, #4]
 601 003e 1A68     		ldr	r2, [r3]
 602 0040 40F20003 		movw	r3, #:lower16:xTickCount
 603 0044 C0F20003 		movt	r3, #:upper16:xTickCount
 604 0048 1B68     		ldr	r3, [r3]
 605 004a 9A42     		cmp	r2, r3
 606 004c 0FD9     		bls	.L31
 626:../FreeRTOS/Source/tasks.c **** 			{
 627:../FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 628:../FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 629:../FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 630:../FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 631:../FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 632:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 607              		.loc 1 632 0
 608 004e 7B68     		ldr	r3, [r7, #4]
 609 0050 1A68     		ldr	r2, [r3]
 610 0052 3B69     		ldr	r3, [r7, #16]
 611 0054 9A42     		cmp	r2, r3
 612 0056 19D9     		bls	.L33
 613              		.loc 1 632 0 is_stmt 0 discriminator 1
 614 0058 40F20003 		movw	r3, #:lower16:xTickCount
 615 005c C0F20003 		movt	r3, #:upper16:xTickCount
 616 0060 1B68     		ldr	r3, [r3]
 617 0062 3A69     		ldr	r2, [r7, #16]
 618 0064 9A42     		cmp	r2, r3
 619 0066 11D9     		bls	.L33
 633:../FreeRTOS/Source/tasks.c **** 				{
 634:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 620              		.loc 1 634 0 is_stmt 1
 621 0068 0123     		movs	r3, #1
 622 006a 7B61     		str	r3, [r7, #20]
 623 006c 0EE0     		b	.L33
 624              	.L31:
 635:../FreeRTOS/Source/tasks.c **** 				}
 636:../FreeRTOS/Source/tasks.c **** 			}
 637:../FreeRTOS/Source/tasks.c **** 			else
 638:../FreeRTOS/Source/tasks.c **** 			{
 639:../FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 640:../FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 641:../FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 642:../FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 625              		.loc 1 642 0
 626 006e 7B68     		ldr	r3, [r7, #4]
 627 0070 1A68     		ldr	r2, [r3]
 628 0072 3B69     		ldr	r3, [r7, #16]
 629 0074 9A42     		cmp	r2, r3
 630 0076 07D8     		bhi	.L34
 631              		.loc 1 642 0 is_stmt 0 discriminator 1
 632 0078 40F20003 		movw	r3, #:lower16:xTickCount
 633 007c C0F20003 		movt	r3, #:upper16:xTickCount
 634 0080 1B68     		ldr	r3, [r3]
 635 0082 3A69     		ldr	r2, [r7, #16]
 636 0084 9A42     		cmp	r2, r3
 637 0086 01D9     		bls	.L33
 638              	.L34:
 643:../FreeRTOS/Source/tasks.c **** 				{
 644:../FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 639              		.loc 1 644 0 is_stmt 1
 640 0088 0123     		movs	r3, #1
 641 008a 7B61     		str	r3, [r7, #20]
 642              	.L33:
 645:../FreeRTOS/Source/tasks.c **** 				}
 646:../FreeRTOS/Source/tasks.c **** 			}
 647:../FreeRTOS/Source/tasks.c **** 
 648:../FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 649:../FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 643              		.loc 1 649 0
 644 008c 7B68     		ldr	r3, [r7, #4]
 645 008e 3A69     		ldr	r2, [r7, #16]
 646 0090 1A60     		str	r2, [r3]
 650:../FreeRTOS/Source/tasks.c **** 
 651:../FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 647              		.loc 1 651 0
 648 0092 7B69     		ldr	r3, [r7, #20]
 649 0094 002B     		cmp	r3, #0
 650 0096 0BD0     		beq	.L35
 652:../FreeRTOS/Source/tasks.c **** 			{
 653:../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 654:../FreeRTOS/Source/tasks.c **** 
 655:../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 656:../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 657:../FreeRTOS/Source/tasks.c **** 				both lists. */
 658:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 651              		.loc 1 658 0
 652 0098 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 653 009c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 654 00a0 1B68     		ldr	r3, [r3]
 655 00a2 0433     		adds	r3, r3, #4
 656 00a4 1846     		mov	r0, r3
 657 00a6 FFF7FEFF 		bl	vListRemove
 659:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 658              		.loc 1 659 0
 659 00aa 3869     		ldr	r0, [r7, #16]
 660 00ac FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 661              	.L35:
 660:../FreeRTOS/Source/tasks.c **** 			}
 661:../FreeRTOS/Source/tasks.c **** 		}
 662:../FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 662              		.loc 1 662 0
 663 00b0 FFF7FEFF 		bl	xTaskResumeAll
 664 00b4 F860     		str	r0, [r7, #12]
 663:../FreeRTOS/Source/tasks.c **** 
 664:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 665:../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 666:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 665              		.loc 1 666 0
 666 00b6 FB68     		ldr	r3, [r7, #12]
 667 00b8 002B     		cmp	r3, #0
 668 00ba 01D1     		bne	.L26
 667:../FreeRTOS/Source/tasks.c **** 		{
 668:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 669              		.loc 1 668 0
 670 00bc FFF7FEFF 		bl	vPortYieldFromISR
 671              	.L26:
 669:../FreeRTOS/Source/tasks.c **** 		}
 670:../FreeRTOS/Source/tasks.c **** 	}
 672              		.loc 1 670 0
 673 00c0 1837     		adds	r7, r7, #24
 674 00c2 BD46     		mov	sp, r7
 675              		@ sp needed
 676 00c4 80BD     		pop	{r7, pc}
 677              		.cfi_endproc
 678              	.LFE2:
 680 00c6 00BF     		.section	.text.vTaskDelay,"ax",%progbits
 681              		.align	2
 682              		.global	vTaskDelay
 683              		.thumb
 684              		.thumb_func
 686              	vTaskDelay:
 687              	.LFB3:
 671:../FreeRTOS/Source/tasks.c **** 
 672:../FreeRTOS/Source/tasks.c **** #endif
 673:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 674:../FreeRTOS/Source/tasks.c **** 
 675:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 676:../FreeRTOS/Source/tasks.c **** 
 677:../FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 678:../FreeRTOS/Source/tasks.c **** 	{
 688              		.loc 1 678 0
 689              		.cfi_startproc
 690              		@ args = 0, pretend = 0, frame = 16
 691              		@ frame_needed = 1, uses_anonymous_args = 0
 692 0000 80B5     		push	{r7, lr}
 693              		.cfi_def_cfa_offset 8
 694              		.cfi_offset 7, -8
 695              		.cfi_offset 14, -4
 696 0002 84B0     		sub	sp, sp, #16
 697              		.cfi_def_cfa_offset 24
 698 0004 00AF     		add	r7, sp, #0
 699              		.cfi_def_cfa_register 7
 700 0006 7860     		str	r0, [r7, #4]
 679:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 680:../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 701              		.loc 1 680 0
 702 0008 0023     		movs	r3, #0
 703 000a FB60     		str	r3, [r7, #12]
 681:../FreeRTOS/Source/tasks.c **** 
 682:../FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 683:../FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 704              		.loc 1 683 0
 705 000c 7B68     		ldr	r3, [r7, #4]
 706 000e 002B     		cmp	r3, #0
 707 0010 18D0     		beq	.L38
 684:../FreeRTOS/Source/tasks.c **** 		{
 685:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 708              		.loc 1 685 0
 709 0012 FFF7FEFF 		bl	vTaskSuspendAll
 686:../FreeRTOS/Source/tasks.c **** 			{
 687:../FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 688:../FreeRTOS/Source/tasks.c **** 
 689:../FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 690:../FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 691:../FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 692:../FreeRTOS/Source/tasks.c **** 				is resumed.
 693:../FreeRTOS/Source/tasks.c **** 
 694:../FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 695:../FreeRTOS/Source/tasks.c **** 				executing task. */
 696:../FreeRTOS/Source/tasks.c **** 
 697:../FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 698:../FreeRTOS/Source/tasks.c **** 				not a problem. */
 699:../FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 710              		.loc 1 699 0
 711 0016 40F20003 		movw	r3, #:lower16:xTickCount
 712 001a C0F20003 		movt	r3, #:upper16:xTickCount
 713 001e 1A68     		ldr	r2, [r3]
 714 0020 7B68     		ldr	r3, [r7, #4]
 715 0022 1344     		add	r3, r3, r2
 716 0024 BB60     		str	r3, [r7, #8]
 700:../FreeRTOS/Source/tasks.c **** 
 701:../FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 702:../FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 703:../FreeRTOS/Source/tasks.c **** 				both lists. */
 704:../FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 717              		.loc 1 704 0
 718 0026 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 719 002a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 720 002e 1B68     		ldr	r3, [r3]
 721 0030 0433     		adds	r3, r3, #4
 722 0032 1846     		mov	r0, r3
 723 0034 FFF7FEFF 		bl	vListRemove
 705:../FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 724              		.loc 1 705 0
 725 0038 B868     		ldr	r0, [r7, #8]
 726 003a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 706:../FreeRTOS/Source/tasks.c **** 			}
 707:../FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 727              		.loc 1 707 0
 728 003e FFF7FEFF 		bl	xTaskResumeAll
 729 0042 F860     		str	r0, [r7, #12]
 730              	.L38:
 708:../FreeRTOS/Source/tasks.c **** 		}
 709:../FreeRTOS/Source/tasks.c **** 
 710:../FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 711:../FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 712:../FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 731              		.loc 1 712 0
 732 0044 FB68     		ldr	r3, [r7, #12]
 733 0046 002B     		cmp	r3, #0
 734 0048 01D1     		bne	.L37
 713:../FreeRTOS/Source/tasks.c **** 		{
 714:../FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 735              		.loc 1 714 0
 736 004a FFF7FEFF 		bl	vPortYieldFromISR
 737              	.L37:
 715:../FreeRTOS/Source/tasks.c **** 		}
 716:../FreeRTOS/Source/tasks.c **** 	}
 738              		.loc 1 716 0
 739 004e 1037     		adds	r7, r7, #16
 740 0050 BD46     		mov	sp, r7
 741              		@ sp needed
 742 0052 80BD     		pop	{r7, pc}
 743              		.cfi_endproc
 744              	.LFE3:
 746              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 747              		.align	2
 748              		.global	uxTaskPriorityGet
 749              		.thumb
 750              		.thumb_func
 752              	uxTaskPriorityGet:
 753              	.LFB4:
 717:../FreeRTOS/Source/tasks.c **** 
 718:../FreeRTOS/Source/tasks.c **** #endif
 719:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 720:../FreeRTOS/Source/tasks.c **** 
 721:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 722:../FreeRTOS/Source/tasks.c **** 
 723:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 724:../FreeRTOS/Source/tasks.c **** 	{
 754              		.loc 1 724 0
 755              		.cfi_startproc
 756              		@ args = 0, pretend = 0, frame = 16
 757              		@ frame_needed = 1, uses_anonymous_args = 0
 758 0000 80B5     		push	{r7, lr}
 759              		.cfi_def_cfa_offset 8
 760              		.cfi_offset 7, -8
 761              		.cfi_offset 14, -4
 762 0002 84B0     		sub	sp, sp, #16
 763              		.cfi_def_cfa_offset 24
 764 0004 00AF     		add	r7, sp, #0
 765              		.cfi_def_cfa_register 7
 766 0006 7860     		str	r0, [r7, #4]
 725:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 726:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 727:../FreeRTOS/Source/tasks.c **** 
 728:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 767              		.loc 1 728 0
 768 0008 FFF7FEFF 		bl	vPortEnterCritical
 729:../FreeRTOS/Source/tasks.c **** 		{
 730:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 731:../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 732:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 769              		.loc 1 732 0
 770 000c 7B68     		ldr	r3, [r7, #4]
 771 000e 002B     		cmp	r3, #0
 772 0010 05D1     		bne	.L41
 773              		.loc 1 732 0 is_stmt 0 discriminator 1
 774 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 775 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 776 001a 1B68     		ldr	r3, [r3]
 777 001c 00E0     		b	.L42
 778              	.L41:
 779              		.loc 1 732 0 discriminator 2
 780 001e 7B68     		ldr	r3, [r7, #4]
 781              	.L42:
 782              		.loc 1 732 0 discriminator 3
 783 0020 FB60     		str	r3, [r7, #12]
 733:../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 784              		.loc 1 733 0 is_stmt 1 discriminator 3
 785 0022 FB68     		ldr	r3, [r7, #12]
 786 0024 DB6A     		ldr	r3, [r3, #44]
 787 0026 BB60     		str	r3, [r7, #8]
 734:../FreeRTOS/Source/tasks.c **** 		}
 735:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 788              		.loc 1 735 0 discriminator 3
 789 0028 FFF7FEFF 		bl	vPortExitCritical
 736:../FreeRTOS/Source/tasks.c **** 
 737:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
 790              		.loc 1 737 0 discriminator 3
 791 002c BB68     		ldr	r3, [r7, #8]
 738:../FreeRTOS/Source/tasks.c **** 	}
 792              		.loc 1 738 0 discriminator 3
 793 002e 1846     		mov	r0, r3
 794 0030 1037     		adds	r7, r7, #16
 795 0032 BD46     		mov	sp, r7
 796              		@ sp needed
 797 0034 80BD     		pop	{r7, pc}
 798              		.cfi_endproc
 799              	.LFE4:
 801 0036 00BF     		.section	.text.vTaskPrioritySet,"ax",%progbits
 802              		.align	2
 803              		.global	vTaskPrioritySet
 804              		.thumb
 805              		.thumb_func
 807              	vTaskPrioritySet:
 808              	.LFB5:
 739:../FreeRTOS/Source/tasks.c **** 
 740:../FreeRTOS/Source/tasks.c **** #endif
 741:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 742:../FreeRTOS/Source/tasks.c **** 
 743:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 744:../FreeRTOS/Source/tasks.c **** 
 745:../FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 746:../FreeRTOS/Source/tasks.c **** 	{
 809              		.loc 1 746 0
 810              		.cfi_startproc
 811              		@ args = 0, pretend = 0, frame = 24
 812              		@ frame_needed = 1, uses_anonymous_args = 0
 813 0000 80B5     		push	{r7, lr}
 814              		.cfi_def_cfa_offset 8
 815              		.cfi_offset 7, -8
 816              		.cfi_offset 14, -4
 817 0002 86B0     		sub	sp, sp, #24
 818              		.cfi_def_cfa_offset 32
 819 0004 00AF     		add	r7, sp, #0
 820              		.cfi_def_cfa_register 7
 821 0006 7860     		str	r0, [r7, #4]
 822 0008 3960     		str	r1, [r7]
 747:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 748:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 749:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 823              		.loc 1 749 0
 824 000a 0023     		movs	r3, #0
 825 000c 7B61     		str	r3, [r7, #20]
 750:../FreeRTOS/Source/tasks.c **** 
 751:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 826              		.loc 1 751 0
 827 000e 3B68     		ldr	r3, [r7]
 828 0010 042B     		cmp	r3, #4
 829 0012 04D9     		bls	.L45
 830              		.loc 1 751 0 is_stmt 0 discriminator 1
 831              	@ 751 "../FreeRTOS/Source/tasks.c" 1
 832 0014 4FF05000 			mov r0, #80								
 833 0018 80F31188 		msr basepri, r0							
 834              	
 835              	@ 0 "" 2
 836              		.thumb
 837              	.L46:
 838 001c FEE7     		b	.L46
 839              	.L45:
 752:../FreeRTOS/Source/tasks.c **** 
 753:../FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 754:../FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 840              		.loc 1 754 0 is_stmt 1
 841 001e 3B68     		ldr	r3, [r7]
 842 0020 042B     		cmp	r3, #4
 843 0022 01D9     		bls	.L47
 755:../FreeRTOS/Source/tasks.c **** 		{
 756:../FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 844              		.loc 1 756 0
 845 0024 0423     		movs	r3, #4
 846 0026 3B60     		str	r3, [r7]
 847              	.L47:
 757:../FreeRTOS/Source/tasks.c **** 		}
 758:../FreeRTOS/Source/tasks.c **** 
 759:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 848              		.loc 1 759 0
 849 0028 FFF7FEFF 		bl	vPortEnterCritical
 760:../FreeRTOS/Source/tasks.c **** 		{
 761:../FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 850              		.loc 1 761 0
 851 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 852 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 853 0034 1B68     		ldr	r3, [r3]
 854 0036 7A68     		ldr	r2, [r7, #4]
 855 0038 9A42     		cmp	r2, r3
 856 003a 01D1     		bne	.L48
 762:../FreeRTOS/Source/tasks.c **** 			{
 763:../FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 857              		.loc 1 763 0
 858 003c 0023     		movs	r3, #0
 859 003e 7B60     		str	r3, [r7, #4]
 860              	.L48:
 764:../FreeRTOS/Source/tasks.c **** 			}
 765:../FreeRTOS/Source/tasks.c **** 
 766:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 767:../FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 768:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 861              		.loc 1 768 0
 862 0040 7B68     		ldr	r3, [r7, #4]
 863 0042 002B     		cmp	r3, #0
 864 0044 05D1     		bne	.L49
 865              		.loc 1 768 0 is_stmt 0 discriminator 1
 866 0046 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 867 004a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 868 004e 1B68     		ldr	r3, [r3]
 869 0050 00E0     		b	.L50
 870              	.L49:
 871              		.loc 1 768 0 discriminator 2
 872 0052 7B68     		ldr	r3, [r7, #4]
 873              	.L50:
 874              		.loc 1 768 0 discriminator 3
 875 0054 3B61     		str	r3, [r7, #16]
 769:../FreeRTOS/Source/tasks.c **** 
 770:../FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 771:../FreeRTOS/Source/tasks.c **** 
 772:../FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 773:../FreeRTOS/Source/tasks.c **** 			{
 774:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 876              		.loc 1 774 0 is_stmt 1 discriminator 3
 877 0056 3B69     		ldr	r3, [r7, #16]
 878 0058 1B6C     		ldr	r3, [r3, #64]
 879 005a FB60     		str	r3, [r7, #12]
 775:../FreeRTOS/Source/tasks.c **** 			}
 776:../FreeRTOS/Source/tasks.c **** 			#else
 777:../FreeRTOS/Source/tasks.c **** 			{
 778:../FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 779:../FreeRTOS/Source/tasks.c **** 			}
 780:../FreeRTOS/Source/tasks.c **** 			#endif
 781:../FreeRTOS/Source/tasks.c **** 
 782:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 880              		.loc 1 782 0 discriminator 3
 881 005c FA68     		ldr	r2, [r7, #12]
 882 005e 3B68     		ldr	r3, [r7]
 883 0060 9A42     		cmp	r2, r3
 884 0062 58D0     		beq	.L51
 783:../FreeRTOS/Source/tasks.c **** 			{
 784:../FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 785:../FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 786:../FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 885              		.loc 1 786 0
 886 0064 3A68     		ldr	r2, [r7]
 887 0066 FB68     		ldr	r3, [r7, #12]
 888 0068 9A42     		cmp	r2, r3
 889 006a 05D9     		bls	.L52
 787:../FreeRTOS/Source/tasks.c **** 				{
 788:../FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 890              		.loc 1 788 0
 891 006c 7B68     		ldr	r3, [r7, #4]
 892 006e 002B     		cmp	r3, #0
 893 0070 07D0     		beq	.L54
 789:../FreeRTOS/Source/tasks.c **** 					{
 790:../FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 791:../FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 792:../FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 793:../FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 794:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 894              		.loc 1 794 0
 895 0072 0123     		movs	r3, #1
 896 0074 7B61     		str	r3, [r7, #20]
 897 0076 04E0     		b	.L54
 898              	.L52:
 795:../FreeRTOS/Source/tasks.c **** 					}
 796:../FreeRTOS/Source/tasks.c **** 				}
 797:../FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 899              		.loc 1 797 0
 900 0078 7B68     		ldr	r3, [r7, #4]
 901 007a 002B     		cmp	r3, #0
 902 007c 01D1     		bne	.L54
 798:../FreeRTOS/Source/tasks.c **** 				{
 799:../FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 800:../FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 801:../FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 903              		.loc 1 801 0
 904 007e 0123     		movs	r3, #1
 905 0080 7B61     		str	r3, [r7, #20]
 906              	.L54:
 802:../FreeRTOS/Source/tasks.c **** 				}
 803:../FreeRTOS/Source/tasks.c **** 
 804:../FreeRTOS/Source/tasks.c **** 
 805:../FreeRTOS/Source/tasks.c **** 
 806:../FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 807:../FreeRTOS/Source/tasks.c **** 				{
 808:../FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 809:../FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 810:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 907              		.loc 1 810 0
 908 0082 3B69     		ldr	r3, [r7, #16]
 909 0084 1A6C     		ldr	r2, [r3, #64]
 910 0086 3B69     		ldr	r3, [r7, #16]
 911 0088 DB6A     		ldr	r3, [r3, #44]
 912 008a 9A42     		cmp	r2, r3
 913 008c 02D1     		bne	.L55
 811:../FreeRTOS/Source/tasks.c **** 					{
 812:../FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 914              		.loc 1 812 0
 915 008e 3B69     		ldr	r3, [r7, #16]
 916 0090 3A68     		ldr	r2, [r7]
 917 0092 DA62     		str	r2, [r3, #44]
 918              	.L55:
 813:../FreeRTOS/Source/tasks.c **** 					}
 814:../FreeRTOS/Source/tasks.c **** 
 815:../FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 816:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 919              		.loc 1 816 0
 920 0094 3B69     		ldr	r3, [r7, #16]
 921 0096 3A68     		ldr	r2, [r7]
 922 0098 1A64     		str	r2, [r3, #64]
 817:../FreeRTOS/Source/tasks.c **** 				}
 818:../FreeRTOS/Source/tasks.c **** 				#else
 819:../FreeRTOS/Source/tasks.c **** 				{
 820:../FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 821:../FreeRTOS/Source/tasks.c **** 				}
 822:../FreeRTOS/Source/tasks.c **** 				#endif
 823:../FreeRTOS/Source/tasks.c **** 
 824:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 923              		.loc 1 824 0
 924 009a 3B68     		ldr	r3, [r7]
 925 009c C3F10502 		rsb	r2, r3, #5
 926 00a0 3B69     		ldr	r3, [r7, #16]
 927 00a2 9A61     		str	r2, [r3, #24]
 825:../FreeRTOS/Source/tasks.c **** 
 826:../FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 827:../FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 828:../FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 829:../FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 830:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 928              		.loc 1 830 0
 929 00a4 3B69     		ldr	r3, [r7, #16]
 930 00a6 5969     		ldr	r1, [r3, #20]
 931 00a8 FA68     		ldr	r2, [r7, #12]
 932 00aa 1346     		mov	r3, r2
 933 00ac 9B00     		lsls	r3, r3, #2
 934 00ae 1344     		add	r3, r3, r2
 935 00b0 9B00     		lsls	r3, r3, #2
 936 00b2 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 937 00b6 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 938 00ba 1344     		add	r3, r3, r2
 939 00bc 9942     		cmp	r1, r3
 940 00be 25D1     		bne	.L56
 831:../FreeRTOS/Source/tasks.c **** 				{
 832:../FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 833:../FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 834:../FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 835:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 941              		.loc 1 835 0
 942 00c0 3B69     		ldr	r3, [r7, #16]
 943 00c2 0433     		adds	r3, r3, #4
 944 00c4 1846     		mov	r0, r3
 945 00c6 FFF7FEFF 		bl	vListRemove
 836:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 946              		.loc 1 836 0
 947 00ca 3B69     		ldr	r3, [r7, #16]
 948 00cc DA6A     		ldr	r2, [r3, #44]
 949 00ce 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 950 00d2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 951 00d6 1B68     		ldr	r3, [r3]
 952 00d8 9A42     		cmp	r2, r3
 953 00da 06D9     		bls	.L57
 954              		.loc 1 836 0 is_stmt 0 discriminator 1
 955 00dc 3B69     		ldr	r3, [r7, #16]
 956 00de DA6A     		ldr	r2, [r3, #44]
 957 00e0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 958 00e4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 959 00e8 1A60     		str	r2, [r3]
 960              	.L57:
 961              		.loc 1 836 0 discriminator 2
 962 00ea 3B69     		ldr	r3, [r7, #16]
 963 00ec DA6A     		ldr	r2, [r3, #44]
 964 00ee 1346     		mov	r3, r2
 965 00f0 9B00     		lsls	r3, r3, #2
 966 00f2 1344     		add	r3, r3, r2
 967 00f4 9B00     		lsls	r3, r3, #2
 968 00f6 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 969 00fa C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 970 00fe 1A44     		add	r2, r2, r3
 971 0100 3B69     		ldr	r3, [r7, #16]
 972 0102 0433     		adds	r3, r3, #4
 973 0104 1046     		mov	r0, r2
 974 0106 1946     		mov	r1, r3
 975 0108 FFF7FEFF 		bl	vListInsertEnd
 976              	.L56:
 837:../FreeRTOS/Source/tasks.c **** 				}
 838:../FreeRTOS/Source/tasks.c **** 
 839:../FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 977              		.loc 1 839 0 is_stmt 1
 978 010c 7B69     		ldr	r3, [r7, #20]
 979 010e 012B     		cmp	r3, #1
 980 0110 01D1     		bne	.L51
 840:../FreeRTOS/Source/tasks.c **** 				{
 841:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 981              		.loc 1 841 0
 982 0112 FFF7FEFF 		bl	vPortYieldFromISR
 983              	.L51:
 842:../FreeRTOS/Source/tasks.c **** 				}
 843:../FreeRTOS/Source/tasks.c **** 			}
 844:../FreeRTOS/Source/tasks.c **** 		}
 845:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 984              		.loc 1 845 0
 985 0116 FFF7FEFF 		bl	vPortExitCritical
 846:../FreeRTOS/Source/tasks.c **** 	}
 986              		.loc 1 846 0
 987 011a 1837     		adds	r7, r7, #24
 988 011c BD46     		mov	sp, r7
 989              		@ sp needed
 990 011e 80BD     		pop	{r7, pc}
 991              		.cfi_endproc
 992              	.LFE5:
 994              		.section	.text.vTaskSuspend,"ax",%progbits
 995              		.align	2
 996              		.global	vTaskSuspend
 997              		.thumb
 998              		.thumb_func
 1000              	vTaskSuspend:
 1001              	.LFB6:
 847:../FreeRTOS/Source/tasks.c **** 
 848:../FreeRTOS/Source/tasks.c **** #endif
 849:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 850:../FreeRTOS/Source/tasks.c **** 
 851:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 852:../FreeRTOS/Source/tasks.c **** 
 853:../FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 854:../FreeRTOS/Source/tasks.c **** 	{
 1002              		.loc 1 854 0
 1003              		.cfi_startproc
 1004              		@ args = 0, pretend = 0, frame = 16
 1005              		@ frame_needed = 1, uses_anonymous_args = 0
 1006 0000 80B5     		push	{r7, lr}
 1007              		.cfi_def_cfa_offset 8
 1008              		.cfi_offset 7, -8
 1009              		.cfi_offset 14, -4
 1010 0002 84B0     		sub	sp, sp, #16
 1011              		.cfi_def_cfa_offset 24
 1012 0004 00AF     		add	r7, sp, #0
 1013              		.cfi_def_cfa_register 7
 1014 0006 7860     		str	r0, [r7, #4]
 855:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 856:../FreeRTOS/Source/tasks.c **** 
 857:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 1015              		.loc 1 857 0
 1016 0008 FFF7FEFF 		bl	vPortEnterCritical
 858:../FreeRTOS/Source/tasks.c **** 		{
 859:../FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 860:../FreeRTOS/Source/tasks.c **** 			suspended. */
 861:../FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1017              		.loc 1 861 0
 1018 000c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1019 0010 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1020 0014 1B68     		ldr	r3, [r3]
 1021 0016 7A68     		ldr	r2, [r7, #4]
 1022 0018 9A42     		cmp	r2, r3
 1023 001a 01D1     		bne	.L59
 862:../FreeRTOS/Source/tasks.c **** 			{
 863:../FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 1024              		.loc 1 863 0
 1025 001c 0023     		movs	r3, #0
 1026 001e 7B60     		str	r3, [r7, #4]
 1027              	.L59:
 864:../FreeRTOS/Source/tasks.c **** 			}
 865:../FreeRTOS/Source/tasks.c **** 
 866:../FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 867:../FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1028              		.loc 1 867 0
 1029 0020 7B68     		ldr	r3, [r7, #4]
 1030 0022 002B     		cmp	r3, #0
 1031 0024 05D1     		bne	.L60
 1032              		.loc 1 867 0 is_stmt 0 discriminator 1
 1033 0026 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1034 002a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1035 002e 1B68     		ldr	r3, [r3]
 1036 0030 00E0     		b	.L61
 1037              	.L60:
 1038              		.loc 1 867 0 discriminator 2
 1039 0032 7B68     		ldr	r3, [r7, #4]
 1040              	.L61:
 1041              		.loc 1 867 0 discriminator 3
 1042 0034 FB60     		str	r3, [r7, #12]
 868:../FreeRTOS/Source/tasks.c **** 
 869:../FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 870:../FreeRTOS/Source/tasks.c **** 
 871:../FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 872:../FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1043              		.loc 1 872 0 is_stmt 1 discriminator 3
 1044 0036 FB68     		ldr	r3, [r7, #12]
 1045 0038 0433     		adds	r3, r3, #4
 1046 003a 1846     		mov	r0, r3
 1047 003c FFF7FEFF 		bl	vListRemove
 873:../FreeRTOS/Source/tasks.c **** 
 874:../FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 875:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 1048              		.loc 1 875 0 discriminator 3
 1049 0040 FB68     		ldr	r3, [r7, #12]
 1050 0042 9B6A     		ldr	r3, [r3, #40]
 1051 0044 002B     		cmp	r3, #0
 1052 0046 04D0     		beq	.L62
 876:../FreeRTOS/Source/tasks.c **** 			{
 877:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1053              		.loc 1 877 0
 1054 0048 FB68     		ldr	r3, [r7, #12]
 1055 004a 1833     		adds	r3, r3, #24
 1056 004c 1846     		mov	r0, r3
 1057 004e FFF7FEFF 		bl	vListRemove
 1058              	.L62:
 878:../FreeRTOS/Source/tasks.c **** 			}
 879:../FreeRTOS/Source/tasks.c **** 
 880:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1059              		.loc 1 880 0
 1060 0052 FB68     		ldr	r3, [r7, #12]
 1061 0054 0433     		adds	r3, r3, #4
 1062 0056 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 1063 005a C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 1064 005e 1946     		mov	r1, r3
 1065 0060 FFF7FEFF 		bl	vListInsertEnd
 881:../FreeRTOS/Source/tasks.c **** 		}
 882:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1066              		.loc 1 882 0
 1067 0064 FFF7FEFF 		bl	vPortExitCritical
 883:../FreeRTOS/Source/tasks.c **** 
 884:../FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1068              		.loc 1 884 0
 1069 0068 7B68     		ldr	r3, [r7, #4]
 1070 006a 002B     		cmp	r3, #0
 1071 006c 1ED1     		bne	.L58
 885:../FreeRTOS/Source/tasks.c **** 		{
 886:../FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1072              		.loc 1 886 0
 1073 006e 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1074 0072 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1075 0076 1B68     		ldr	r3, [r3]
 1076 0078 002B     		cmp	r3, #0
 1077 007a 02D0     		beq	.L64
 887:../FreeRTOS/Source/tasks.c **** 			{
 888:../FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 889:../FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1078              		.loc 1 889 0
 1079 007c FFF7FEFF 		bl	vPortYieldFromISR
 1080 0080 14E0     		b	.L58
 1081              	.L64:
 890:../FreeRTOS/Source/tasks.c **** 			}
 891:../FreeRTOS/Source/tasks.c **** 			else
 892:../FreeRTOS/Source/tasks.c **** 			{
 893:../FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 894:../FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 895:../FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 896:../FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1082              		.loc 1 896 0
 1083 0082 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1084 0086 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1085 008a 1A68     		ldr	r2, [r3]
 1086 008c 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1087 0090 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1088 0094 1B68     		ldr	r3, [r3]
 1089 0096 9A42     		cmp	r2, r3
 1090 0098 06D1     		bne	.L65
 897:../FreeRTOS/Source/tasks.c **** 				{
 898:../FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 899:../FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 900:../FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 901:../FreeRTOS/Source/tasks.c **** 					is. */
 902:../FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 1091              		.loc 1 902 0
 1092 009a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1093 009e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1094 00a2 0022     		movs	r2, #0
 1095 00a4 1A60     		str	r2, [r3]
 1096 00a6 01E0     		b	.L58
 1097              	.L65:
 903:../FreeRTOS/Source/tasks.c **** 				}
 904:../FreeRTOS/Source/tasks.c **** 				else
 905:../FreeRTOS/Source/tasks.c **** 				{
 906:../FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 1098              		.loc 1 906 0
 1099 00a8 FFF7FEFF 		bl	vTaskSwitchContext
 1100              	.L58:
 907:../FreeRTOS/Source/tasks.c **** 				}
 908:../FreeRTOS/Source/tasks.c **** 			}
 909:../FreeRTOS/Source/tasks.c **** 		}
 910:../FreeRTOS/Source/tasks.c **** 	}
 1101              		.loc 1 910 0
 1102 00ac 1037     		adds	r7, r7, #16
 1103 00ae BD46     		mov	sp, r7
 1104              		@ sp needed
 1105 00b0 80BD     		pop	{r7, pc}
 1106              		.cfi_endproc
 1107              	.LFE6:
 1109 00b2 00BF     		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1110              		.align	2
 1111              		.global	xTaskIsTaskSuspended
 1112              		.thumb
 1113              		.thumb_func
 1115              	xTaskIsTaskSuspended:
 1116              	.LFB7:
 911:../FreeRTOS/Source/tasks.c **** 
 912:../FreeRTOS/Source/tasks.c **** #endif
 913:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 914:../FreeRTOS/Source/tasks.c **** 
 915:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 916:../FreeRTOS/Source/tasks.c **** 
 917:../FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 918:../FreeRTOS/Source/tasks.c **** 	{
 1117              		.loc 1 918 0
 1118              		.cfi_startproc
 1119              		@ args = 0, pretend = 0, frame = 16
 1120              		@ frame_needed = 1, uses_anonymous_args = 0
 1121              		@ link register save eliminated.
 1122 0000 80B4     		push	{r7}
 1123              		.cfi_def_cfa_offset 4
 1124              		.cfi_offset 7, -4
 1125 0002 85B0     		sub	sp, sp, #20
 1126              		.cfi_def_cfa_offset 24
 1127 0004 00AF     		add	r7, sp, #0
 1128              		.cfi_def_cfa_register 7
 1129 0006 7860     		str	r0, [r7, #4]
 919:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1130              		.loc 1 919 0
 1131 0008 0023     		movs	r3, #0
 1132 000a FB60     		str	r3, [r7, #12]
 920:../FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1133              		.loc 1 920 0
 1134 000c 7B68     		ldr	r3, [r7, #4]
 1135 000e BB60     		str	r3, [r7, #8]
 921:../FreeRTOS/Source/tasks.c **** 
 922:../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 923:../FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 1136              		.loc 1 923 0
 1137 0010 7B68     		ldr	r3, [r7, #4]
 1138 0012 002B     		cmp	r3, #0
 1139 0014 04D1     		bne	.L67
 1140              		.loc 1 923 0 is_stmt 0 discriminator 1
 1141              	@ 923 "../FreeRTOS/Source/tasks.c" 1
 1142 0016 4FF05000 			mov r0, #80								
 1143 001a 80F31188 		msr basepri, r0							
 1144              	
 1145              	@ 0 "" 2
 1146              		.thumb
 1147              	.L68:
 1148 001e FEE7     		b	.L68
 1149              	.L67:
 924:../FreeRTOS/Source/tasks.c **** 
 925:../FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 926:../FreeRTOS/Source/tasks.c **** 		suspended list? */
 927:../FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1150              		.loc 1 927 0 is_stmt 1
 1151 0020 BB68     		ldr	r3, [r7, #8]
 1152 0022 5A69     		ldr	r2, [r3, #20]
 1153 0024 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1154 0028 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1155 002c 9A42     		cmp	r2, r3
 1156 002e 0DD1     		bne	.L69
 928:../FreeRTOS/Source/tasks.c **** 		{
 929:../FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 930:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1157              		.loc 1 930 0
 1158 0030 BB68     		ldr	r3, [r7, #8]
 1159 0032 9A6A     		ldr	r2, [r3, #40]
 1160 0034 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1161 0038 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1162 003c 9A42     		cmp	r2, r3
 1163 003e 05D0     		beq	.L69
 931:../FreeRTOS/Source/tasks.c **** 			{
 932:../FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 933:../FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 934:../FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 935:../FreeRTOS/Source/tasks.c **** 				specified. */
 936:../FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1164              		.loc 1 936 0
 1165 0040 BB68     		ldr	r3, [r7, #8]
 1166 0042 9B6A     		ldr	r3, [r3, #40]
 1167 0044 002B     		cmp	r3, #0
 1168 0046 01D1     		bne	.L69
 937:../FreeRTOS/Source/tasks.c **** 				{
 938:../FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1169              		.loc 1 938 0
 1170 0048 0123     		movs	r3, #1
 1171 004a FB60     		str	r3, [r7, #12]
 1172              	.L69:
 939:../FreeRTOS/Source/tasks.c **** 				}
 940:../FreeRTOS/Source/tasks.c **** 			}
 941:../FreeRTOS/Source/tasks.c **** 		}
 942:../FreeRTOS/Source/tasks.c **** 
 943:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 1173              		.loc 1 943 0
 1174 004c FB68     		ldr	r3, [r7, #12]
 944:../FreeRTOS/Source/tasks.c **** 	}
 1175              		.loc 1 944 0
 1176 004e 1846     		mov	r0, r3
 1177 0050 1437     		adds	r7, r7, #20
 1178 0052 BD46     		mov	sp, r7
 1179              		@ sp needed
 1180 0054 5DF8047B 		ldr	r7, [sp], #4
 1181 0058 7047     		bx	lr
 1182              		.cfi_endproc
 1183              	.LFE7:
 1185 005a 00BF     		.section	.text.vTaskResume,"ax",%progbits
 1186              		.align	2
 1187              		.global	vTaskResume
 1188              		.thumb
 1189              		.thumb_func
 1191              	vTaskResume:
 1192              	.LFB8:
 945:../FreeRTOS/Source/tasks.c **** 
 946:../FreeRTOS/Source/tasks.c **** #endif
 947:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 948:../FreeRTOS/Source/tasks.c **** 
 949:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 950:../FreeRTOS/Source/tasks.c **** 
 951:../FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 952:../FreeRTOS/Source/tasks.c **** 	{
 1193              		.loc 1 952 0
 1194              		.cfi_startproc
 1195              		@ args = 0, pretend = 0, frame = 16
 1196              		@ frame_needed = 1, uses_anonymous_args = 0
 1197 0000 80B5     		push	{r7, lr}
 1198              		.cfi_def_cfa_offset 8
 1199              		.cfi_offset 7, -8
 1200              		.cfi_offset 14, -4
 1201 0002 84B0     		sub	sp, sp, #16
 1202              		.cfi_def_cfa_offset 24
 1203 0004 00AF     		add	r7, sp, #0
 1204              		.cfi_def_cfa_register 7
 1205 0006 7860     		str	r0, [r7, #4]
 953:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 954:../FreeRTOS/Source/tasks.c **** 
 955:../FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
 956:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
 1206              		.loc 1 956 0
 1207 0008 7B68     		ldr	r3, [r7, #4]
 1208 000a 002B     		cmp	r3, #0
 1209 000c 04D1     		bne	.L72
 1210              		.loc 1 956 0 is_stmt 0 discriminator 1
 1211              	@ 956 "../FreeRTOS/Source/tasks.c" 1
 1212 000e 4FF05000 			mov r0, #80								
 1213 0012 80F31188 		msr basepri, r0							
 1214              	
 1215              	@ 0 "" 2
 1216              		.thumb
 1217              	.L73:
 1218 0016 FEE7     		b	.L73
 1219              	.L72:
 957:../FreeRTOS/Source/tasks.c **** 
 958:../FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 959:../FreeRTOS/Source/tasks.c **** 		it in the ready list. */
 960:../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1220              		.loc 1 960 0 is_stmt 1
 1221 0018 7B68     		ldr	r3, [r7, #4]
 1222 001a FB60     		str	r3, [r7, #12]
 961:../FreeRTOS/Source/tasks.c **** 
 962:../FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 963:../FreeRTOS/Source/tasks.c **** 		currently executing task. */
 964:../FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1223              		.loc 1 964 0
 1224 001c FB68     		ldr	r3, [r7, #12]
 1225 001e 002B     		cmp	r3, #0
 1226 0020 43D0     		beq	.L71
 1227              		.loc 1 964 0 is_stmt 0 discriminator 1
 1228 0022 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1229 0026 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1230 002a 1B68     		ldr	r3, [r3]
 1231 002c FA68     		ldr	r2, [r7, #12]
 1232 002e 9A42     		cmp	r2, r3
 1233 0030 3BD0     		beq	.L71
 965:../FreeRTOS/Source/tasks.c **** 		{
 966:../FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1234              		.loc 1 966 0 is_stmt 1
 1235 0032 FFF7FEFF 		bl	vPortEnterCritical
 967:../FreeRTOS/Source/tasks.c **** 			{
 968:../FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1236              		.loc 1 968 0
 1237 0036 F868     		ldr	r0, [r7, #12]
 1238 0038 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1239 003c 0346     		mov	r3, r0
 1240 003e 012B     		cmp	r3, #1
 1241 0040 31D1     		bne	.L75
 969:../FreeRTOS/Source/tasks.c **** 				{
 970:../FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 971:../FreeRTOS/Source/tasks.c **** 
 972:../FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 973:../FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
 974:../FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1242              		.loc 1 974 0
 1243 0042 FB68     		ldr	r3, [r7, #12]
 1244 0044 0433     		adds	r3, r3, #4
 1245 0046 1846     		mov	r0, r3
 1246 0048 FFF7FEFF 		bl	vListRemove
 975:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1247              		.loc 1 975 0
 1248 004c FB68     		ldr	r3, [r7, #12]
 1249 004e DA6A     		ldr	r2, [r3, #44]
 1250 0050 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1251 0054 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1252 0058 1B68     		ldr	r3, [r3]
 1253 005a 9A42     		cmp	r2, r3
 1254 005c 06D9     		bls	.L76
 1255              		.loc 1 975 0 is_stmt 0 discriminator 1
 1256 005e FB68     		ldr	r3, [r7, #12]
 1257 0060 DA6A     		ldr	r2, [r3, #44]
 1258 0062 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1259 0066 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1260 006a 1A60     		str	r2, [r3]
 1261              	.L76:
 1262              		.loc 1 975 0 discriminator 2
 1263 006c FB68     		ldr	r3, [r7, #12]
 1264 006e DA6A     		ldr	r2, [r3, #44]
 1265 0070 1346     		mov	r3, r2
 1266 0072 9B00     		lsls	r3, r3, #2
 1267 0074 1344     		add	r3, r3, r2
 1268 0076 9B00     		lsls	r3, r3, #2
 1269 0078 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1270 007c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1271 0080 1A44     		add	r2, r2, r3
 1272 0082 FB68     		ldr	r3, [r7, #12]
 1273 0084 0433     		adds	r3, r3, #4
 1274 0086 1046     		mov	r0, r2
 1275 0088 1946     		mov	r1, r3
 1276 008a FFF7FEFF 		bl	vListInsertEnd
 976:../FreeRTOS/Source/tasks.c **** 
 977:../FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 978:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1277              		.loc 1 978 0 is_stmt 1 discriminator 2
 1278 008e FB68     		ldr	r3, [r7, #12]
 1279 0090 DA6A     		ldr	r2, [r3, #44]
 1280 0092 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1281 0096 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1282 009a 1B68     		ldr	r3, [r3]
 1283 009c DB6A     		ldr	r3, [r3, #44]
 1284 009e 9A42     		cmp	r2, r3
 1285 00a0 01D3     		bcc	.L75
 979:../FreeRTOS/Source/tasks.c **** 					{
 980:../FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 981:../FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 982:../FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1286              		.loc 1 982 0
 1287 00a2 FFF7FEFF 		bl	vPortYieldFromISR
 1288              	.L75:
 983:../FreeRTOS/Source/tasks.c **** 					}
 984:../FreeRTOS/Source/tasks.c **** 				}
 985:../FreeRTOS/Source/tasks.c **** 			}
 986:../FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1289              		.loc 1 986 0
 1290 00a6 FFF7FEFF 		bl	vPortExitCritical
 1291              	.L71:
 987:../FreeRTOS/Source/tasks.c **** 		}
 988:../FreeRTOS/Source/tasks.c **** 	}
 1292              		.loc 1 988 0
 1293 00aa 1037     		adds	r7, r7, #16
 1294 00ac BD46     		mov	sp, r7
 1295              		@ sp needed
 1296 00ae 80BD     		pop	{r7, pc}
 1297              		.cfi_endproc
 1298              	.LFE8:
 1300              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1301              		.align	2
 1302              		.global	xTaskResumeFromISR
 1303              		.thumb
 1304              		.thumb_func
 1306              	xTaskResumeFromISR:
 1307              	.LFB9:
 989:../FreeRTOS/Source/tasks.c **** 
 990:../FreeRTOS/Source/tasks.c **** #endif
 991:../FreeRTOS/Source/tasks.c **** 
 992:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 993:../FreeRTOS/Source/tasks.c **** 
 994:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 995:../FreeRTOS/Source/tasks.c **** 
 996:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 997:../FreeRTOS/Source/tasks.c **** 	{
 1308              		.loc 1 997 0
 1309              		.cfi_startproc
 1310              		@ args = 0, pretend = 0, frame = 24
 1311              		@ frame_needed = 1, uses_anonymous_args = 0
 1312 0000 80B5     		push	{r7, lr}
 1313              		.cfi_def_cfa_offset 8
 1314              		.cfi_offset 7, -8
 1315              		.cfi_offset 14, -4
 1316 0002 86B0     		sub	sp, sp, #24
 1317              		.cfi_def_cfa_offset 32
 1318 0004 00AF     		add	r7, sp, #0
 1319              		.cfi_def_cfa_register 7
 1320 0006 7860     		str	r0, [r7, #4]
 998:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1321              		.loc 1 998 0
 1322 0008 0023     		movs	r3, #0
 1323 000a 7B61     		str	r3, [r7, #20]
 999:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1000:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:../FreeRTOS/Source/tasks.c **** 
1002:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
 1324              		.loc 1 1002 0
 1325 000c 7B68     		ldr	r3, [r7, #4]
 1326 000e 002B     		cmp	r3, #0
 1327 0010 04D1     		bne	.L78
 1328              		.loc 1 1002 0 is_stmt 0 discriminator 1
 1329              	@ 1002 "../FreeRTOS/Source/tasks.c" 1
 1330 0012 4FF05000 			mov r0, #80								
 1331 0016 80F31188 		msr basepri, r0							
 1332              	
 1333              	@ 0 "" 2
 1334              		.thumb
 1335              	.L79:
 1336 001a FEE7     		b	.L79
 1337              	.L78:
1003:../FreeRTOS/Source/tasks.c **** 
1004:../FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1338              		.loc 1 1004 0 is_stmt 1
 1339 001c 7B68     		ldr	r3, [r7, #4]
 1340 001e 3B61     		str	r3, [r7, #16]
1005:../FreeRTOS/Source/tasks.c **** 
1006:../FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1341              		.loc 1 1006 0
 1342 0020 0023     		movs	r3, #0
 1343 0022 FB60     		str	r3, [r7, #12]
 1344              	@ 1006 "../FreeRTOS/Source/tasks.c" 1
 1345 0024 4FF05000 			mov r0, #80								
 1346 0028 80F31188 		msr basepri, r0							
 1347              	
 1348              	@ 0 "" 2
1007:../FreeRTOS/Source/tasks.c **** 		{
1008:../FreeRTOS/Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1349              		.loc 1 1008 0
 1350              		.thumb
 1351 002c 3869     		ldr	r0, [r7, #16]
 1352 002e FFF7FEFF 		bl	xTaskIsTaskSuspended
 1353 0032 0346     		mov	r3, r0
 1354 0034 012B     		cmp	r3, #1
 1355 0036 44D1     		bne	.L80
1009:../FreeRTOS/Source/tasks.c **** 			{
1010:../FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:../FreeRTOS/Source/tasks.c **** 
1012:../FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1356              		.loc 1 1012 0
 1357 0038 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1358 003c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1359 0040 1B68     		ldr	r3, [r3]
 1360 0042 002B     		cmp	r3, #0
 1361 0044 34D1     		bne	.L81
1013:../FreeRTOS/Source/tasks.c **** 				{
1014:../FreeRTOS/Source/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1362              		.loc 1 1014 0
 1363 0046 3B69     		ldr	r3, [r7, #16]
 1364 0048 DA6A     		ldr	r2, [r3, #44]
 1365 004a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1366 004e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1367 0052 1B68     		ldr	r3, [r3]
 1368 0054 DB6A     		ldr	r3, [r3, #44]
 1369 0056 9A42     		cmp	r2, r3
 1370 0058 34BF     		ite	cc
 1371 005a 0023     		movcc	r3, #0
 1372 005c 0123     		movcs	r3, #1
 1373 005e DBB2     		uxtb	r3, r3
 1374 0060 7B61     		str	r3, [r7, #20]
1015:../FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1375              		.loc 1 1015 0
 1376 0062 3B69     		ldr	r3, [r7, #16]
 1377 0064 0433     		adds	r3, r3, #4
 1378 0066 1846     		mov	r0, r3
 1379 0068 FFF7FEFF 		bl	vListRemove
1016:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1380              		.loc 1 1016 0
 1381 006c 3B69     		ldr	r3, [r7, #16]
 1382 006e DA6A     		ldr	r2, [r3, #44]
 1383 0070 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1384 0074 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1385 0078 1B68     		ldr	r3, [r3]
 1386 007a 9A42     		cmp	r2, r3
 1387 007c 06D9     		bls	.L82
 1388              		.loc 1 1016 0 is_stmt 0 discriminator 1
 1389 007e 3B69     		ldr	r3, [r7, #16]
 1390 0080 DA6A     		ldr	r2, [r3, #44]
 1391 0082 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1392 0086 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1393 008a 1A60     		str	r2, [r3]
 1394              	.L82:
 1395              		.loc 1 1016 0 discriminator 2
 1396 008c 3B69     		ldr	r3, [r7, #16]
 1397 008e DA6A     		ldr	r2, [r3, #44]
 1398 0090 1346     		mov	r3, r2
 1399 0092 9B00     		lsls	r3, r3, #2
 1400 0094 1344     		add	r3, r3, r2
 1401 0096 9B00     		lsls	r3, r3, #2
 1402 0098 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1403 009c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1404 00a0 1A44     		add	r2, r2, r3
 1405 00a2 3B69     		ldr	r3, [r7, #16]
 1406 00a4 0433     		adds	r3, r3, #4
 1407 00a6 1046     		mov	r0, r2
 1408 00a8 1946     		mov	r1, r3
 1409 00aa FFF7FEFF 		bl	vListInsertEnd
 1410 00ae 08E0     		b	.L80
 1411              	.L81:
1017:../FreeRTOS/Source/tasks.c **** 				}
1018:../FreeRTOS/Source/tasks.c **** 				else
1019:../FreeRTOS/Source/tasks.c **** 				{
1020:../FreeRTOS/Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1021:../FreeRTOS/Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1022:../FreeRTOS/Source/tasks.c **** 					yield will be performed if necessary. */
1023:../FreeRTOS/Source/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1412              		.loc 1 1023 0 is_stmt 1
 1413 00b0 3B69     		ldr	r3, [r7, #16]
 1414 00b2 1833     		adds	r3, r3, #24
 1415 00b4 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1416 00b8 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1417 00bc 1946     		mov	r1, r3
 1418 00be FFF7FEFF 		bl	vListInsertEnd
 1419              	.L80:
1024:../FreeRTOS/Source/tasks.c **** 				}
1025:../FreeRTOS/Source/tasks.c **** 			}
1026:../FreeRTOS/Source/tasks.c **** 		}
1027:../FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1420              		.loc 1 1027 0
 1421              	@ 1027 "../FreeRTOS/Source/tasks.c" 1
 1422 00c2 4FF00000 			mov r0, #0					
 1423 00c6 80F31188 		msr basepri, r0				
 1424              	
 1425              	@ 0 "" 2
1028:../FreeRTOS/Source/tasks.c **** 
1029:../FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1426              		.loc 1 1029 0
 1427              		.thumb
 1428 00ca 7B69     		ldr	r3, [r7, #20]
1030:../FreeRTOS/Source/tasks.c **** 	}
 1429              		.loc 1 1030 0
 1430 00cc 1846     		mov	r0, r3
 1431 00ce 1837     		adds	r7, r7, #24
 1432 00d0 BD46     		mov	sp, r7
 1433              		@ sp needed
 1434 00d2 80BD     		pop	{r7, pc}
 1435              		.cfi_endproc
 1436              	.LFE9:
 1438              		.section	.rodata
 1439              		.align	2
 1440              	.LC0:
 1441 0000 49444C45 		.ascii	"IDLE\000"
 1441      00
 1442 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1443              		.align	2
 1444              		.global	vTaskStartScheduler
 1445              		.thumb
 1446              		.thumb_func
 1448              	vTaskStartScheduler:
 1449              	.LFB10:
1031:../FreeRTOS/Source/tasks.c **** 
1032:../FreeRTOS/Source/tasks.c **** #endif
1033:../FreeRTOS/Source/tasks.c **** 
1034:../FreeRTOS/Source/tasks.c **** 
1035:../FreeRTOS/Source/tasks.c **** 
1036:../FreeRTOS/Source/tasks.c **** 
1037:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1038:../FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1039:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1040:../FreeRTOS/Source/tasks.c **** 
1041:../FreeRTOS/Source/tasks.c **** 
1042:../FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1043:../FreeRTOS/Source/tasks.c **** {
 1450              		.loc 1 1043 0
 1451              		.cfi_startproc
 1452              		@ args = 0, pretend = 0, frame = 8
 1453              		@ frame_needed = 1, uses_anonymous_args = 0
 1454 0000 80B5     		push	{r7, lr}
 1455              		.cfi_def_cfa_offset 8
 1456              		.cfi_offset 7, -8
 1457              		.cfi_offset 14, -4
 1458 0002 86B0     		sub	sp, sp, #24
 1459              		.cfi_def_cfa_offset 32
 1460 0004 04AF     		add	r7, sp, #16
 1461              		.cfi_def_cfa 7, 16
1044:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1045:../FreeRTOS/Source/tasks.c **** 
1046:../FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1047:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:../FreeRTOS/Source/tasks.c **** 	{
1049:../FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:../FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1051:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1052:../FreeRTOS/Source/tasks.c **** 	}
1053:../FreeRTOS/Source/tasks.c **** 	#else
1054:../FreeRTOS/Source/tasks.c **** 	{
1055:../FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1056:../FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1462              		.loc 1 1056 0
 1463 0006 0023     		movs	r3, #0
 1464 0008 0093     		str	r3, [sp]
 1465 000a 0023     		movs	r3, #0
 1466 000c 0193     		str	r3, [sp, #4]
 1467 000e 0023     		movs	r3, #0
 1468 0010 0293     		str	r3, [sp, #8]
 1469 0012 0023     		movs	r3, #0
 1470 0014 0393     		str	r3, [sp, #12]
 1471 0016 40F20000 		movw	r0, #:lower16:prvIdleTask
 1472 001a C0F20000 		movt	r0, #:upper16:prvIdleTask
 1473 001e 40F20001 		movw	r1, #:lower16:.LC0
 1474 0022 C0F20001 		movt	r1, #:upper16:.LC0
 1475 0026 7822     		movs	r2, #120
 1476 0028 0023     		movs	r3, #0
 1477 002a FFF7FEFF 		bl	xTaskGenericCreate
 1478 002e 7860     		str	r0, [r7, #4]
1057:../FreeRTOS/Source/tasks.c **** 	}
1058:../FreeRTOS/Source/tasks.c **** 	#endif
1059:../FreeRTOS/Source/tasks.c **** 
1060:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1061:../FreeRTOS/Source/tasks.c **** 	{
1062:../FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
 1479              		.loc 1 1062 0
 1480 0030 7B68     		ldr	r3, [r7, #4]
 1481 0032 012B     		cmp	r3, #1
 1482 0034 02D1     		bne	.L85
1063:../FreeRTOS/Source/tasks.c **** 		{
1064:../FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1483              		.loc 1 1064 0
 1484 0036 FFF7FEFF 		bl	xTimerCreateTimerTask
 1485 003a 7860     		str	r0, [r7, #4]
 1486              	.L85:
1065:../FreeRTOS/Source/tasks.c **** 		}
1066:../FreeRTOS/Source/tasks.c **** 	}
1067:../FreeRTOS/Source/tasks.c **** 	#endif
1068:../FreeRTOS/Source/tasks.c **** 
1069:../FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1487              		.loc 1 1069 0
 1488 003c 7B68     		ldr	r3, [r7, #4]
 1489 003e 012B     		cmp	r3, #1
 1490 0040 11D1     		bne	.L86
1070:../FreeRTOS/Source/tasks.c **** 	{
1071:../FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1072:../FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1073:../FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1074:../FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1075:../FreeRTOS/Source/tasks.c **** 		starts to run.
1076:../FreeRTOS/Source/tasks.c **** 
1077:../FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:../FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:../FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1491              		.loc 1 1079 0
 1492              	@ 1079 "../FreeRTOS/Source/tasks.c" 1
 1493 0042 4FF05000 			mov r0, #80								
 1494 0046 80F31188 		msr basepri, r0							
 1495              	
 1496              	@ 0 "" 2
1080:../FreeRTOS/Source/tasks.c **** 
1081:../FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1497              		.loc 1 1081 0
 1498              		.thumb
 1499 004a 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1500 004e C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1501 0052 0122     		movs	r2, #1
 1502 0054 1A60     		str	r2, [r3]
1082:../FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1503              		.loc 1 1082 0
 1504 0056 40F20003 		movw	r3, #:lower16:xTickCount
 1505 005a C0F20003 		movt	r3, #:upper16:xTickCount
 1506 005e 0022     		movs	r2, #0
 1507 0060 1A60     		str	r2, [r3]
1083:../FreeRTOS/Source/tasks.c **** 
1084:../FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:../FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1086:../FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1087:../FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1088:../FreeRTOS/Source/tasks.c **** 		
1089:../FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1090:../FreeRTOS/Source/tasks.c **** 		portable interface. */
1091:../FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1508              		.loc 1 1091 0
 1509 0062 FFF7FEFF 		bl	xPortStartScheduler
 1510              	.L86:
1092:../FreeRTOS/Source/tasks.c **** 		{
1093:../FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1094:../FreeRTOS/Source/tasks.c **** 			function will not return. */
1095:../FreeRTOS/Source/tasks.c **** 		}
1096:../FreeRTOS/Source/tasks.c **** 		else
1097:../FreeRTOS/Source/tasks.c **** 		{
1098:../FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:../FreeRTOS/Source/tasks.c **** 		}
1100:../FreeRTOS/Source/tasks.c **** 	}
1101:../FreeRTOS/Source/tasks.c **** 
1102:../FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1103:../FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
 1511              		.loc 1 1103 0
 1512 0066 7B68     		ldr	r3, [r7, #4]
 1513 0068 002B     		cmp	r3, #0
 1514 006a 04D1     		bne	.L84
 1515              		.loc 1 1103 0 is_stmt 0 discriminator 1
 1516              	@ 1103 "../FreeRTOS/Source/tasks.c" 1
 1517 006c 4FF05000 			mov r0, #80								
 1518 0070 80F31188 		msr basepri, r0							
 1519              	
 1520              	@ 0 "" 2
 1521              		.thumb
 1522              	.L88:
 1523 0074 FEE7     		b	.L88
 1524              	.L84:
1104:../FreeRTOS/Source/tasks.c **** }
 1525              		.loc 1 1104 0 is_stmt 1
 1526 0076 0837     		adds	r7, r7, #8
 1527 0078 BD46     		mov	sp, r7
 1528              		@ sp needed
 1529 007a 80BD     		pop	{r7, pc}
 1530              		.cfi_endproc
 1531              	.LFE10:
 1533              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1534              		.align	2
 1535              		.global	vTaskEndScheduler
 1536              		.thumb
 1537              		.thumb_func
 1539              	vTaskEndScheduler:
 1540              	.LFB11:
1105:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1106:../FreeRTOS/Source/tasks.c **** 
1107:../FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1108:../FreeRTOS/Source/tasks.c **** {
 1541              		.loc 1 1108 0
 1542              		.cfi_startproc
 1543              		@ args = 0, pretend = 0, frame = 0
 1544              		@ frame_needed = 1, uses_anonymous_args = 0
 1545 0000 80B5     		push	{r7, lr}
 1546              		.cfi_def_cfa_offset 8
 1547              		.cfi_offset 7, -8
 1548              		.cfi_offset 14, -4
 1549 0002 00AF     		add	r7, sp, #0
 1550              		.cfi_def_cfa_register 7
1109:../FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1110:../FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1111:../FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1112:../FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1551              		.loc 1 1112 0
 1552              	@ 1112 "../FreeRTOS/Source/tasks.c" 1
 1553 0004 4FF05000 			mov r0, #80								
 1554 0008 80F31188 		msr basepri, r0							
 1555              	
 1556              	@ 0 "" 2
1113:../FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1557              		.loc 1 1113 0
 1558              		.thumb
 1559 000c 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1560 0010 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1561 0014 0022     		movs	r2, #0
 1562 0016 1A60     		str	r2, [r3]
1114:../FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1563              		.loc 1 1114 0
 1564 0018 FFF7FEFF 		bl	vPortEndScheduler
1115:../FreeRTOS/Source/tasks.c **** }
 1565              		.loc 1 1115 0
 1566 001c 80BD     		pop	{r7, pc}
 1567              		.cfi_endproc
 1568              	.LFE11:
 1570 001e 00BF     		.section	.text.vTaskSuspendAll,"ax",%progbits
 1571              		.align	2
 1572              		.global	vTaskSuspendAll
 1573              		.thumb
 1574              		.thumb_func
 1576              	vTaskSuspendAll:
 1577              	.LFB12:
1116:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1117:../FreeRTOS/Source/tasks.c **** 
1118:../FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1119:../FreeRTOS/Source/tasks.c **** {
 1578              		.loc 1 1119 0
 1579              		.cfi_startproc
 1580              		@ args = 0, pretend = 0, frame = 0
 1581              		@ frame_needed = 1, uses_anonymous_args = 0
 1582              		@ link register save eliminated.
 1583 0000 80B4     		push	{r7}
 1584              		.cfi_def_cfa_offset 4
 1585              		.cfi_offset 7, -4
 1586 0002 00AF     		add	r7, sp, #0
 1587              		.cfi_def_cfa_register 7
1120:../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1121:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1122:../FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1588              		.loc 1 1122 0
 1589 0004 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1590 0008 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1591 000c 1B68     		ldr	r3, [r3]
 1592 000e 5A1C     		adds	r2, r3, #1
 1593 0010 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1594 0014 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1595 0018 1A60     		str	r2, [r3]
1123:../FreeRTOS/Source/tasks.c **** }
 1596              		.loc 1 1123 0
 1597 001a BD46     		mov	sp, r7
 1598              		@ sp needed
 1599 001c 5DF8047B 		ldr	r7, [sp], #4
 1600 0020 7047     		bx	lr
 1601              		.cfi_endproc
 1602              	.LFE12:
 1604 0022 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1605              		.align	2
 1606              		.global	xTaskResumeAll
 1607              		.thumb
 1608              		.thumb_func
 1610              	xTaskResumeAll:
 1611              	.LFB13:
1124:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1125:../FreeRTOS/Source/tasks.c **** 
1126:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1127:../FreeRTOS/Source/tasks.c **** {
 1612              		.loc 1 1127 0
 1613              		.cfi_startproc
 1614              		@ args = 0, pretend = 0, frame = 8
 1615              		@ frame_needed = 1, uses_anonymous_args = 0
 1616 0000 90B5     		push	{r4, r7, lr}
 1617              		.cfi_def_cfa_offset 12
 1618              		.cfi_offset 4, -12
 1619              		.cfi_offset 7, -8
 1620              		.cfi_offset 14, -4
 1621 0002 83B0     		sub	sp, sp, #12
 1622              		.cfi_def_cfa_offset 24
 1623 0004 00AF     		add	r7, sp, #0
 1624              		.cfi_def_cfa_register 7
1128:../FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1129:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1625              		.loc 1 1129 0
 1626 0006 0023     		movs	r3, #0
 1627 0008 7B60     		str	r3, [r7, #4]
1130:../FreeRTOS/Source/tasks.c **** 
1131:../FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1132:../FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1133:../FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1628              		.loc 1 1133 0
 1629 000a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1630 000e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1631 0012 1B68     		ldr	r3, [r3]
 1632 0014 002B     		cmp	r3, #0
 1633 0016 04D1     		bne	.L92
 1634              		.loc 1 1133 0 is_stmt 0 discriminator 1
 1635              	@ 1133 "../FreeRTOS/Source/tasks.c" 1
 1636 0018 4FF05000 			mov r0, #80								
 1637 001c 80F31188 		msr basepri, r0							
 1638              	
 1639              	@ 0 "" 2
 1640              		.thumb
 1641              	.L93:
 1642 0020 FEE7     		b	.L93
 1643              	.L92:
1134:../FreeRTOS/Source/tasks.c **** 
1135:../FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1136:../FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1137:../FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1138:../FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1139:../FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1140:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1644              		.loc 1 1140 0 is_stmt 1
 1645 0022 FFF7FEFF 		bl	vPortEnterCritical
1141:../FreeRTOS/Source/tasks.c **** 	{
1142:../FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1646              		.loc 1 1142 0
 1647 0026 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1648 002a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1649 002e 1B68     		ldr	r3, [r3]
 1650 0030 5A1E     		subs	r2, r3, #1
 1651 0032 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1652 0036 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1653 003a 1A60     		str	r2, [r3]
1143:../FreeRTOS/Source/tasks.c **** 
1144:../FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1654              		.loc 1 1144 0
 1655 003c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1656 0040 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1657 0044 1B68     		ldr	r3, [r3]
 1658 0046 002B     		cmp	r3, #0
 1659 0048 79D1     		bne	.L94
1145:../FreeRTOS/Source/tasks.c **** 		{
1146:../FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1660              		.loc 1 1146 0
 1661 004a 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1662 004e C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1663 0052 1B68     		ldr	r3, [r3]
 1664 0054 002B     		cmp	r3, #0
 1665 0056 72D0     		beq	.L94
 1666              	.LBB3:
1147:../FreeRTOS/Source/tasks.c **** 			{
1148:../FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1667              		.loc 1 1148 0
 1668 0058 0023     		movs	r3, #0
 1669 005a 3B60     		str	r3, [r7]
1149:../FreeRTOS/Source/tasks.c **** 
1150:../FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1151:../FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1152:../FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1670              		.loc 1 1152 0
 1671 005c 36E0     		b	.L95
 1672              	.L97:
1153:../FreeRTOS/Source/tasks.c **** 				{
1154:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1673              		.loc 1 1154 0
 1674 005e 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1675 0062 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1676 0066 DB68     		ldr	r3, [r3, #12]
 1677 0068 DC68     		ldr	r4, [r3, #12]
1155:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1678              		.loc 1 1155 0
 1679 006a 04F11803 		add	r3, r4, #24
 1680 006e 1846     		mov	r0, r3
 1681 0070 FFF7FEFF 		bl	vListRemove
1156:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1682              		.loc 1 1156 0
 1683 0074 231D     		adds	r3, r4, #4
 1684 0076 1846     		mov	r0, r3
 1685 0078 FFF7FEFF 		bl	vListRemove
1157:../FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1686              		.loc 1 1157 0
 1687 007c E26A     		ldr	r2, [r4, #44]
 1688 007e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1689 0082 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1690 0086 1B68     		ldr	r3, [r3]
 1691 0088 9A42     		cmp	r2, r3
 1692 008a 05D9     		bls	.L96
 1693              		.loc 1 1157 0 is_stmt 0 discriminator 1
 1694 008c E26A     		ldr	r2, [r4, #44]
 1695 008e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1696 0092 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1697 0096 1A60     		str	r2, [r3]
 1698              	.L96:
 1699              		.loc 1 1157 0 discriminator 2
 1700 0098 E26A     		ldr	r2, [r4, #44]
 1701 009a 1346     		mov	r3, r2
 1702 009c 9B00     		lsls	r3, r3, #2
 1703 009e 1344     		add	r3, r3, r2
 1704 00a0 9B00     		lsls	r3, r3, #2
 1705 00a2 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1706 00a6 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1707 00aa 1A44     		add	r2, r2, r3
 1708 00ac 231D     		adds	r3, r4, #4
 1709 00ae 1046     		mov	r0, r2
 1710 00b0 1946     		mov	r1, r3
 1711 00b2 FFF7FEFF 		bl	vListInsertEnd
1158:../FreeRTOS/Source/tasks.c **** 
1159:../FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1160:../FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1161:../FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1712              		.loc 1 1161 0 is_stmt 1 discriminator 2
 1713 00b6 E26A     		ldr	r2, [r4, #44]
 1714 00b8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1715 00bc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1716 00c0 1B68     		ldr	r3, [r3]
 1717 00c2 DB6A     		ldr	r3, [r3, #44]
 1718 00c4 9A42     		cmp	r2, r3
 1719 00c6 01D3     		bcc	.L95
1162:../FreeRTOS/Source/tasks.c **** 					{
1163:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1720              		.loc 1 1163 0
 1721 00c8 0123     		movs	r3, #1
 1722 00ca 3B60     		str	r3, [r7]
 1723              	.L95:
1152:../FreeRTOS/Source/tasks.c **** 				{
 1724              		.loc 1 1152 0 discriminator 1
 1725 00cc 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1726 00d0 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1727 00d4 1B68     		ldr	r3, [r3]
 1728 00d6 002B     		cmp	r3, #0
 1729 00d8 C1D1     		bne	.L97
1164:../FreeRTOS/Source/tasks.c **** 					}
1165:../FreeRTOS/Source/tasks.c **** 				}
1166:../FreeRTOS/Source/tasks.c **** 
1167:../FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1168:../FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1169:../FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1170:../FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1730              		.loc 1 1170 0
 1731 00da 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1732 00de C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1733 00e2 1B68     		ldr	r3, [r3]
 1734 00e4 002B     		cmp	r3, #0
 1735 00e6 16D0     		beq	.L98
1171:../FreeRTOS/Source/tasks.c **** 				{
1172:../FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1736              		.loc 1 1172 0
 1737 00e8 0CE0     		b	.L99
 1738              	.L100:
1173:../FreeRTOS/Source/tasks.c **** 					{
1174:../FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1739              		.loc 1 1174 0
 1740 00ea FFF7FEFF 		bl	vTaskIncrementTick
1175:../FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1741              		.loc 1 1175 0
 1742 00ee 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1743 00f2 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1744 00f6 1B68     		ldr	r3, [r3]
 1745 00f8 5A1E     		subs	r2, r3, #1
 1746 00fa 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1747 00fe C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1748 0102 1A60     		str	r2, [r3]
 1749              	.L99:
1172:../FreeRTOS/Source/tasks.c **** 					{
 1750              		.loc 1 1172 0 discriminator 1
 1751 0104 40F20003 		movw	r3, #:lower16:uxMissedTicks
 1752 0108 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 1753 010c 1B68     		ldr	r3, [r3]
 1754 010e 002B     		cmp	r3, #0
 1755 0110 EBD1     		bne	.L100
1176:../FreeRTOS/Source/tasks.c **** 					}
1177:../FreeRTOS/Source/tasks.c **** 
1178:../FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1179:../FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1180:../FreeRTOS/Source/tasks.c **** 					the task actually running. */
1181:../FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1182:../FreeRTOS/Source/tasks.c **** 					{
1183:../FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1756              		.loc 1 1183 0
 1757 0112 0123     		movs	r3, #1
 1758 0114 3B60     		str	r3, [r7]
 1759              	.L98:
1184:../FreeRTOS/Source/tasks.c **** 					}
1185:../FreeRTOS/Source/tasks.c **** 					#endif
1186:../FreeRTOS/Source/tasks.c **** 				}
1187:../FreeRTOS/Source/tasks.c **** 
1188:../FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1760              		.loc 1 1188 0
 1761 0116 3B68     		ldr	r3, [r7]
 1762 0118 012B     		cmp	r3, #1
 1763 011a 06D0     		beq	.L101
 1764              		.loc 1 1188 0 is_stmt 0 discriminator 1
 1765 011c 40F20003 		movw	r3, #:lower16:xMissedYield
 1766 0120 C0F20003 		movt	r3, #:upper16:xMissedYield
 1767 0124 1B68     		ldr	r3, [r3]
 1768 0126 012B     		cmp	r3, #1
 1769 0128 09D1     		bne	.L94
 1770              	.L101:
1189:../FreeRTOS/Source/tasks.c **** 				{
1190:../FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1771              		.loc 1 1190 0 is_stmt 1
 1772 012a 0123     		movs	r3, #1
 1773 012c 7B60     		str	r3, [r7, #4]
1191:../FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1774              		.loc 1 1191 0
 1775 012e 40F20003 		movw	r3, #:lower16:xMissedYield
 1776 0132 C0F20003 		movt	r3, #:upper16:xMissedYield
 1777 0136 0022     		movs	r2, #0
 1778 0138 1A60     		str	r2, [r3]
1192:../FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1779              		.loc 1 1192 0
 1780 013a FFF7FEFF 		bl	vPortYieldFromISR
 1781              	.L94:
 1782              	.LBE3:
1193:../FreeRTOS/Source/tasks.c **** 				}
1194:../FreeRTOS/Source/tasks.c **** 			}
1195:../FreeRTOS/Source/tasks.c **** 		}
1196:../FreeRTOS/Source/tasks.c **** 	}
1197:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1783              		.loc 1 1197 0
 1784 013e FFF7FEFF 		bl	vPortExitCritical
1198:../FreeRTOS/Source/tasks.c **** 
1199:../FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1785              		.loc 1 1199 0
 1786 0142 7B68     		ldr	r3, [r7, #4]
1200:../FreeRTOS/Source/tasks.c **** }
 1787              		.loc 1 1200 0
 1788 0144 1846     		mov	r0, r3
 1789 0146 0C37     		adds	r7, r7, #12
 1790 0148 BD46     		mov	sp, r7
 1791              		@ sp needed
 1792 014a 90BD     		pop	{r4, r7, pc}
 1793              		.cfi_endproc
 1794              	.LFE13:
 1796              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1797              		.align	2
 1798              		.global	xTaskGetTickCount
 1799              		.thumb
 1800              		.thumb_func
 1802              	xTaskGetTickCount:
 1803              	.LFB14:
1201:../FreeRTOS/Source/tasks.c **** 
1202:../FreeRTOS/Source/tasks.c **** 
1203:../FreeRTOS/Source/tasks.c **** 
1204:../FreeRTOS/Source/tasks.c **** 
1205:../FreeRTOS/Source/tasks.c **** 
1206:../FreeRTOS/Source/tasks.c **** 
1207:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1208:../FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1209:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1210:../FreeRTOS/Source/tasks.c **** 
1211:../FreeRTOS/Source/tasks.c **** 
1212:../FreeRTOS/Source/tasks.c **** 
1213:../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1214:../FreeRTOS/Source/tasks.c **** {
 1804              		.loc 1 1214 0
 1805              		.cfi_startproc
 1806              		@ args = 0, pretend = 0, frame = 8
 1807              		@ frame_needed = 1, uses_anonymous_args = 0
 1808 0000 80B5     		push	{r7, lr}
 1809              		.cfi_def_cfa_offset 8
 1810              		.cfi_offset 7, -8
 1811              		.cfi_offset 14, -4
 1812 0002 82B0     		sub	sp, sp, #8
 1813              		.cfi_def_cfa_offset 16
 1814 0004 00AF     		add	r7, sp, #0
 1815              		.cfi_def_cfa_register 7
1215:../FreeRTOS/Source/tasks.c **** portTickType xTicks;
1216:../FreeRTOS/Source/tasks.c **** 
1217:../FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1218:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1816              		.loc 1 1218 0
 1817 0006 FFF7FEFF 		bl	vPortEnterCritical
1219:../FreeRTOS/Source/tasks.c **** 	{
1220:../FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1818              		.loc 1 1220 0
 1819 000a 40F20003 		movw	r3, #:lower16:xTickCount
 1820 000e C0F20003 		movt	r3, #:upper16:xTickCount
 1821 0012 1B68     		ldr	r3, [r3]
 1822 0014 7B60     		str	r3, [r7, #4]
1221:../FreeRTOS/Source/tasks.c **** 	}
1222:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1823              		.loc 1 1222 0
 1824 0016 FFF7FEFF 		bl	vPortExitCritical
1223:../FreeRTOS/Source/tasks.c **** 
1224:../FreeRTOS/Source/tasks.c **** 	return xTicks;
 1825              		.loc 1 1224 0
 1826 001a 7B68     		ldr	r3, [r7, #4]
1225:../FreeRTOS/Source/tasks.c **** }
 1827              		.loc 1 1225 0
 1828 001c 1846     		mov	r0, r3
 1829 001e 0837     		adds	r7, r7, #8
 1830 0020 BD46     		mov	sp, r7
 1831              		@ sp needed
 1832 0022 80BD     		pop	{r7, pc}
 1833              		.cfi_endproc
 1834              	.LFE14:
 1836              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1837              		.align	2
 1838              		.global	xTaskGetTickCountFromISR
 1839              		.thumb
 1840              		.thumb_func
 1842              	xTaskGetTickCountFromISR:
 1843              	.LFB15:
1226:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1227:../FreeRTOS/Source/tasks.c **** 
1228:../FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1229:../FreeRTOS/Source/tasks.c **** {
 1844              		.loc 1 1229 0
 1845              		.cfi_startproc
 1846              		@ args = 0, pretend = 0, frame = 8
 1847              		@ frame_needed = 1, uses_anonymous_args = 0
 1848              		@ link register save eliminated.
 1849 0000 80B4     		push	{r7}
 1850              		.cfi_def_cfa_offset 4
 1851              		.cfi_offset 7, -4
 1852 0002 83B0     		sub	sp, sp, #12
 1853              		.cfi_def_cfa_offset 16
 1854 0004 00AF     		add	r7, sp, #0
 1855              		.cfi_def_cfa_register 7
1230:../FreeRTOS/Source/tasks.c **** portTickType xReturn;
1231:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:../FreeRTOS/Source/tasks.c **** 
1233:../FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1856              		.loc 1 1233 0
 1857 0006 0023     		movs	r3, #0
 1858 0008 7B60     		str	r3, [r7, #4]
 1859              	@ 1233 "../FreeRTOS/Source/tasks.c" 1
 1860 000a 4FF05000 			mov r0, #80								
 1861 000e 80F31188 		msr basepri, r0							
 1862              	
 1863              	@ 0 "" 2
1234:../FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1864              		.loc 1 1234 0
 1865              		.thumb
 1866 0012 40F20003 		movw	r3, #:lower16:xTickCount
 1867 0016 C0F20003 		movt	r3, #:upper16:xTickCount
 1868 001a 1B68     		ldr	r3, [r3]
 1869 001c 3B60     		str	r3, [r7]
1235:../FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1870              		.loc 1 1235 0
 1871              	@ 1235 "../FreeRTOS/Source/tasks.c" 1
 1872 001e 4FF00000 			mov r0, #0					
 1873 0022 80F31188 		msr basepri, r0				
 1874              	
 1875              	@ 0 "" 2
1236:../FreeRTOS/Source/tasks.c **** 
1237:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 1876              		.loc 1 1237 0
 1877              		.thumb
 1878 0026 3B68     		ldr	r3, [r7]
1238:../FreeRTOS/Source/tasks.c **** }
 1879              		.loc 1 1238 0
 1880 0028 1846     		mov	r0, r3
 1881 002a 0C37     		adds	r7, r7, #12
 1882 002c BD46     		mov	sp, r7
 1883              		@ sp needed
 1884 002e 5DF8047B 		ldr	r7, [sp], #4
 1885 0032 7047     		bx	lr
 1886              		.cfi_endproc
 1887              	.LFE15:
 1889              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1890              		.align	2
 1891              		.global	uxTaskGetNumberOfTasks
 1892              		.thumb
 1893              		.thumb_func
 1895              	uxTaskGetNumberOfTasks:
 1896              	.LFB16:
1239:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1240:../FreeRTOS/Source/tasks.c **** 
1241:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:../FreeRTOS/Source/tasks.c **** {
 1897              		.loc 1 1242 0
 1898              		.cfi_startproc
 1899              		@ args = 0, pretend = 0, frame = 0
 1900              		@ frame_needed = 1, uses_anonymous_args = 0
 1901              		@ link register save eliminated.
 1902 0000 80B4     		push	{r7}
 1903              		.cfi_def_cfa_offset 4
 1904              		.cfi_offset 7, -4
 1905 0002 00AF     		add	r7, sp, #0
 1906              		.cfi_def_cfa_register 7
1243:../FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1244:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1245:../FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1907              		.loc 1 1245 0
 1908 0004 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1909 0008 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1910 000c 1B68     		ldr	r3, [r3]
1246:../FreeRTOS/Source/tasks.c **** }
 1911              		.loc 1 1246 0
 1912 000e 1846     		mov	r0, r3
 1913 0010 BD46     		mov	sp, r7
 1914              		@ sp needed
 1915 0012 5DF8047B 		ldr	r7, [sp], #4
 1916 0016 7047     		bx	lr
 1917              		.cfi_endproc
 1918              	.LFE16:
 1920              		.section	.text.vTaskIncrementTick,"ax",%progbits
 1921              		.align	2
 1922              		.global	vTaskIncrementTick
 1923              		.thumb
 1924              		.thumb_func
 1926              	vTaskIncrementTick:
 1927              	.LFB17:
1247:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1248:../FreeRTOS/Source/tasks.c **** 
1249:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:../FreeRTOS/Source/tasks.c **** 
1251:../FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:../FreeRTOS/Source/tasks.c **** 	{
1253:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1254:../FreeRTOS/Source/tasks.c **** 
1255:../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1256:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1258:../FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1259:../FreeRTOS/Source/tasks.c **** 	}
1260:../FreeRTOS/Source/tasks.c **** 
1261:../FreeRTOS/Source/tasks.c **** #endif
1262:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1263:../FreeRTOS/Source/tasks.c **** 
1264:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1265:../FreeRTOS/Source/tasks.c **** 
1266:../FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1267:../FreeRTOS/Source/tasks.c **** 	{
1268:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1269:../FreeRTOS/Source/tasks.c **** 
1270:../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1271:../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1272:../FreeRTOS/Source/tasks.c **** 
1273:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1274:../FreeRTOS/Source/tasks.c **** 		{
1275:../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1276:../FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1277:../FreeRTOS/Source/tasks.c **** 
1278:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1279:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1280:../FreeRTOS/Source/tasks.c **** 
1281:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1282:../FreeRTOS/Source/tasks.c **** 
1283:../FreeRTOS/Source/tasks.c **** 			do
1284:../FreeRTOS/Source/tasks.c **** 			{
1285:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1286:../FreeRTOS/Source/tasks.c **** 
1287:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1288:../FreeRTOS/Source/tasks.c **** 				{
1289:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1290:../FreeRTOS/Source/tasks.c **** 				}
1291:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1292:../FreeRTOS/Source/tasks.c **** 
1293:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1294:../FreeRTOS/Source/tasks.c **** 			{
1295:../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1296:../FreeRTOS/Source/tasks.c **** 			}
1297:../FreeRTOS/Source/tasks.c **** 
1298:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1299:../FreeRTOS/Source/tasks.c **** 			{
1300:../FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1301:../FreeRTOS/Source/tasks.c **** 			}
1302:../FreeRTOS/Source/tasks.c **** 
1303:../FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1304:../FreeRTOS/Source/tasks.c **** 			{
1305:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1306:../FreeRTOS/Source/tasks.c **** 				{
1307:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1308:../FreeRTOS/Source/tasks.c **** 				}
1309:../FreeRTOS/Source/tasks.c **** 			}
1310:../FreeRTOS/Source/tasks.c **** 			#endif
1311:../FreeRTOS/Source/tasks.c **** 
1312:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1313:../FreeRTOS/Source/tasks.c **** 			{
1314:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1315:../FreeRTOS/Source/tasks.c **** 				{
1316:../FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1317:../FreeRTOS/Source/tasks.c **** 				}
1318:../FreeRTOS/Source/tasks.c **** 			}
1319:../FreeRTOS/Source/tasks.c **** 			#endif
1320:../FreeRTOS/Source/tasks.c **** 		}
1321:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1322:../FreeRTOS/Source/tasks.c **** 	}
1323:../FreeRTOS/Source/tasks.c **** 
1324:../FreeRTOS/Source/tasks.c **** #endif
1325:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1326:../FreeRTOS/Source/tasks.c **** 
1327:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:../FreeRTOS/Source/tasks.c **** 
1329:../FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:../FreeRTOS/Source/tasks.c **** 	{
1331:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1332:../FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1333:../FreeRTOS/Source/tasks.c **** 
1334:../FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1335:../FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1336:../FreeRTOS/Source/tasks.c **** 
1337:../FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1338:../FreeRTOS/Source/tasks.c **** 		{
1339:../FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:../FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:../FreeRTOS/Source/tasks.c **** 			#else
1342:../FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1343:../FreeRTOS/Source/tasks.c **** 			#endif
1344:../FreeRTOS/Source/tasks.c **** 
1345:../FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:../FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:../FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1348:../FreeRTOS/Source/tasks.c **** 			
1349:../FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1350:../FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1351:../FreeRTOS/Source/tasks.c **** 			buffer. */
1352:../FreeRTOS/Source/tasks.c **** 
1353:../FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1354:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1355:../FreeRTOS/Source/tasks.c **** 
1356:../FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1357:../FreeRTOS/Source/tasks.c **** 
1358:../FreeRTOS/Source/tasks.c **** 			do
1359:../FreeRTOS/Source/tasks.c **** 			{
1360:../FreeRTOS/Source/tasks.c **** 				uxQueue--;
1361:../FreeRTOS/Source/tasks.c **** 
1362:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1363:../FreeRTOS/Source/tasks.c **** 				{
1364:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1365:../FreeRTOS/Source/tasks.c **** 				}
1366:../FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1367:../FreeRTOS/Source/tasks.c **** 
1368:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1369:../FreeRTOS/Source/tasks.c **** 			{
1370:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1371:../FreeRTOS/Source/tasks.c **** 			}
1372:../FreeRTOS/Source/tasks.c **** 
1373:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1374:../FreeRTOS/Source/tasks.c **** 			{
1375:../FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1376:../FreeRTOS/Source/tasks.c **** 			}
1377:../FreeRTOS/Source/tasks.c **** 
1378:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:../FreeRTOS/Source/tasks.c **** 			{
1380:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1381:../FreeRTOS/Source/tasks.c **** 				{
1382:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1383:../FreeRTOS/Source/tasks.c **** 				}
1384:../FreeRTOS/Source/tasks.c **** 			}
1385:../FreeRTOS/Source/tasks.c **** 			#endif
1386:../FreeRTOS/Source/tasks.c **** 
1387:../FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1388:../FreeRTOS/Source/tasks.c **** 			{
1389:../FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1390:../FreeRTOS/Source/tasks.c **** 				{
1391:../FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1392:../FreeRTOS/Source/tasks.c **** 				}
1393:../FreeRTOS/Source/tasks.c **** 			}
1394:../FreeRTOS/Source/tasks.c **** 			#endif
1395:../FreeRTOS/Source/tasks.c **** 		}
1396:../FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1397:../FreeRTOS/Source/tasks.c **** 	}
1398:../FreeRTOS/Source/tasks.c **** 
1399:../FreeRTOS/Source/tasks.c **** #endif
1400:../FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1401:../FreeRTOS/Source/tasks.c **** 
1402:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:../FreeRTOS/Source/tasks.c **** 
1404:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:../FreeRTOS/Source/tasks.c **** 	{
1406:../FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:../FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1408:../FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:../FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1410:../FreeRTOS/Source/tasks.c **** 	}
1411:../FreeRTOS/Source/tasks.c **** 	
1412:../FreeRTOS/Source/tasks.c **** #endif
1413:../FreeRTOS/Source/tasks.c **** 
1414:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1415:../FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:../FreeRTOS/Source/tasks.c ****  * documented in task.h
1417:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1418:../FreeRTOS/Source/tasks.c **** 
1419:../FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1420:../FreeRTOS/Source/tasks.c **** {
 1928              		.loc 1 1420 0
 1929              		.cfi_startproc
 1930              		@ args = 0, pretend = 0, frame = 16
 1931              		@ frame_needed = 1, uses_anonymous_args = 0
 1932 0000 80B5     		push	{r7, lr}
 1933              		.cfi_def_cfa_offset 8
 1934              		.cfi_offset 7, -8
 1935              		.cfi_offset 14, -4
 1936 0002 84B0     		sub	sp, sp, #16
 1937              		.cfi_def_cfa_offset 24
 1938 0004 00AF     		add	r7, sp, #0
 1939              		.cfi_def_cfa_register 7
1421:../FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1422:../FreeRTOS/Source/tasks.c **** 
1423:../FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1424:../FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1425:../FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1426:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1940              		.loc 1 1426 0
 1941 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1942 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1943 000e 1B68     		ldr	r3, [r3]
 1944 0010 002B     		cmp	r3, #0
 1945 0012 40F0C680 		bne	.L110
1427:../FreeRTOS/Source/tasks.c **** 	{
1428:../FreeRTOS/Source/tasks.c **** 		++xTickCount;
 1946              		.loc 1 1428 0
 1947 0016 40F20003 		movw	r3, #:lower16:xTickCount
 1948 001a C0F20003 		movt	r3, #:upper16:xTickCount
 1949 001e 1B68     		ldr	r3, [r3]
 1950 0020 5A1C     		adds	r2, r3, #1
 1951 0022 40F20003 		movw	r3, #:lower16:xTickCount
 1952 0026 C0F20003 		movt	r3, #:upper16:xTickCount
 1953 002a 1A60     		str	r2, [r3]
1429:../FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1954              		.loc 1 1429 0
 1955 002c 40F20003 		movw	r3, #:lower16:xTickCount
 1956 0030 C0F20003 		movt	r3, #:upper16:xTickCount
 1957 0034 1B68     		ldr	r3, [r3]
 1958 0036 002B     		cmp	r3, #0
 1959 0038 4CD1     		bne	.L111
 1960              	.LBB4:
1430:../FreeRTOS/Source/tasks.c **** 		{
1431:../FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1432:../FreeRTOS/Source/tasks.c **** 
1433:../FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1434:../FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1435:../FreeRTOS/Source/tasks.c **** 			an error! */
1436:../FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 1961              		.loc 1 1436 0
 1962 003a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1963 003e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1964 0042 1B68     		ldr	r3, [r3]
 1965 0044 1B68     		ldr	r3, [r3]
 1966 0046 002B     		cmp	r3, #0
 1967 0048 04D0     		beq	.L112
 1968              		.loc 1 1436 0 is_stmt 0 discriminator 1
 1969              	@ 1436 "../FreeRTOS/Source/tasks.c" 1
 1970 004a 4FF05000 			mov r0, #80								
 1971 004e 80F31188 		msr basepri, r0							
 1972              	
 1973              	@ 0 "" 2
 1974              		.thumb
 1975              	.L113:
 1976 0052 FEE7     		b	.L113
 1977              	.L112:
1437:../FreeRTOS/Source/tasks.c **** 			
1438:../FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1978              		.loc 1 1438 0 is_stmt 1
 1979 0054 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1980 0058 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1981 005c 1B68     		ldr	r3, [r3]
 1982 005e FB60     		str	r3, [r7, #12]
1439:../FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1983              		.loc 1 1439 0
 1984 0060 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1985 0064 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1986 0068 1A68     		ldr	r2, [r3]
 1987 006a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1988 006e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1989 0072 1A60     		str	r2, [r3]
1440:../FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1990              		.loc 1 1440 0
 1991 0074 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1992 0078 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1993 007c FA68     		ldr	r2, [r7, #12]
 1994 007e 1A60     		str	r2, [r3]
1441:../FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 1995              		.loc 1 1441 0
 1996 0080 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 1997 0084 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 1998 0088 1B68     		ldr	r3, [r3]
 1999 008a 5A1C     		adds	r2, r3, #1
 2000 008c 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2001 0090 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2002 0094 1A60     		str	r2, [r3]
1442:../FreeRTOS/Source/tasks.c **** 	
1443:../FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2003              		.loc 1 1443 0
 2004 0096 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2005 009a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2006 009e 1B68     		ldr	r3, [r3]
 2007 00a0 1B68     		ldr	r3, [r3]
 2008 00a2 002B     		cmp	r3, #0
 2009 00a4 07D1     		bne	.L114
1444:../FreeRTOS/Source/tasks.c **** 			{
1445:../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1446:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1447:../FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1448:../FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:../FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1450:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2010              		.loc 1 1450 0
 2011 00a6 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2012 00aa C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2013 00ae 4FF0FF32 		mov	r2, #-1
 2014 00b2 1A60     		str	r2, [r3]
 2015 00b4 0EE0     		b	.L111
 2016              	.L114:
1451:../FreeRTOS/Source/tasks.c **** 			}
1452:../FreeRTOS/Source/tasks.c **** 			else
1453:../FreeRTOS/Source/tasks.c **** 			{
1454:../FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1455:../FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1456:../FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1457:../FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1458:../FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2017              		.loc 1 1458 0
 2018 00b6 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2019 00ba C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2020 00be 1B68     		ldr	r3, [r3]
 2021 00c0 DB68     		ldr	r3, [r3, #12]
 2022 00c2 DB68     		ldr	r3, [r3, #12]
 2023 00c4 BB60     		str	r3, [r7, #8]
1459:../FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2024              		.loc 1 1459 0
 2025 00c6 BB68     		ldr	r3, [r7, #8]
 2026 00c8 5A68     		ldr	r2, [r3, #4]
 2027 00ca 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2028 00ce C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2029 00d2 1A60     		str	r2, [r3]
 2030              	.L111:
 2031              	.LBE4:
 2032              	.LBB5:
1460:../FreeRTOS/Source/tasks.c **** 			}
1461:../FreeRTOS/Source/tasks.c **** 		}
1462:../FreeRTOS/Source/tasks.c **** 
1463:../FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1464:../FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 2033              		.loc 1 1464 0
 2034 00d4 40F20003 		movw	r3, #:lower16:xTickCount
 2035 00d8 C0F20003 		movt	r3, #:upper16:xTickCount
 2036 00dc 1A68     		ldr	r2, [r3]
 2037 00de 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2038 00e2 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2039 00e6 1B68     		ldr	r3, [r3]
 2040 00e8 9A42     		cmp	r2, r3
 2041 00ea 59D3     		bcc	.L115
 2042              	.L120:
 2043              		.loc 1 1464 0 is_stmt 0 discriminator 1
 2044 00ec 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2045 00f0 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2046 00f4 1B68     		ldr	r3, [r3]
 2047 00f6 1B68     		ldr	r3, [r3]
 2048 00f8 002B     		cmp	r3, #0
 2049 00fa 07D1     		bne	.L116
 2050 00fc 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2051 0100 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2052 0104 4FF0FF32 		mov	r2, #-1
 2053 0108 1A60     		str	r2, [r3]
 2054 010a 49E0     		b	.L115
 2055              	.L116:
 2056              		.loc 1 1464 0 discriminator 2
 2057 010c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2058 0110 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2059 0114 1B68     		ldr	r3, [r3]
 2060 0116 DB68     		ldr	r3, [r3, #12]
 2061 0118 DB68     		ldr	r3, [r3, #12]
 2062 011a BB60     		str	r3, [r7, #8]
 2063 011c BB68     		ldr	r3, [r7, #8]
 2064 011e 5B68     		ldr	r3, [r3, #4]
 2065 0120 7B60     		str	r3, [r7, #4]
 2066 0122 40F20003 		movw	r3, #:lower16:xTickCount
 2067 0126 C0F20003 		movt	r3, #:upper16:xTickCount
 2068 012a 1A68     		ldr	r2, [r3]
 2069 012c 7B68     		ldr	r3, [r7, #4]
 2070 012e 9A42     		cmp	r2, r3
 2071 0130 06D2     		bcs	.L117
 2072              		.loc 1 1464 0 discriminator 1
 2073 0132 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2074 0136 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2075 013a 7A68     		ldr	r2, [r7, #4]
 2076 013c 1A60     		str	r2, [r3]
 2077 013e 2FE0     		b	.L115
 2078              	.L117:
 2079              		.loc 1 1464 0 discriminator 2
 2080 0140 BB68     		ldr	r3, [r7, #8]
 2081 0142 0433     		adds	r3, r3, #4
 2082 0144 1846     		mov	r0, r3
 2083 0146 FFF7FEFF 		bl	vListRemove
 2084 014a BB68     		ldr	r3, [r7, #8]
 2085 014c 9B6A     		ldr	r3, [r3, #40]
 2086 014e 002B     		cmp	r3, #0
 2087 0150 04D0     		beq	.L118
 2088              		.loc 1 1464 0 discriminator 1
 2089 0152 BB68     		ldr	r3, [r7, #8]
 2090 0154 1833     		adds	r3, r3, #24
 2091 0156 1846     		mov	r0, r3
 2092 0158 FFF7FEFF 		bl	vListRemove
 2093              	.L118:
 2094              		.loc 1 1464 0 discriminator 2
 2095 015c BB68     		ldr	r3, [r7, #8]
 2096 015e DA6A     		ldr	r2, [r3, #44]
 2097 0160 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2098 0164 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2099 0168 1B68     		ldr	r3, [r3]
 2100 016a 9A42     		cmp	r2, r3
 2101 016c 06D9     		bls	.L119
 2102              		.loc 1 1464 0 discriminator 1
 2103 016e BB68     		ldr	r3, [r7, #8]
 2104 0170 DA6A     		ldr	r2, [r3, #44]
 2105 0172 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2106 0176 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2107 017a 1A60     		str	r2, [r3]
 2108              	.L119:
 2109              		.loc 1 1464 0 discriminator 2
 2110 017c BB68     		ldr	r3, [r7, #8]
 2111 017e DA6A     		ldr	r2, [r3, #44]
 2112 0180 1346     		mov	r3, r2
 2113 0182 9B00     		lsls	r3, r3, #2
 2114 0184 1344     		add	r3, r3, r2
 2115 0186 9B00     		lsls	r3, r3, #2
 2116 0188 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2117 018c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2118 0190 1A44     		add	r2, r2, r3
 2119 0192 BB68     		ldr	r3, [r7, #8]
 2120 0194 0433     		adds	r3, r3, #4
 2121 0196 1046     		mov	r0, r2
 2122 0198 1946     		mov	r1, r3
 2123 019a FFF7FEFF 		bl	vListInsertEnd
 2124 019e A5E7     		b	.L120
 2125              	.L115:
 2126              	.LBE5:
 2127 01a0 0AE0     		b	.L109
 2128              	.L110:
1465:../FreeRTOS/Source/tasks.c **** 	}
1466:../FreeRTOS/Source/tasks.c **** 	else
1467:../FreeRTOS/Source/tasks.c **** 	{
1468:../FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 2129              		.loc 1 1468 0 is_stmt 1
 2130 01a2 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2131 01a6 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2132 01aa 1B68     		ldr	r3, [r3]
 2133 01ac 5A1C     		adds	r2, r3, #1
 2134 01ae 40F20003 		movw	r3, #:lower16:uxMissedTicks
 2135 01b2 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 2136 01b6 1A60     		str	r2, [r3]
 2137              	.L109:
1469:../FreeRTOS/Source/tasks.c **** 
1470:../FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1471:../FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1472:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1473:../FreeRTOS/Source/tasks.c **** 		{
1474:../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1475:../FreeRTOS/Source/tasks.c **** 		}
1476:../FreeRTOS/Source/tasks.c **** 		#endif
1477:../FreeRTOS/Source/tasks.c **** 	}
1478:../FreeRTOS/Source/tasks.c **** 
1479:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1480:../FreeRTOS/Source/tasks.c **** 	{
1481:../FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1482:../FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1483:../FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1484:../FreeRTOS/Source/tasks.c **** 		{
1485:../FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1486:../FreeRTOS/Source/tasks.c **** 		}
1487:../FreeRTOS/Source/tasks.c **** 	}
1488:../FreeRTOS/Source/tasks.c **** 	#endif
1489:../FreeRTOS/Source/tasks.c **** 
1490:../FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1491:../FreeRTOS/Source/tasks.c **** }
 2138              		.loc 1 1491 0
 2139 01b8 1037     		adds	r7, r7, #16
 2140 01ba BD46     		mov	sp, r7
 2141              		@ sp needed
 2142 01bc 80BD     		pop	{r7, pc}
 2143              		.cfi_endproc
 2144              	.LFE17:
 2146 01be 00BF     		.section	.text.vTaskSwitchContext,"ax",%progbits
 2147              		.align	2
 2148              		.global	vTaskSwitchContext
 2149              		.thumb
 2150              		.thumb_func
 2152              	vTaskSwitchContext:
 2153              	.LFB18:
1492:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1493:../FreeRTOS/Source/tasks.c **** 
1494:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:../FreeRTOS/Source/tasks.c **** 
1496:../FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:../FreeRTOS/Source/tasks.c **** 	{
1498:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1499:../FreeRTOS/Source/tasks.c **** 
1500:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1502:../FreeRTOS/Source/tasks.c **** 		{
1503:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:../FreeRTOS/Source/tasks.c **** 		}
1505:../FreeRTOS/Source/tasks.c **** 		else
1506:../FreeRTOS/Source/tasks.c **** 		{
1507:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:../FreeRTOS/Source/tasks.c **** 		}
1509:../FreeRTOS/Source/tasks.c **** 
1510:../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1512:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1513:../FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1514:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1515:../FreeRTOS/Source/tasks.c **** 	}
1516:../FreeRTOS/Source/tasks.c **** 
1517:../FreeRTOS/Source/tasks.c **** #endif
1518:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1519:../FreeRTOS/Source/tasks.c **** 
1520:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:../FreeRTOS/Source/tasks.c **** 
1522:../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:../FreeRTOS/Source/tasks.c **** 	{
1524:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1525:../FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1526:../FreeRTOS/Source/tasks.c **** 
1527:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1528:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1529:../FreeRTOS/Source/tasks.c **** 		{
1530:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:../FreeRTOS/Source/tasks.c **** 		}
1532:../FreeRTOS/Source/tasks.c **** 		else
1533:../FreeRTOS/Source/tasks.c **** 		{
1534:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1535:../FreeRTOS/Source/tasks.c **** 		}
1536:../FreeRTOS/Source/tasks.c **** 
1537:../FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1538:../FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1539:../FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1540:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1541:../FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1542:../FreeRTOS/Source/tasks.c **** 
1543:../FreeRTOS/Source/tasks.c **** 		return xReturn;
1544:../FreeRTOS/Source/tasks.c **** 	}
1545:../FreeRTOS/Source/tasks.c **** 
1546:../FreeRTOS/Source/tasks.c **** #endif
1547:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1548:../FreeRTOS/Source/tasks.c **** 
1549:../FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:../FreeRTOS/Source/tasks.c **** 
1551:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:../FreeRTOS/Source/tasks.c **** 	{
1553:../FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1554:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1555:../FreeRTOS/Source/tasks.c **** 
1556:../FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1557:../FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1558:../FreeRTOS/Source/tasks.c **** 		{
1559:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:../FreeRTOS/Source/tasks.c **** 		}
1561:../FreeRTOS/Source/tasks.c **** 		else
1562:../FreeRTOS/Source/tasks.c **** 		{
1563:../FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1564:../FreeRTOS/Source/tasks.c **** 		}
1565:../FreeRTOS/Source/tasks.c **** 
1566:../FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1567:../FreeRTOS/Source/tasks.c **** 		{
1568:../FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1569:../FreeRTOS/Source/tasks.c **** 		}
1570:../FreeRTOS/Source/tasks.c **** 		else
1571:../FreeRTOS/Source/tasks.c **** 		{
1572:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1573:../FreeRTOS/Source/tasks.c **** 		}
1574:../FreeRTOS/Source/tasks.c **** 
1575:../FreeRTOS/Source/tasks.c **** 		return xReturn;
1576:../FreeRTOS/Source/tasks.c **** 	}
1577:../FreeRTOS/Source/tasks.c **** 
1578:../FreeRTOS/Source/tasks.c **** #endif
1579:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1580:../FreeRTOS/Source/tasks.c **** 
1581:../FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1582:../FreeRTOS/Source/tasks.c **** {
 2154              		.loc 1 1582 0
 2155              		.cfi_startproc
 2156              		@ args = 0, pretend = 0, frame = 8
 2157              		@ frame_needed = 1, uses_anonymous_args = 0
 2158              		@ link register save eliminated.
 2159 0000 80B4     		push	{r7}
 2160              		.cfi_def_cfa_offset 4
 2161              		.cfi_offset 7, -4
 2162 0002 83B0     		sub	sp, sp, #12
 2163              		.cfi_def_cfa_offset 16
 2164 0004 00AF     		add	r7, sp, #0
 2165              		.cfi_def_cfa_register 7
1583:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2166              		.loc 1 1583 0
 2167 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2168 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2169 000e 1B68     		ldr	r3, [r3]
 2170 0010 002B     		cmp	r3, #0
 2171 0012 06D0     		beq	.L123
1584:../FreeRTOS/Source/tasks.c **** 	{
1585:../FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1586:../FreeRTOS/Source/tasks.c **** 		switch. */
1587:../FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2172              		.loc 1 1587 0
 2173 0014 40F20003 		movw	r3, #:lower16:xMissedYield
 2174 0018 C0F20003 		movt	r3, #:upper16:xMissedYield
 2175 001c 0122     		movs	r2, #1
 2176 001e 1A60     		str	r2, [r3]
 2177 0020 4FE0     		b	.L122
 2178              	.L123:
1588:../FreeRTOS/Source/tasks.c **** 	}
1589:../FreeRTOS/Source/tasks.c **** 	else
1590:../FreeRTOS/Source/tasks.c **** 	{
1591:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1592:../FreeRTOS/Source/tasks.c **** 	
1593:../FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:../FreeRTOS/Source/tasks.c **** 		{
1595:../FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1596:../FreeRTOS/Source/tasks.c **** 			
1597:../FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:../FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:../FreeRTOS/Source/tasks.c **** 				#else
1600:../FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1601:../FreeRTOS/Source/tasks.c **** 				#endif
1602:../FreeRTOS/Source/tasks.c **** 	
1603:../FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1604:../FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1605:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:../FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1607:../FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1608:../FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1609:../FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1610:../FreeRTOS/Source/tasks.c **** 		}
1611:../FreeRTOS/Source/tasks.c **** 		#endif
1612:../FreeRTOS/Source/tasks.c **** 	
1613:../FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1614:../FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1615:../FreeRTOS/Source/tasks.c **** 	
1616:../FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1617:../FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2179              		.loc 1 1617 0
 2180 0022 16E0     		b	.L125
 2181              	.L128:
1618:../FreeRTOS/Source/tasks.c **** 		{
1619:../FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
 2182              		.loc 1 1619 0
 2183 0024 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2184 0028 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2185 002c 1B68     		ldr	r3, [r3]
 2186 002e 002B     		cmp	r3, #0
 2187 0030 04D1     		bne	.L126
 2188              		.loc 1 1619 0 is_stmt 0 discriminator 1
 2189              	@ 1619 "../FreeRTOS/Source/tasks.c" 1
 2190 0032 4FF05000 			mov r0, #80								
 2191 0036 80F31188 		msr basepri, r0							
 2192              	
 2193              	@ 0 "" 2
 2194              		.thumb
 2195              	.L127:
 2196 003a FEE7     		b	.L127
 2197              	.L126:
1620:../FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
 2198              		.loc 1 1620 0 is_stmt 1
 2199 003c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2200 0040 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2201 0044 1B68     		ldr	r3, [r3]
 2202 0046 5A1E     		subs	r2, r3, #1
 2203 0048 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2204 004c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2205 0050 1A60     		str	r2, [r3]
 2206              	.L125:
1617:../FreeRTOS/Source/tasks.c **** 		{
 2207              		.loc 1 1617 0 discriminator 1
 2208 0052 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2209 0056 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2210 005a 1968     		ldr	r1, [r3]
 2211 005c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2212 0060 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2213 0064 0B46     		mov	r3, r1
 2214 0066 9B00     		lsls	r3, r3, #2
 2215 0068 0B44     		add	r3, r3, r1
 2216 006a 9B00     		lsls	r3, r3, #2
 2217 006c 1344     		add	r3, r3, r2
 2218 006e 1B68     		ldr	r3, [r3]
 2219 0070 002B     		cmp	r3, #0
 2220 0072 D7D0     		beq	.L128
 2221              	.LBB6:
1621:../FreeRTOS/Source/tasks.c **** 		}
1622:../FreeRTOS/Source/tasks.c **** 	
1623:../FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:../FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1625:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2222              		.loc 1 1625 0
 2223 0074 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2224 0078 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2225 007c 1A68     		ldr	r2, [r3]
 2226 007e 1346     		mov	r3, r2
 2227 0080 9B00     		lsls	r3, r3, #2
 2228 0082 1344     		add	r3, r3, r2
 2229 0084 9B00     		lsls	r3, r3, #2
 2230 0086 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2231 008a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2232 008e 1344     		add	r3, r3, r2
 2233 0090 7B60     		str	r3, [r7, #4]
 2234 0092 7B68     		ldr	r3, [r7, #4]
 2235 0094 5B68     		ldr	r3, [r3, #4]
 2236 0096 5A68     		ldr	r2, [r3, #4]
 2237 0098 7B68     		ldr	r3, [r7, #4]
 2238 009a 5A60     		str	r2, [r3, #4]
 2239 009c 7B68     		ldr	r3, [r7, #4]
 2240 009e 5A68     		ldr	r2, [r3, #4]
 2241 00a0 7B68     		ldr	r3, [r7, #4]
 2242 00a2 0833     		adds	r3, r3, #8
 2243 00a4 9A42     		cmp	r2, r3
 2244 00a6 04D1     		bne	.L129
 2245              		.loc 1 1625 0 is_stmt 0 discriminator 1
 2246 00a8 7B68     		ldr	r3, [r7, #4]
 2247 00aa 5B68     		ldr	r3, [r3, #4]
 2248 00ac 5A68     		ldr	r2, [r3, #4]
 2249 00ae 7B68     		ldr	r3, [r7, #4]
 2250 00b0 5A60     		str	r2, [r3, #4]
 2251              	.L129:
 2252              		.loc 1 1625 0 discriminator 2
 2253 00b2 7B68     		ldr	r3, [r7, #4]
 2254 00b4 5B68     		ldr	r3, [r3, #4]
 2255 00b6 DA68     		ldr	r2, [r3, #12]
 2256 00b8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2257 00bc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2258 00c0 1A60     		str	r2, [r3]
 2259              	.L122:
 2260              	.LBE6:
1626:../FreeRTOS/Source/tasks.c **** 	
1627:../FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1628:../FreeRTOS/Source/tasks.c **** 	}
1629:../FreeRTOS/Source/tasks.c **** }
 2261              		.loc 1 1629 0 is_stmt 1
 2262 00c2 0C37     		adds	r7, r7, #12
 2263 00c4 BD46     		mov	sp, r7
 2264              		@ sp needed
 2265 00c6 5DF8047B 		ldr	r7, [sp], #4
 2266 00ca 7047     		bx	lr
 2267              		.cfi_endproc
 2268              	.LFE18:
 2270              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2271              		.align	2
 2272              		.global	vTaskPlaceOnEventList
 2273              		.thumb
 2274              		.thumb_func
 2276              	vTaskPlaceOnEventList:
 2277              	.LFB19:
1630:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1631:../FreeRTOS/Source/tasks.c **** 
1632:../FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:../FreeRTOS/Source/tasks.c **** {
 2278              		.loc 1 1633 0
 2279              		.cfi_startproc
 2280              		@ args = 0, pretend = 0, frame = 16
 2281              		@ frame_needed = 1, uses_anonymous_args = 0
 2282 0000 80B5     		push	{r7, lr}
 2283              		.cfi_def_cfa_offset 8
 2284              		.cfi_offset 7, -8
 2285              		.cfi_offset 14, -4
 2286 0002 84B0     		sub	sp, sp, #16
 2287              		.cfi_def_cfa_offset 24
 2288 0004 00AF     		add	r7, sp, #0
 2289              		.cfi_def_cfa_register 7
 2290 0006 7860     		str	r0, [r7, #4]
 2291 0008 3960     		str	r1, [r7]
1634:../FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1635:../FreeRTOS/Source/tasks.c **** 
1636:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2292              		.loc 1 1636 0
 2293 000a 7B68     		ldr	r3, [r7, #4]
 2294 000c 002B     		cmp	r3, #0
 2295 000e 04D1     		bne	.L131
 2296              		.loc 1 1636 0 is_stmt 0 discriminator 1
 2297              	@ 1636 "../FreeRTOS/Source/tasks.c" 1
 2298 0010 4FF05000 			mov r0, #80								
 2299 0014 80F31188 		msr basepri, r0							
 2300              	
 2301              	@ 0 "" 2
 2302              		.thumb
 2303              	.L132:
 2304 0018 FEE7     		b	.L132
 2305              	.L131:
1637:../FreeRTOS/Source/tasks.c **** 
1638:../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1640:../FreeRTOS/Source/tasks.c **** 
1641:../FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1642:../FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1643:../FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1644:../FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2306              		.loc 1 1644 0 is_stmt 1
 2307 001a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2308 001e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2309 0022 1B68     		ldr	r3, [r3]
 2310 0024 1833     		adds	r3, r3, #24
 2311 0026 7868     		ldr	r0, [r7, #4]
 2312 0028 1946     		mov	r1, r3
 2313 002a FFF7FEFF 		bl	vListInsert
1645:../FreeRTOS/Source/tasks.c **** 
1646:../FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1647:../FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1648:../FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1649:../FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2314              		.loc 1 1649 0
 2315 002e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2316 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2317 0036 1B68     		ldr	r3, [r3]
 2318 0038 0433     		adds	r3, r3, #4
 2319 003a 1846     		mov	r0, r3
 2320 003c FFF7FEFF 		bl	vListRemove
1650:../FreeRTOS/Source/tasks.c **** 
1651:../FreeRTOS/Source/tasks.c **** 
1652:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1653:../FreeRTOS/Source/tasks.c **** 	{
1654:../FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2321              		.loc 1 1654 0
 2322 0040 3B68     		ldr	r3, [r7]
 2323 0042 B3F1FF3F 		cmp	r3, #-1
 2324 0046 0DD1     		bne	.L133
1655:../FreeRTOS/Source/tasks.c **** 		{
1656:../FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1657:../FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1658:../FreeRTOS/Source/tasks.c **** 			indefinitely. */
1659:../FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2325              		.loc 1 1659 0
 2326 0048 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2327 004c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2328 0050 1B68     		ldr	r3, [r3]
 2329 0052 0433     		adds	r3, r3, #4
 2330 0054 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2331 0058 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2332 005c 1946     		mov	r1, r3
 2333 005e FFF7FEFF 		bl	vListInsertEnd
 2334 0062 0AE0     		b	.L130
 2335              	.L133:
1660:../FreeRTOS/Source/tasks.c **** 		}
1661:../FreeRTOS/Source/tasks.c **** 		else
1662:../FreeRTOS/Source/tasks.c **** 		{
1663:../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1664:../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1665:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2336              		.loc 1 1665 0
 2337 0064 40F20003 		movw	r3, #:lower16:xTickCount
 2338 0068 C0F20003 		movt	r3, #:upper16:xTickCount
 2339 006c 1A68     		ldr	r2, [r3]
 2340 006e 3B68     		ldr	r3, [r7]
 2341 0070 1344     		add	r3, r3, r2
 2342 0072 FB60     		str	r3, [r7, #12]
1666:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2343              		.loc 1 1666 0
 2344 0074 F868     		ldr	r0, [r7, #12]
 2345 0076 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2346              	.L130:
1667:../FreeRTOS/Source/tasks.c **** 		}
1668:../FreeRTOS/Source/tasks.c **** 	}
1669:../FreeRTOS/Source/tasks.c **** 	#else
1670:../FreeRTOS/Source/tasks.c **** 	{
1671:../FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1672:../FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1673:../FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1674:../FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:../FreeRTOS/Source/tasks.c **** 	}
1676:../FreeRTOS/Source/tasks.c **** 	#endif
1677:../FreeRTOS/Source/tasks.c **** }
 2347              		.loc 1 1677 0
 2348 007a 1037     		adds	r7, r7, #16
 2349 007c BD46     		mov	sp, r7
 2350              		@ sp needed
 2351 007e 80BD     		pop	{r7, pc}
 2352              		.cfi_endproc
 2353              	.LFE19:
 2355              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2356              		.align	2
 2357              		.global	vTaskPlaceOnEventListRestricted
 2358              		.thumb
 2359              		.thumb_func
 2361              	vTaskPlaceOnEventListRestricted:
 2362              	.LFB20:
1678:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1679:../FreeRTOS/Source/tasks.c **** 
1680:../FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1681:../FreeRTOS/Source/tasks.c **** 
1682:../FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:../FreeRTOS/Source/tasks.c **** 	{
 2363              		.loc 1 1683 0
 2364              		.cfi_startproc
 2365              		@ args = 0, pretend = 0, frame = 16
 2366              		@ frame_needed = 1, uses_anonymous_args = 0
 2367 0000 80B5     		push	{r7, lr}
 2368              		.cfi_def_cfa_offset 8
 2369              		.cfi_offset 7, -8
 2370              		.cfi_offset 14, -4
 2371 0002 84B0     		sub	sp, sp, #16
 2372              		.cfi_def_cfa_offset 24
 2373 0004 00AF     		add	r7, sp, #0
 2374              		.cfi_def_cfa_register 7
 2375 0006 7860     		str	r0, [r7, #4]
 2376 0008 3960     		str	r1, [r7]
1684:../FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1685:../FreeRTOS/Source/tasks.c **** 
1686:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
 2377              		.loc 1 1686 0
 2378 000a 7B68     		ldr	r3, [r7, #4]
 2379 000c 002B     		cmp	r3, #0
 2380 000e 04D1     		bne	.L136
 2381              		.loc 1 1686 0 is_stmt 0 discriminator 1
 2382              	@ 1686 "../FreeRTOS/Source/tasks.c" 1
 2383 0010 4FF05000 			mov r0, #80								
 2384 0014 80F31188 		msr basepri, r0							
 2385              	
 2386              	@ 0 "" 2
 2387              		.thumb
 2388              	.L137:
 2389 0018 FEE7     		b	.L137
 2390              	.L136:
1687:../FreeRTOS/Source/tasks.c **** 
1688:../FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1689:../FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1690:../FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1691:../FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1692:../FreeRTOS/Source/tasks.c **** 
1693:../FreeRTOS/Source/tasks.c **** 	
1694:../FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1695:../FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1696:../FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1697:../FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1698:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2391              		.loc 1 1698 0 is_stmt 1
 2392 001a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2393 001e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2394 0022 1B68     		ldr	r3, [r3]
 2395 0024 1833     		adds	r3, r3, #24
 2396 0026 7868     		ldr	r0, [r7, #4]
 2397 0028 1946     		mov	r1, r3
 2398 002a FFF7FEFF 		bl	vListInsertEnd
1699:../FreeRTOS/Source/tasks.c **** 
1700:../FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1701:../FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1702:../FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1703:../FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2399              		.loc 1 1703 0
 2400 002e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2401 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2402 0036 1B68     		ldr	r3, [r3]
 2403 0038 0433     		adds	r3, r3, #4
 2404 003a 1846     		mov	r0, r3
 2405 003c FFF7FEFF 		bl	vListRemove
1704:../FreeRTOS/Source/tasks.c **** 
1705:../FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1706:../FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1707:../FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2406              		.loc 1 1707 0
 2407 0040 40F20003 		movw	r3, #:lower16:xTickCount
 2408 0044 C0F20003 		movt	r3, #:upper16:xTickCount
 2409 0048 1A68     		ldr	r2, [r3]
 2410 004a 3B68     		ldr	r3, [r7]
 2411 004c 1344     		add	r3, r3, r2
 2412 004e FB60     		str	r3, [r7, #12]
1708:../FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2413              		.loc 1 1708 0
 2414 0050 F868     		ldr	r0, [r7, #12]
 2415 0052 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1709:../FreeRTOS/Source/tasks.c **** 	}
 2416              		.loc 1 1709 0
 2417 0056 1037     		adds	r7, r7, #16
 2418 0058 BD46     		mov	sp, r7
 2419              		@ sp needed
 2420 005a 80BD     		pop	{r7, pc}
 2421              		.cfi_endproc
 2422              	.LFE20:
 2424              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2425              		.align	2
 2426              		.global	xTaskRemoveFromEventList
 2427              		.thumb
 2428              		.thumb_func
 2430              	xTaskRemoveFromEventList:
 2431              	.LFB21:
1710:../FreeRTOS/Source/tasks.c **** 	
1711:../FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1712:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1713:../FreeRTOS/Source/tasks.c **** 
1714:../FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:../FreeRTOS/Source/tasks.c **** {
 2432              		.loc 1 1715 0
 2433              		.cfi_startproc
 2434              		@ args = 0, pretend = 0, frame = 16
 2435              		@ frame_needed = 1, uses_anonymous_args = 0
 2436 0000 80B5     		push	{r7, lr}
 2437              		.cfi_def_cfa_offset 8
 2438              		.cfi_offset 7, -8
 2439              		.cfi_offset 14, -4
 2440 0002 84B0     		sub	sp, sp, #16
 2441              		.cfi_def_cfa_offset 24
 2442 0004 00AF     		add	r7, sp, #0
 2443              		.cfi_def_cfa_register 7
 2444 0006 7860     		str	r0, [r7, #4]
1716:../FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1717:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1718:../FreeRTOS/Source/tasks.c **** 
1719:../FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:../FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:../FreeRTOS/Source/tasks.c **** 
1722:../FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1723:../FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1724:../FreeRTOS/Source/tasks.c **** 	it to the ready list.
1725:../FreeRTOS/Source/tasks.c **** 
1726:../FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1727:../FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1728:../FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1729:../FreeRTOS/Source/tasks.c **** 	
1730:../FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1731:../FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1732:../FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2445              		.loc 1 1732 0
 2446 0008 7B68     		ldr	r3, [r7, #4]
 2447 000a DB68     		ldr	r3, [r3, #12]
 2448 000c DB68     		ldr	r3, [r3, #12]
 2449 000e BB60     		str	r3, [r7, #8]
1733:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2450              		.loc 1 1733 0
 2451 0010 BB68     		ldr	r3, [r7, #8]
 2452 0012 002B     		cmp	r3, #0
 2453 0014 04D1     		bne	.L139
 2454              		.loc 1 1733 0 is_stmt 0 discriminator 1
 2455              	@ 1733 "../FreeRTOS/Source/tasks.c" 1
 2456 0016 4FF05000 			mov r0, #80								
 2457 001a 80F31188 		msr basepri, r0							
 2458              	
 2459              	@ 0 "" 2
 2460              		.thumb
 2461              	.L140:
 2462 001e FEE7     		b	.L140
 2463              	.L139:
1734:../FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2464              		.loc 1 1734 0 is_stmt 1
 2465 0020 BB68     		ldr	r3, [r7, #8]
 2466 0022 1833     		adds	r3, r3, #24
 2467 0024 1846     		mov	r0, r3
 2468 0026 FFF7FEFF 		bl	vListRemove
1735:../FreeRTOS/Source/tasks.c **** 
1736:../FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2469              		.loc 1 1736 0
 2470 002a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2471 002e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2472 0032 1B68     		ldr	r3, [r3]
 2473 0034 002B     		cmp	r3, #0
 2474 0036 26D1     		bne	.L141
1737:../FreeRTOS/Source/tasks.c **** 	{
1738:../FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2475              		.loc 1 1738 0
 2476 0038 BB68     		ldr	r3, [r7, #8]
 2477 003a 0433     		adds	r3, r3, #4
 2478 003c 1846     		mov	r0, r3
 2479 003e FFF7FEFF 		bl	vListRemove
1739:../FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2480              		.loc 1 1739 0
 2481 0042 BB68     		ldr	r3, [r7, #8]
 2482 0044 DA6A     		ldr	r2, [r3, #44]
 2483 0046 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2484 004a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2485 004e 1B68     		ldr	r3, [r3]
 2486 0050 9A42     		cmp	r2, r3
 2487 0052 06D9     		bls	.L142
 2488              		.loc 1 1739 0 is_stmt 0 discriminator 1
 2489 0054 BB68     		ldr	r3, [r7, #8]
 2490 0056 DA6A     		ldr	r2, [r3, #44]
 2491 0058 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2492 005c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2493 0060 1A60     		str	r2, [r3]
 2494              	.L142:
 2495              		.loc 1 1739 0 discriminator 2
 2496 0062 BB68     		ldr	r3, [r7, #8]
 2497 0064 DA6A     		ldr	r2, [r3, #44]
 2498 0066 1346     		mov	r3, r2
 2499 0068 9B00     		lsls	r3, r3, #2
 2500 006a 1344     		add	r3, r3, r2
 2501 006c 9B00     		lsls	r3, r3, #2
 2502 006e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2503 0072 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2504 0076 1A44     		add	r2, r2, r3
 2505 0078 BB68     		ldr	r3, [r7, #8]
 2506 007a 0433     		adds	r3, r3, #4
 2507 007c 1046     		mov	r0, r2
 2508 007e 1946     		mov	r1, r3
 2509 0080 FFF7FEFF 		bl	vListInsertEnd
 2510 0084 08E0     		b	.L143
 2511              	.L141:
1740:../FreeRTOS/Source/tasks.c **** 	}
1741:../FreeRTOS/Source/tasks.c **** 	else
1742:../FreeRTOS/Source/tasks.c **** 	{
1743:../FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1744:../FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1745:../FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2512              		.loc 1 1745 0 is_stmt 1
 2513 0086 BB68     		ldr	r3, [r7, #8]
 2514 0088 1833     		adds	r3, r3, #24
 2515 008a 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2516 008e C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2517 0092 1946     		mov	r1, r3
 2518 0094 FFF7FEFF 		bl	vListInsertEnd
 2519              	.L143:
1746:../FreeRTOS/Source/tasks.c **** 	}
1747:../FreeRTOS/Source/tasks.c **** 
1748:../FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2520              		.loc 1 1748 0
 2521 0098 BB68     		ldr	r3, [r7, #8]
 2522 009a DA6A     		ldr	r2, [r3, #44]
 2523 009c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2524 00a0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2525 00a4 1B68     		ldr	r3, [r3]
 2526 00a6 DB6A     		ldr	r3, [r3, #44]
 2527 00a8 9A42     		cmp	r2, r3
 2528 00aa 02D3     		bcc	.L144
1749:../FreeRTOS/Source/tasks.c **** 	{
1750:../FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1751:../FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1752:../FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1753:../FreeRTOS/Source/tasks.c **** 		switch now. */
1754:../FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2529              		.loc 1 1754 0
 2530 00ac 0123     		movs	r3, #1
 2531 00ae FB60     		str	r3, [r7, #12]
 2532 00b0 01E0     		b	.L145
 2533              	.L144:
1755:../FreeRTOS/Source/tasks.c **** 	}
1756:../FreeRTOS/Source/tasks.c **** 	else
1757:../FreeRTOS/Source/tasks.c **** 	{
1758:../FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2534              		.loc 1 1758 0
 2535 00b2 0023     		movs	r3, #0
 2536 00b4 FB60     		str	r3, [r7, #12]
 2537              	.L145:
1759:../FreeRTOS/Source/tasks.c **** 	}
1760:../FreeRTOS/Source/tasks.c **** 
1761:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2538              		.loc 1 1761 0
 2539 00b6 FB68     		ldr	r3, [r7, #12]
1762:../FreeRTOS/Source/tasks.c **** }
 2540              		.loc 1 1762 0
 2541 00b8 1846     		mov	r0, r3
 2542 00ba 1037     		adds	r7, r7, #16
 2543 00bc BD46     		mov	sp, r7
 2544              		@ sp needed
 2545 00be 80BD     		pop	{r7, pc}
 2546              		.cfi_endproc
 2547              	.LFE21:
 2549              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2550              		.align	2
 2551              		.global	vTaskSetTimeOutState
 2552              		.thumb
 2553              		.thumb_func
 2555              	vTaskSetTimeOutState:
 2556              	.LFB22:
1763:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:../FreeRTOS/Source/tasks.c **** 
1765:../FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:../FreeRTOS/Source/tasks.c **** {
 2557              		.loc 1 1766 0
 2558              		.cfi_startproc
 2559              		@ args = 0, pretend = 0, frame = 8
 2560              		@ frame_needed = 1, uses_anonymous_args = 0
 2561              		@ link register save eliminated.
 2562 0000 80B4     		push	{r7}
 2563              		.cfi_def_cfa_offset 4
 2564              		.cfi_offset 7, -4
 2565 0002 83B0     		sub	sp, sp, #12
 2566              		.cfi_def_cfa_offset 16
 2567 0004 00AF     		add	r7, sp, #0
 2568              		.cfi_def_cfa_register 7
 2569 0006 7860     		str	r0, [r7, #4]
1767:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2570              		.loc 1 1767 0
 2571 0008 7B68     		ldr	r3, [r7, #4]
 2572 000a 002B     		cmp	r3, #0
 2573 000c 04D1     		bne	.L148
 2574              		.loc 1 1767 0 is_stmt 0 discriminator 1
 2575              	@ 1767 "../FreeRTOS/Source/tasks.c" 1
 2576 000e 4FF05000 			mov r0, #80								
 2577 0012 80F31188 		msr basepri, r0							
 2578              	
 2579              	@ 0 "" 2
 2580              		.thumb
 2581              	.L149:
 2582 0016 FEE7     		b	.L149
 2583              	.L148:
1768:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2584              		.loc 1 1768 0 is_stmt 1
 2585 0018 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2586 001c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2587 0020 1A68     		ldr	r2, [r3]
 2588 0022 7B68     		ldr	r3, [r7, #4]
 2589 0024 1A60     		str	r2, [r3]
1769:../FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2590              		.loc 1 1769 0
 2591 0026 40F20003 		movw	r3, #:lower16:xTickCount
 2592 002a C0F20003 		movt	r3, #:upper16:xTickCount
 2593 002e 1A68     		ldr	r2, [r3]
 2594 0030 7B68     		ldr	r3, [r7, #4]
 2595 0032 5A60     		str	r2, [r3, #4]
1770:../FreeRTOS/Source/tasks.c **** }
 2596              		.loc 1 1770 0
 2597 0034 0C37     		adds	r7, r7, #12
 2598 0036 BD46     		mov	sp, r7
 2599              		@ sp needed
 2600 0038 5DF8047B 		ldr	r7, [sp], #4
 2601 003c 7047     		bx	lr
 2602              		.cfi_endproc
 2603              	.LFE22:
 2605 003e 00BF     		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2606              		.align	2
 2607              		.global	xTaskCheckForTimeOut
 2608              		.thumb
 2609              		.thumb_func
 2611              	xTaskCheckForTimeOut:
 2612              	.LFB23:
1771:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1772:../FreeRTOS/Source/tasks.c **** 
1773:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1774:../FreeRTOS/Source/tasks.c **** {
 2613              		.loc 1 1774 0
 2614              		.cfi_startproc
 2615              		@ args = 0, pretend = 0, frame = 16
 2616              		@ frame_needed = 1, uses_anonymous_args = 0
 2617 0000 80B5     		push	{r7, lr}
 2618              		.cfi_def_cfa_offset 8
 2619              		.cfi_offset 7, -8
 2620              		.cfi_offset 14, -4
 2621 0002 84B0     		sub	sp, sp, #16
 2622              		.cfi_def_cfa_offset 24
 2623 0004 00AF     		add	r7, sp, #0
 2624              		.cfi_def_cfa_register 7
 2625 0006 7860     		str	r0, [r7, #4]
 2626 0008 3960     		str	r1, [r7]
1775:../FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1776:../FreeRTOS/Source/tasks.c **** 
1777:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2627              		.loc 1 1777 0
 2628 000a 7B68     		ldr	r3, [r7, #4]
 2629 000c 002B     		cmp	r3, #0
 2630 000e 04D1     		bne	.L151
 2631              		.loc 1 1777 0 is_stmt 0 discriminator 1
 2632              	@ 1777 "../FreeRTOS/Source/tasks.c" 1
 2633 0010 4FF05000 			mov r0, #80								
 2634 0014 80F31188 		msr basepri, r0							
 2635              	
 2636              	@ 0 "" 2
 2637              		.thumb
 2638              	.L152:
 2639 0018 FEE7     		b	.L152
 2640              	.L151:
1778:../FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
 2641              		.loc 1 1778 0 is_stmt 1
 2642 001a 3B68     		ldr	r3, [r7]
 2643 001c 002B     		cmp	r3, #0
 2644 001e 04D1     		bne	.L153
 2645              		.loc 1 1778 0 is_stmt 0 discriminator 1
 2646              	@ 1778 "../FreeRTOS/Source/tasks.c" 1
 2647 0020 4FF05000 			mov r0, #80								
 2648 0024 80F31188 		msr basepri, r0							
 2649              	
 2650              	@ 0 "" 2
 2651              		.thumb
 2652              	.L154:
 2653 0028 FEE7     		b	.L154
 2654              	.L153:
1779:../FreeRTOS/Source/tasks.c **** 
1780:../FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2655              		.loc 1 1780 0 is_stmt 1
 2656 002a FFF7FEFF 		bl	vPortEnterCritical
1781:../FreeRTOS/Source/tasks.c **** 	{
1782:../FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1783:../FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:../FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1785:../FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1786:../FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2657              		.loc 1 1786 0
 2658 002e 3B68     		ldr	r3, [r7]
 2659 0030 1B68     		ldr	r3, [r3]
 2660 0032 B3F1FF3F 		cmp	r3, #-1
 2661 0036 02D1     		bne	.L155
1787:../FreeRTOS/Source/tasks.c **** 			{
1788:../FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2662              		.loc 1 1788 0
 2663 0038 0023     		movs	r3, #0
 2664 003a FB60     		str	r3, [r7, #12]
 2665 003c 35E0     		b	.L156
 2666              	.L155:
1789:../FreeRTOS/Source/tasks.c **** 			}
1790:../FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1791:../FreeRTOS/Source/tasks.c **** 		#endif
1792:../FreeRTOS/Source/tasks.c **** 
1793:../FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2667              		.loc 1 1793 0
 2668 003e 7B68     		ldr	r3, [r7, #4]
 2669 0040 1A68     		ldr	r2, [r3]
 2670 0042 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2671 0046 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2672 004a 1B68     		ldr	r3, [r3]
 2673 004c 9A42     		cmp	r2, r3
 2674 004e 0BD0     		beq	.L157
 2675              		.loc 1 1793 0 is_stmt 0 discriminator 1
 2676 0050 7B68     		ldr	r3, [r7, #4]
 2677 0052 5A68     		ldr	r2, [r3, #4]
 2678 0054 40F20003 		movw	r3, #:lower16:xTickCount
 2679 0058 C0F20003 		movt	r3, #:upper16:xTickCount
 2680 005c 1B68     		ldr	r3, [r3]
 2681 005e 9A42     		cmp	r2, r3
 2682 0060 02D8     		bhi	.L157
1794:../FreeRTOS/Source/tasks.c **** 		{
1795:../FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:../FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:../FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1798:../FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1799:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2683              		.loc 1 1799 0 is_stmt 1
 2684 0062 0123     		movs	r3, #1
 2685 0064 FB60     		str	r3, [r7, #12]
 2686 0066 20E0     		b	.L156
 2687              	.L157:
1800:../FreeRTOS/Source/tasks.c **** 		}
1801:../FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2688              		.loc 1 1801 0
 2689 0068 40F20003 		movw	r3, #:lower16:xTickCount
 2690 006c C0F20003 		movt	r3, #:upper16:xTickCount
 2691 0070 1A68     		ldr	r2, [r3]
 2692 0072 7B68     		ldr	r3, [r7, #4]
 2693 0074 5B68     		ldr	r3, [r3, #4]
 2694 0076 D21A     		subs	r2, r2, r3
 2695 0078 3B68     		ldr	r3, [r7]
 2696 007a 1B68     		ldr	r3, [r3]
 2697 007c 9A42     		cmp	r2, r3
 2698 007e 12D2     		bcs	.L158
1802:../FreeRTOS/Source/tasks.c **** 		{
1803:../FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:../FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2699              		.loc 1 1804 0
 2700 0080 3B68     		ldr	r3, [r7]
 2701 0082 1A68     		ldr	r2, [r3]
 2702 0084 7B68     		ldr	r3, [r7, #4]
 2703 0086 5968     		ldr	r1, [r3, #4]
 2704 0088 40F20003 		movw	r3, #:lower16:xTickCount
 2705 008c C0F20003 		movt	r3, #:upper16:xTickCount
 2706 0090 1B68     		ldr	r3, [r3]
 2707 0092 CB1A     		subs	r3, r1, r3
 2708 0094 1A44     		add	r2, r2, r3
 2709 0096 3B68     		ldr	r3, [r7]
 2710 0098 1A60     		str	r2, [r3]
1805:../FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2711              		.loc 1 1805 0
 2712 009a 7868     		ldr	r0, [r7, #4]
 2713 009c FFF7FEFF 		bl	vTaskSetTimeOutState
1806:../FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2714              		.loc 1 1806 0
 2715 00a0 0023     		movs	r3, #0
 2716 00a2 FB60     		str	r3, [r7, #12]
 2717 00a4 01E0     		b	.L156
 2718              	.L158:
1807:../FreeRTOS/Source/tasks.c **** 		}
1808:../FreeRTOS/Source/tasks.c **** 		else
1809:../FreeRTOS/Source/tasks.c **** 		{
1810:../FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2719              		.loc 1 1810 0
 2720 00a6 0123     		movs	r3, #1
 2721 00a8 FB60     		str	r3, [r7, #12]
 2722              	.L156:
1811:../FreeRTOS/Source/tasks.c **** 		}
1812:../FreeRTOS/Source/tasks.c **** 	}
1813:../FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2723              		.loc 1 1813 0
 2724 00aa FFF7FEFF 		bl	vPortExitCritical
1814:../FreeRTOS/Source/tasks.c **** 
1815:../FreeRTOS/Source/tasks.c **** 	return xReturn;
 2725              		.loc 1 1815 0
 2726 00ae FB68     		ldr	r3, [r7, #12]
1816:../FreeRTOS/Source/tasks.c **** }
 2727              		.loc 1 1816 0
 2728 00b0 1846     		mov	r0, r3
 2729 00b2 1037     		adds	r7, r7, #16
 2730 00b4 BD46     		mov	sp, r7
 2731              		@ sp needed
 2732 00b6 80BD     		pop	{r7, pc}
 2733              		.cfi_endproc
 2734              	.LFE23:
 2736              		.section	.text.vTaskMissedYield,"ax",%progbits
 2737              		.align	2
 2738              		.global	vTaskMissedYield
 2739              		.thumb
 2740              		.thumb_func
 2742              	vTaskMissedYield:
 2743              	.LFB24:
1817:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1818:../FreeRTOS/Source/tasks.c **** 
1819:../FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1820:../FreeRTOS/Source/tasks.c **** {
 2744              		.loc 1 1820 0
 2745              		.cfi_startproc
 2746              		@ args = 0, pretend = 0, frame = 0
 2747              		@ frame_needed = 1, uses_anonymous_args = 0
 2748              		@ link register save eliminated.
 2749 0000 80B4     		push	{r7}
 2750              		.cfi_def_cfa_offset 4
 2751              		.cfi_offset 7, -4
 2752 0002 00AF     		add	r7, sp, #0
 2753              		.cfi_def_cfa_register 7
1821:../FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2754              		.loc 1 1821 0
 2755 0004 40F20003 		movw	r3, #:lower16:xMissedYield
 2756 0008 C0F20003 		movt	r3, #:upper16:xMissedYield
 2757 000c 0122     		movs	r2, #1
 2758 000e 1A60     		str	r2, [r3]
1822:../FreeRTOS/Source/tasks.c **** }
 2759              		.loc 1 1822 0
 2760 0010 BD46     		mov	sp, r7
 2761              		@ sp needed
 2762 0012 5DF8047B 		ldr	r7, [sp], #4
 2763 0016 7047     		bx	lr
 2764              		.cfi_endproc
 2765              	.LFE24:
 2767              		.section	.text.prvIdleTask,"ax",%progbits
 2768              		.align	2
 2769              		.thumb
 2770              		.thumb_func
 2772              	prvIdleTask:
 2773              	.LFB25:
1823:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1824:../FreeRTOS/Source/tasks.c **** 
1825:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1826:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:../FreeRTOS/Source/tasks.c **** 	{
1828:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1829:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1830:../FreeRTOS/Source/tasks.c **** 	
1831:../FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
1832:../FreeRTOS/Source/tasks.c **** 		{
1833:../FreeRTOS/Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
1834:../FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
1835:../FreeRTOS/Source/tasks.c **** 		}
1836:../FreeRTOS/Source/tasks.c **** 		else
1837:../FreeRTOS/Source/tasks.c **** 		{
1838:../FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
1839:../FreeRTOS/Source/tasks.c **** 		}
1840:../FreeRTOS/Source/tasks.c **** 		
1841:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
1842:../FreeRTOS/Source/tasks.c **** 	}
1843:../FreeRTOS/Source/tasks.c **** #endif
1844:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1845:../FreeRTOS/Source/tasks.c **** 
1846:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1847:../FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:../FreeRTOS/Source/tasks.c **** 	{
1849:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1850:../FreeRTOS/Source/tasks.c **** 	
1851:../FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
1852:../FreeRTOS/Source/tasks.c **** 		{
1853:../FreeRTOS/Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
1854:../FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
1855:../FreeRTOS/Source/tasks.c **** 		}
1856:../FreeRTOS/Source/tasks.c **** 	}
1857:../FreeRTOS/Source/tasks.c **** #endif
1858:../FreeRTOS/Source/tasks.c **** 
1859:../FreeRTOS/Source/tasks.c **** 
1860:../FreeRTOS/Source/tasks.c **** /*
1861:../FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1862:../FreeRTOS/Source/tasks.c ****  * The Idle task.
1863:../FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1864:../FreeRTOS/Source/tasks.c ****  *
1865:../FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:../FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1867:../FreeRTOS/Source/tasks.c ****  *
1868:../FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1869:../FreeRTOS/Source/tasks.c ****  *
1870:../FreeRTOS/Source/tasks.c ****  */
1871:../FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:../FreeRTOS/Source/tasks.c **** {
 2774              		.loc 1 1872 0
 2775              		.cfi_startproc
 2776              		@ args = 0, pretend = 0, frame = 8
 2777              		@ frame_needed = 1, uses_anonymous_args = 0
 2778 0000 80B5     		push	{r7, lr}
 2779              		.cfi_def_cfa_offset 8
 2780              		.cfi_offset 7, -8
 2781              		.cfi_offset 14, -4
 2782 0002 82B0     		sub	sp, sp, #8
 2783              		.cfi_def_cfa_offset 16
 2784 0004 00AF     		add	r7, sp, #0
 2785              		.cfi_def_cfa_register 7
 2786 0006 7860     		str	r0, [r7, #4]
 2787              	.L163:
1873:../FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1874:../FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1875:../FreeRTOS/Source/tasks.c **** 
1876:../FreeRTOS/Source/tasks.c **** 	for( ;; )
1877:../FreeRTOS/Source/tasks.c **** 	{
1878:../FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1879:../FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2788              		.loc 1 1879 0
 2789 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
1880:../FreeRTOS/Source/tasks.c **** 
1881:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1882:../FreeRTOS/Source/tasks.c **** 		{
1883:../FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1884:../FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1885:../FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1886:../FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1887:../FreeRTOS/Source/tasks.c **** 			taskYIELD();
1888:../FreeRTOS/Source/tasks.c **** 		}
1889:../FreeRTOS/Source/tasks.c **** 		#endif
1890:../FreeRTOS/Source/tasks.c **** 
1891:../FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:../FreeRTOS/Source/tasks.c **** 		{
1893:../FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1894:../FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1895:../FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1896:../FreeRTOS/Source/tasks.c **** 			timeslice.
1897:../FreeRTOS/Source/tasks.c **** 
1898:../FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1899:../FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1900:../FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1901:../FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1902:../FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2790              		.loc 1 1902 0
 2791 000c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 2792 0010 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 2793 0014 1B68     		ldr	r3, [r3]
 2794 0016 012B     		cmp	r3, #1
 2795 0018 02D9     		bls	.L162
1903:../FreeRTOS/Source/tasks.c **** 			{
1904:../FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2796              		.loc 1 1904 0
 2797 001a FFF7FEFF 		bl	vPortYieldFromISR
1905:../FreeRTOS/Source/tasks.c **** 			}
1906:../FreeRTOS/Source/tasks.c **** 		}
1907:../FreeRTOS/Source/tasks.c **** 		#endif
1908:../FreeRTOS/Source/tasks.c **** 
1909:../FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1910:../FreeRTOS/Source/tasks.c **** 		{
1911:../FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1912:../FreeRTOS/Source/tasks.c **** 
1913:../FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1914:../FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1915:../FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1916:../FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:../FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:../FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1919:../FreeRTOS/Source/tasks.c **** 		}
1920:../FreeRTOS/Source/tasks.c **** 		#endif
1921:../FreeRTOS/Source/tasks.c **** 	}
 2798              		.loc 1 1921 0
 2799 001e F3E7     		b	.L163
 2800              	.L162:
 2801 0020 F2E7     		b	.L163
 2802              		.cfi_endproc
 2803              	.LFE25:
 2805 0022 00BF     		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2806              		.align	2
 2807              		.thumb
 2808              		.thumb_func
 2810              	prvInitialiseTCBVariables:
 2811              	.LFB26:
1922:../FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:../FreeRTOS/Source/tasks.c **** 
1924:../FreeRTOS/Source/tasks.c **** 
1925:../FreeRTOS/Source/tasks.c **** 
1926:../FreeRTOS/Source/tasks.c **** 
1927:../FreeRTOS/Source/tasks.c **** 
1928:../FreeRTOS/Source/tasks.c **** 
1929:../FreeRTOS/Source/tasks.c **** 
1930:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1931:../FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1932:../FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1933:../FreeRTOS/Source/tasks.c **** 
1934:../FreeRTOS/Source/tasks.c **** 
1935:../FreeRTOS/Source/tasks.c **** 
1936:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1937:../FreeRTOS/Source/tasks.c **** {
 2812              		.loc 1 1937 0
 2813              		.cfi_startproc
 2814              		@ args = 4, pretend = 0, frame = 16
 2815              		@ frame_needed = 1, uses_anonymous_args = 0
 2816 0000 80B5     		push	{r7, lr}
 2817              		.cfi_def_cfa_offset 8
 2818              		.cfi_offset 7, -8
 2819              		.cfi_offset 14, -4
 2820 0002 84B0     		sub	sp, sp, #16
 2821              		.cfi_def_cfa_offset 24
 2822 0004 00AF     		add	r7, sp, #0
 2823              		.cfi_def_cfa_register 7
 2824 0006 F860     		str	r0, [r7, #12]
 2825 0008 B960     		str	r1, [r7, #8]
 2826 000a 7A60     		str	r2, [r7, #4]
 2827 000c 3B60     		str	r3, [r7]
1938:../FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1939:../FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1940:../FreeRTOS/Source/tasks.c **** 	{
1941:../FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1942:../FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2828              		.loc 1 1942 0
 2829 000e FB68     		ldr	r3, [r7, #12]
 2830 0010 3433     		adds	r3, r3, #52
 2831 0012 1846     		mov	r0, r3
 2832 0014 B968     		ldr	r1, [r7, #8]
 2833 0016 0A22     		movs	r2, #10
 2834 0018 FFF7FEFF 		bl	strncpy
1943:../FreeRTOS/Source/tasks.c **** 	}
1944:../FreeRTOS/Source/tasks.c **** 	#endif
1945:../FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2835              		.loc 1 1945 0
 2836 001c FB68     		ldr	r3, [r7, #12]
 2837 001e 0022     		movs	r2, #0
 2838 0020 83F83D20 		strb	r2, [r3, #61]
1946:../FreeRTOS/Source/tasks.c **** 
1947:../FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1948:../FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1949:../FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 2839              		.loc 1 1949 0
 2840 0024 7B68     		ldr	r3, [r7, #4]
 2841 0026 042B     		cmp	r3, #4
 2842 0028 01D9     		bls	.L165
1950:../FreeRTOS/Source/tasks.c **** 	{
1951:../FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 2843              		.loc 1 1951 0
 2844 002a 0423     		movs	r3, #4
 2845 002c 7B60     		str	r3, [r7, #4]
 2846              	.L165:
1952:../FreeRTOS/Source/tasks.c **** 	}
1953:../FreeRTOS/Source/tasks.c **** 
1954:../FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 2847              		.loc 1 1954 0
 2848 002e FB68     		ldr	r3, [r7, #12]
 2849 0030 7A68     		ldr	r2, [r7, #4]
 2850 0032 DA62     		str	r2, [r3, #44]
1955:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1956:../FreeRTOS/Source/tasks.c **** 	{
1957:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 2851              		.loc 1 1957 0
 2852 0034 FB68     		ldr	r3, [r7, #12]
 2853 0036 7A68     		ldr	r2, [r7, #4]
 2854 0038 1A64     		str	r2, [r3, #64]
1958:../FreeRTOS/Source/tasks.c **** 	}
1959:../FreeRTOS/Source/tasks.c **** 	#endif
1960:../FreeRTOS/Source/tasks.c **** 
1961:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 2855              		.loc 1 1961 0
 2856 003a FB68     		ldr	r3, [r7, #12]
 2857 003c 0433     		adds	r3, r3, #4
 2858 003e 1846     		mov	r0, r3
 2859 0040 FFF7FEFF 		bl	vListInitialiseItem
1962:../FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 2860              		.loc 1 1962 0
 2861 0044 FB68     		ldr	r3, [r7, #12]
 2862 0046 1833     		adds	r3, r3, #24
 2863 0048 1846     		mov	r0, r3
 2864 004a FFF7FEFF 		bl	vListInitialiseItem
1963:../FreeRTOS/Source/tasks.c **** 
1964:../FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:../FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1966:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 2865              		.loc 1 1966 0
 2866 004e FB68     		ldr	r3, [r7, #12]
 2867 0050 FA68     		ldr	r2, [r7, #12]
 2868 0052 1A61     		str	r2, [r3, #16]
1967:../FreeRTOS/Source/tasks.c **** 
1968:../FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
1969:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 2869              		.loc 1 1969 0
 2870 0054 7B68     		ldr	r3, [r7, #4]
 2871 0056 C3F10502 		rsb	r2, r3, #5
 2872 005a FB68     		ldr	r3, [r7, #12]
 2873 005c 9A61     		str	r2, [r3, #24]
1970:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 2874              		.loc 1 1970 0
 2875 005e FB68     		ldr	r3, [r7, #12]
 2876 0060 FA68     		ldr	r2, [r7, #12]
 2877 0062 5A62     		str	r2, [r3, #36]
1971:../FreeRTOS/Source/tasks.c **** 
1972:../FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:../FreeRTOS/Source/tasks.c **** 	{
1974:../FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:../FreeRTOS/Source/tasks.c **** 	}
1976:../FreeRTOS/Source/tasks.c **** 	#endif
1977:../FreeRTOS/Source/tasks.c **** 
1978:../FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:../FreeRTOS/Source/tasks.c **** 	{
1980:../FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1981:../FreeRTOS/Source/tasks.c **** 	}
1982:../FreeRTOS/Source/tasks.c **** 	#endif
1983:../FreeRTOS/Source/tasks.c **** 
1984:../FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:../FreeRTOS/Source/tasks.c **** 	{
1986:../FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1987:../FreeRTOS/Source/tasks.c **** 	}
1988:../FreeRTOS/Source/tasks.c **** 	#endif
1989:../FreeRTOS/Source/tasks.c **** 
1990:../FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:../FreeRTOS/Source/tasks.c **** 	{
1992:../FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:../FreeRTOS/Source/tasks.c **** 	}
1994:../FreeRTOS/Source/tasks.c **** 	#else
1995:../FreeRTOS/Source/tasks.c **** 	{
1996:../FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
1997:../FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
1998:../FreeRTOS/Source/tasks.c **** 	}
1999:../FreeRTOS/Source/tasks.c **** 	#endif
2000:../FreeRTOS/Source/tasks.c **** }
 2878              		.loc 1 2000 0
 2879 0064 1037     		adds	r7, r7, #16
 2880 0066 BD46     		mov	sp, r7
 2881              		@ sp needed
 2882 0068 80BD     		pop	{r7, pc}
 2883              		.cfi_endproc
 2884              	.LFE26:
 2886 006a 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 2887              		.align	2
 2888              		.thumb
 2889              		.thumb_func
 2891              	prvInitialiseTaskLists:
 2892              	.LFB27:
2001:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2002:../FreeRTOS/Source/tasks.c **** 
2003:../FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2004:../FreeRTOS/Source/tasks.c **** 
2005:../FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:../FreeRTOS/Source/tasks.c **** 	{
2007:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2008:../FreeRTOS/Source/tasks.c **** 	
2009:../FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2010:../FreeRTOS/Source/tasks.c **** 		{
2011:../FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2012:../FreeRTOS/Source/tasks.c **** 		}
2013:../FreeRTOS/Source/tasks.c **** 
2014:../FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2015:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:../FreeRTOS/Source/tasks.c **** 
2017:../FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:../FreeRTOS/Source/tasks.c **** 	}
2019:../FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2020:../FreeRTOS/Source/tasks.c **** #endif
2021:../FreeRTOS/Source/tasks.c **** 
2022:../FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2023:../FreeRTOS/Source/tasks.c **** {
 2893              		.loc 1 2023 0
 2894              		.cfi_startproc
 2895              		@ args = 0, pretend = 0, frame = 8
 2896              		@ frame_needed = 1, uses_anonymous_args = 0
 2897 0000 80B5     		push	{r7, lr}
 2898              		.cfi_def_cfa_offset 8
 2899              		.cfi_offset 7, -8
 2900              		.cfi_offset 14, -4
 2901 0002 82B0     		sub	sp, sp, #8
 2902              		.cfi_def_cfa_offset 16
 2903 0004 00AF     		add	r7, sp, #0
 2904              		.cfi_def_cfa_register 7
2024:../FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2025:../FreeRTOS/Source/tasks.c **** 
2026:../FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 2905              		.loc 1 2026 0
 2906 0006 0023     		movs	r3, #0
 2907 0008 7B60     		str	r3, [r7, #4]
 2908 000a 0FE0     		b	.L167
 2909              	.L168:
2027:../FreeRTOS/Source/tasks.c **** 	{
2028:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 2910              		.loc 1 2028 0 discriminator 2
 2911 000c 7A68     		ldr	r2, [r7, #4]
 2912 000e 1346     		mov	r3, r2
 2913 0010 9B00     		lsls	r3, r3, #2
 2914 0012 1344     		add	r3, r3, r2
 2915 0014 9B00     		lsls	r3, r3, #2
 2916 0016 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2917 001a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2918 001e 1344     		add	r3, r3, r2
 2919 0020 1846     		mov	r0, r3
 2920 0022 FFF7FEFF 		bl	vListInitialise
2026:../FreeRTOS/Source/tasks.c **** 	{
 2921              		.loc 1 2026 0 discriminator 2
 2922 0026 7B68     		ldr	r3, [r7, #4]
 2923 0028 0133     		adds	r3, r3, #1
 2924 002a 7B60     		str	r3, [r7, #4]
 2925              	.L167:
2026:../FreeRTOS/Source/tasks.c **** 	{
 2926              		.loc 1 2026 0 is_stmt 0 discriminator 1
 2927 002c 7B68     		ldr	r3, [r7, #4]
 2928 002e 042B     		cmp	r3, #4
 2929 0030 ECD9     		bls	.L168
2029:../FreeRTOS/Source/tasks.c **** 	}
2030:../FreeRTOS/Source/tasks.c **** 
2031:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 2930              		.loc 1 2031 0 is_stmt 1
 2931 0032 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 2932 0036 C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 2933 003a FFF7FEFF 		bl	vListInitialise
2032:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 2934              		.loc 1 2032 0
 2935 003e 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 2936 0042 C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 2937 0046 FFF7FEFF 		bl	vListInitialise
2033:../FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 2938              		.loc 1 2033 0
 2939 004a 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2940 004e C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2941 0052 FFF7FEFF 		bl	vListInitialise
2034:../FreeRTOS/Source/tasks.c **** 
2035:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2036:../FreeRTOS/Source/tasks.c **** 	{
2037:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 2942              		.loc 1 2037 0
 2943 0056 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 2944 005a C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 2945 005e FFF7FEFF 		bl	vListInitialise
2038:../FreeRTOS/Source/tasks.c **** 	}
2039:../FreeRTOS/Source/tasks.c **** 	#endif
2040:../FreeRTOS/Source/tasks.c **** 
2041:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2042:../FreeRTOS/Source/tasks.c **** 	{
2043:../FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 2946              		.loc 1 2043 0
 2947 0062 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2948 0066 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2949 006a FFF7FEFF 		bl	vListInitialise
2044:../FreeRTOS/Source/tasks.c **** 	}
2045:../FreeRTOS/Source/tasks.c **** 	#endif
2046:../FreeRTOS/Source/tasks.c **** 
2047:../FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:../FreeRTOS/Source/tasks.c **** 	using list2. */
2049:../FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 2950              		.loc 1 2049 0
 2951 006e 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2952 0072 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2953 0076 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 2954 007a C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 2955 007e 1A60     		str	r2, [r3]
2050:../FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 2956              		.loc 1 2050 0
 2957 0080 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2958 0084 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2959 0088 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 2960 008c C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 2961 0090 1A60     		str	r2, [r3]
2051:../FreeRTOS/Source/tasks.c **** }
 2962              		.loc 1 2051 0
 2963 0092 0837     		adds	r7, r7, #8
 2964 0094 BD46     		mov	sp, r7
 2965              		@ sp needed
 2966 0096 80BD     		pop	{r7, pc}
 2967              		.cfi_endproc
 2968              	.LFE27:
 2970              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 2971              		.align	2
 2972              		.thumb
 2973              		.thumb_func
 2975              	prvCheckTasksWaitingTermination:
 2976              	.LFB28:
2052:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2053:../FreeRTOS/Source/tasks.c **** 
2054:../FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2055:../FreeRTOS/Source/tasks.c **** {
 2977              		.loc 1 2055 0
 2978              		.cfi_startproc
 2979              		@ args = 0, pretend = 0, frame = 8
 2980              		@ frame_needed = 1, uses_anonymous_args = 0
 2981 0000 80B5     		push	{r7, lr}
 2982              		.cfi_def_cfa_offset 8
 2983              		.cfi_offset 7, -8
 2984              		.cfi_offset 14, -4
 2985 0002 82B0     		sub	sp, sp, #8
 2986              		.cfi_def_cfa_offset 16
 2987 0004 00AF     		add	r7, sp, #0
 2988              		.cfi_def_cfa_register 7
 2989              	.LBB7:
2056:../FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2057:../FreeRTOS/Source/tasks.c **** 	{
2058:../FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2059:../FreeRTOS/Source/tasks.c **** 
2060:../FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:../FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2062:../FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 2990              		.loc 1 2062 0
 2991 0006 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 2992 000a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 2993 000e 1B68     		ldr	r3, [r3]
 2994 0010 002B     		cmp	r3, #0
 2995 0012 3AD0     		beq	.L169
2063:../FreeRTOS/Source/tasks.c **** 		{
2064:../FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 2996              		.loc 1 2064 0
 2997 0014 FFF7FEFF 		bl	vTaskSuspendAll
2065:../FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 2998              		.loc 1 2065 0
 2999 0018 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3000 001c C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3001 0020 1B68     		ldr	r3, [r3]
 3002 0022 002B     		cmp	r3, #0
 3003 0024 14BF     		ite	ne
 3004 0026 0023     		movne	r3, #0
 3005 0028 0123     		moveq	r3, #1
 3006 002a DBB2     		uxtb	r3, r3
 3007 002c 7B60     		str	r3, [r7, #4]
2066:../FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 3008              		.loc 1 2066 0
 3009 002e FFF7FEFF 		bl	xTaskResumeAll
2067:../FreeRTOS/Source/tasks.c **** 
2068:../FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3010              		.loc 1 2068 0
 3011 0032 7B68     		ldr	r3, [r7, #4]
 3012 0034 002B     		cmp	r3, #0
 3013 0036 28D1     		bne	.L169
 3014              	.LBB8:
2069:../FreeRTOS/Source/tasks.c **** 			{
2070:../FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2071:../FreeRTOS/Source/tasks.c **** 
2072:../FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 3015              		.loc 1 2072 0
 3016 0038 FFF7FEFF 		bl	vPortEnterCritical
2073:../FreeRTOS/Source/tasks.c **** 				{
2074:../FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3017              		.loc 1 2074 0
 3018 003c 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3019 0040 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3020 0044 DB68     		ldr	r3, [r3, #12]
 3021 0046 DB68     		ldr	r3, [r3, #12]
 3022 0048 3B60     		str	r3, [r7]
2075:../FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3023              		.loc 1 2075 0
 3024 004a 3B68     		ldr	r3, [r7]
 3025 004c 0433     		adds	r3, r3, #4
 3026 004e 1846     		mov	r0, r3
 3027 0050 FFF7FEFF 		bl	vListRemove
2076:../FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3028              		.loc 1 2076 0
 3029 0054 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3030 0058 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3031 005c 1B68     		ldr	r3, [r3]
 3032 005e 5A1E     		subs	r2, r3, #1
 3033 0060 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3034 0064 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3035 0068 1A60     		str	r2, [r3]
2077:../FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 3036              		.loc 1 2077 0
 3037 006a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3038 006e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3039 0072 1B68     		ldr	r3, [r3]
 3040 0074 5A1E     		subs	r2, r3, #1
 3041 0076 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3042 007a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3043 007e 1A60     		str	r2, [r3]
2078:../FreeRTOS/Source/tasks.c **** 				}
2079:../FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 3044              		.loc 1 2079 0
 3045 0080 FFF7FEFF 		bl	vPortExitCritical
2080:../FreeRTOS/Source/tasks.c **** 
2081:../FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3046              		.loc 1 2081 0
 3047 0084 3868     		ldr	r0, [r7]
 3048 0086 FFF7FEFF 		bl	prvDeleteTCB
 3049              	.L169:
 3050              	.LBE8:
 3051              	.LBE7:
2082:../FreeRTOS/Source/tasks.c **** 			}
2083:../FreeRTOS/Source/tasks.c **** 		}
2084:../FreeRTOS/Source/tasks.c **** 	}
2085:../FreeRTOS/Source/tasks.c **** 	#endif
2086:../FreeRTOS/Source/tasks.c **** }
 3052              		.loc 1 2086 0
 3053 008a 0837     		adds	r7, r7, #8
 3054 008c BD46     		mov	sp, r7
 3055              		@ sp needed
 3056 008e 80BD     		pop	{r7, pc}
 3057              		.cfi_endproc
 3058              	.LFE28:
 3060              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3061              		.align	2
 3062              		.thumb
 3063              		.thumb_func
 3065              	prvAddCurrentTaskToDelayedList:
 3066              	.LFB29:
2087:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2088:../FreeRTOS/Source/tasks.c **** 
2089:../FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:../FreeRTOS/Source/tasks.c **** {
 3067              		.loc 1 2090 0
 3068              		.cfi_startproc
 3069              		@ args = 0, pretend = 0, frame = 8
 3070              		@ frame_needed = 1, uses_anonymous_args = 0
 3071 0000 80B5     		push	{r7, lr}
 3072              		.cfi_def_cfa_offset 8
 3073              		.cfi_offset 7, -8
 3074              		.cfi_offset 14, -4
 3075 0002 82B0     		sub	sp, sp, #8
 3076              		.cfi_def_cfa_offset 16
 3077 0004 00AF     		add	r7, sp, #0
 3078              		.cfi_def_cfa_register 7
 3079 0006 7860     		str	r0, [r7, #4]
2091:../FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2092:../FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3080              		.loc 1 2092 0
 3081 0008 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3082 000c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3083 0010 1B68     		ldr	r3, [r3]
 3084 0012 7A68     		ldr	r2, [r7, #4]
 3085 0014 5A60     		str	r2, [r3, #4]
2093:../FreeRTOS/Source/tasks.c **** 
2094:../FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3086              		.loc 1 2094 0
 3087 0016 40F20003 		movw	r3, #:lower16:xTickCount
 3088 001a C0F20003 		movt	r3, #:upper16:xTickCount
 3089 001e 1B68     		ldr	r3, [r3]
 3090 0020 7A68     		ldr	r2, [r7, #4]
 3091 0022 9A42     		cmp	r2, r3
 3092 0024 0FD2     		bcs	.L172
2095:../FreeRTOS/Source/tasks.c **** 	{
2096:../FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3093              		.loc 1 2097 0
 3094 0026 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3095 002a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3096 002e 1A68     		ldr	r2, [r3]
 3097 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3098 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3099 0038 1B68     		ldr	r3, [r3]
 3100 003a 0433     		adds	r3, r3, #4
 3101 003c 1046     		mov	r0, r2
 3102 003e 1946     		mov	r1, r3
 3103 0040 FFF7FEFF 		bl	vListInsert
 3104 0044 1CE0     		b	.L171
 3105              	.L172:
2098:../FreeRTOS/Source/tasks.c **** 	}
2099:../FreeRTOS/Source/tasks.c **** 	else
2100:../FreeRTOS/Source/tasks.c **** 	{
2101:../FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2102:../FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3106              		.loc 1 2102 0
 3107 0046 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3108 004a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3109 004e 1A68     		ldr	r2, [r3]
 3110 0050 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3111 0054 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3112 0058 1B68     		ldr	r3, [r3]
 3113 005a 0433     		adds	r3, r3, #4
 3114 005c 1046     		mov	r0, r2
 3115 005e 1946     		mov	r1, r3
 3116 0060 FFF7FEFF 		bl	vListInsert
2103:../FreeRTOS/Source/tasks.c **** 
2104:../FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2105:../FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:../FreeRTOS/Source/tasks.c **** 		too. */
2107:../FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3117              		.loc 1 2107 0
 3118 0064 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3119 0068 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3120 006c 1B68     		ldr	r3, [r3]
 3121 006e 7A68     		ldr	r2, [r7, #4]
 3122 0070 9A42     		cmp	r2, r3
 3123 0072 05D2     		bcs	.L171
2108:../FreeRTOS/Source/tasks.c **** 		{
2109:../FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3124              		.loc 1 2109 0
 3125 0074 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3126 0078 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3127 007c 7A68     		ldr	r2, [r7, #4]
 3128 007e 1A60     		str	r2, [r3]
 3129              	.L171:
2110:../FreeRTOS/Source/tasks.c **** 		}
2111:../FreeRTOS/Source/tasks.c **** 	}
2112:../FreeRTOS/Source/tasks.c **** }
 3130              		.loc 1 2112 0
 3131 0080 0837     		adds	r7, r7, #8
 3132 0082 BD46     		mov	sp, r7
 3133              		@ sp needed
 3134 0084 80BD     		pop	{r7, pc}
 3135              		.cfi_endproc
 3136              	.LFE29:
 3138 0086 00BF     		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3139              		.align	2
 3140              		.thumb
 3141              		.thumb_func
 3143              	prvAllocateTCBAndStack:
 3144              	.LFB30:
2113:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2114:../FreeRTOS/Source/tasks.c **** 
2115:../FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2116:../FreeRTOS/Source/tasks.c **** {
 3145              		.loc 1 2116 0
 3146              		.cfi_startproc
 3147              		@ args = 0, pretend = 0, frame = 16
 3148              		@ frame_needed = 1, uses_anonymous_args = 0
 3149 0000 80B5     		push	{r7, lr}
 3150              		.cfi_def_cfa_offset 8
 3151              		.cfi_offset 7, -8
 3152              		.cfi_offset 14, -4
 3153 0002 84B0     		sub	sp, sp, #16
 3154              		.cfi_def_cfa_offset 24
 3155 0004 00AF     		add	r7, sp, #0
 3156              		.cfi_def_cfa_register 7
 3157 0006 0346     		mov	r3, r0
 3158 0008 3960     		str	r1, [r7]
 3159 000a FB80     		strh	r3, [r7, #6]	@ movhi
2117:../FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2118:../FreeRTOS/Source/tasks.c **** 
2119:../FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:../FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2121:../FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3160              		.loc 1 2121 0
 3161 000c 4420     		movs	r0, #68
 3162 000e FFF7FEFF 		bl	pvPortMalloc
 3163 0012 F860     		str	r0, [r7, #12]
2122:../FreeRTOS/Source/tasks.c **** 
2123:../FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3164              		.loc 1 2123 0
 3165 0014 FB68     		ldr	r3, [r7, #12]
 3166 0016 002B     		cmp	r3, #0
 3167 0018 1FD0     		beq	.L175
2124:../FreeRTOS/Source/tasks.c **** 	{
2125:../FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2126:../FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2127:../FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2128:../FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3168              		.loc 1 2128 0
 3169 001a 3B68     		ldr	r3, [r7]
 3170 001c 002B     		cmp	r3, #0
 3171 001e 06D1     		bne	.L176
 3172              		.loc 1 2128 0 is_stmt 0 discriminator 1
 3173 0020 FB88     		ldrh	r3, [r7, #6]
 3174 0022 9B00     		lsls	r3, r3, #2
 3175 0024 1846     		mov	r0, r3
 3176 0026 FFF7FEFF 		bl	pvPortMalloc
 3177 002a 0346     		mov	r3, r0
 3178 002c 00E0     		b	.L177
 3179              	.L176:
 3180              		.loc 1 2128 0 discriminator 2
 3181 002e 3B68     		ldr	r3, [r7]
 3182              	.L177:
 3183              		.loc 1 2128 0 discriminator 3
 3184 0030 FA68     		ldr	r2, [r7, #12]
 3185 0032 1363     		str	r3, [r2, #48]
2129:../FreeRTOS/Source/tasks.c **** 
2130:../FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3186              		.loc 1 2130 0 is_stmt 1 discriminator 3
 3187 0034 FB68     		ldr	r3, [r7, #12]
 3188 0036 1B6B     		ldr	r3, [r3, #48]
 3189 0038 002B     		cmp	r3, #0
 3190 003a 05D1     		bne	.L178
2131:../FreeRTOS/Source/tasks.c **** 		{
2132:../FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:../FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3191              		.loc 1 2133 0
 3192 003c F868     		ldr	r0, [r7, #12]
 3193 003e FFF7FEFF 		bl	vPortFree
2134:../FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3194              		.loc 1 2134 0
 3195 0042 0023     		movs	r3, #0
 3196 0044 FB60     		str	r3, [r7, #12]
 3197 0046 08E0     		b	.L175
 3198              	.L178:
2135:../FreeRTOS/Source/tasks.c **** 		}
2136:../FreeRTOS/Source/tasks.c **** 		else
2137:../FreeRTOS/Source/tasks.c **** 		{
2138:../FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2139:../FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3199              		.loc 1 2139 0
 3200 0048 FB68     		ldr	r3, [r7, #12]
 3201 004a 1A6B     		ldr	r2, [r3, #48]
 3202 004c FB88     		ldrh	r3, [r7, #6]
 3203 004e 9B00     		lsls	r3, r3, #2
 3204 0050 1046     		mov	r0, r2
 3205 0052 A521     		movs	r1, #165
 3206 0054 1A46     		mov	r2, r3
 3207 0056 FFF7FEFF 		bl	memset
 3208              	.L175:
2140:../FreeRTOS/Source/tasks.c **** 		}
2141:../FreeRTOS/Source/tasks.c **** 	}
2142:../FreeRTOS/Source/tasks.c **** 
2143:../FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3209              		.loc 1 2143 0
 3210 005a FB68     		ldr	r3, [r7, #12]
2144:../FreeRTOS/Source/tasks.c **** }
 3211              		.loc 1 2144 0
 3212 005c 1846     		mov	r0, r3
 3213 005e 1037     		adds	r7, r7, #16
 3214 0060 BD46     		mov	sp, r7
 3215              		@ sp needed
 3216 0062 80BD     		pop	{r7, pc}
 3217              		.cfi_endproc
 3218              	.LFE30:
 3220              		.section	.text.prvDeleteTCB,"ax",%progbits
 3221              		.align	2
 3222              		.thumb
 3223              		.thumb_func
 3225              	prvDeleteTCB:
 3226              	.LFB31:
2145:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2146:../FreeRTOS/Source/tasks.c **** 
2147:../FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2148:../FreeRTOS/Source/tasks.c **** 
2149:../FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2150:../FreeRTOS/Source/tasks.c **** 	{
2151:../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:../FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2153:../FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:../FreeRTOS/Source/tasks.c **** 
2155:../FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2156:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2157:../FreeRTOS/Source/tasks.c **** 		do
2158:../FreeRTOS/Source/tasks.c **** 		{
2159:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2160:../FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2161:../FreeRTOS/Source/tasks.c **** 			{
2162:../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:../FreeRTOS/Source/tasks.c **** 			}
2164:../FreeRTOS/Source/tasks.c **** 			#else
2165:../FreeRTOS/Source/tasks.c **** 			{
2166:../FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2167:../FreeRTOS/Source/tasks.c **** 			}
2168:../FreeRTOS/Source/tasks.c **** 			#endif			
2169:../FreeRTOS/Source/tasks.c **** 			
2170:../FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2171:../FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2172:../FreeRTOS/Source/tasks.c **** 
2173:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2174:../FreeRTOS/Source/tasks.c **** 	}
2175:../FreeRTOS/Source/tasks.c **** 
2176:../FreeRTOS/Source/tasks.c **** #endif
2177:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2178:../FreeRTOS/Source/tasks.c **** 
2179:../FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:../FreeRTOS/Source/tasks.c **** 
2181:../FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2182:../FreeRTOS/Source/tasks.c **** 	{
2183:../FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:../FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2185:../FreeRTOS/Source/tasks.c **** 
2186:../FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:../FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2188:../FreeRTOS/Source/tasks.c **** 		do
2189:../FreeRTOS/Source/tasks.c **** 		{
2190:../FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2191:../FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2192:../FreeRTOS/Source/tasks.c **** 
2193:../FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2194:../FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2195:../FreeRTOS/Source/tasks.c **** 			{
2196:../FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2197:../FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2198:../FreeRTOS/Source/tasks.c **** 				{
2199:../FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2200:../FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2201:../FreeRTOS/Source/tasks.c **** 				}
2202:../FreeRTOS/Source/tasks.c **** 				else
2203:../FreeRTOS/Source/tasks.c **** 				{
2204:../FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2205:../FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2206:../FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2207:../FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2208:../FreeRTOS/Source/tasks.c **** 
2209:../FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2210:../FreeRTOS/Source/tasks.c **** 					{
2211:../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:../FreeRTOS/Source/tasks.c **** 						{
2213:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2214:../FreeRTOS/Source/tasks.c **** 						}
2215:../FreeRTOS/Source/tasks.c **** 						#else
2216:../FreeRTOS/Source/tasks.c **** 						{
2217:../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2218:../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2219:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2220:../FreeRTOS/Source/tasks.c **** 						}
2221:../FreeRTOS/Source/tasks.c **** 						#endif
2222:../FreeRTOS/Source/tasks.c **** 					}
2223:../FreeRTOS/Source/tasks.c **** 					else
2224:../FreeRTOS/Source/tasks.c **** 					{
2225:../FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2226:../FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2227:../FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:../FreeRTOS/Source/tasks.c **** 						{
2229:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2230:../FreeRTOS/Source/tasks.c **** 						}
2231:../FreeRTOS/Source/tasks.c **** 						#else
2232:../FreeRTOS/Source/tasks.c **** 						{
2233:../FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2234:../FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2235:../FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2236:../FreeRTOS/Source/tasks.c **** 						}
2237:../FreeRTOS/Source/tasks.c **** 						#endif
2238:../FreeRTOS/Source/tasks.c **** 					}
2239:../FreeRTOS/Source/tasks.c **** 				}
2240:../FreeRTOS/Source/tasks.c **** 
2241:../FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2242:../FreeRTOS/Source/tasks.c **** 			}
2243:../FreeRTOS/Source/tasks.c **** 
2244:../FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2245:../FreeRTOS/Source/tasks.c **** 	}
2246:../FreeRTOS/Source/tasks.c **** 
2247:../FreeRTOS/Source/tasks.c **** #endif
2248:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2249:../FreeRTOS/Source/tasks.c **** 
2250:../FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:../FreeRTOS/Source/tasks.c **** 
2252:../FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:../FreeRTOS/Source/tasks.c **** 	{
2254:../FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
2255:../FreeRTOS/Source/tasks.c **** 
2256:../FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2257:../FreeRTOS/Source/tasks.c **** 		{
2258:../FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2259:../FreeRTOS/Source/tasks.c **** 			usCount++;
2260:../FreeRTOS/Source/tasks.c **** 		}
2261:../FreeRTOS/Source/tasks.c **** 
2262:../FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2263:../FreeRTOS/Source/tasks.c **** 
2264:../FreeRTOS/Source/tasks.c **** 		return usCount;
2265:../FreeRTOS/Source/tasks.c **** 	}
2266:../FreeRTOS/Source/tasks.c **** 
2267:../FreeRTOS/Source/tasks.c **** #endif
2268:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2269:../FreeRTOS/Source/tasks.c **** 
2270:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:../FreeRTOS/Source/tasks.c **** 
2272:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:../FreeRTOS/Source/tasks.c **** 	{
2274:../FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2275:../FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2276:../FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2277:../FreeRTOS/Source/tasks.c **** 
2278:../FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2279:../FreeRTOS/Source/tasks.c **** 
2280:../FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2281:../FreeRTOS/Source/tasks.c **** 		{
2282:../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2283:../FreeRTOS/Source/tasks.c **** 		}
2284:../FreeRTOS/Source/tasks.c **** 		#else
2285:../FreeRTOS/Source/tasks.c **** 		{
2286:../FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:../FreeRTOS/Source/tasks.c **** 		}
2288:../FreeRTOS/Source/tasks.c **** 		#endif
2289:../FreeRTOS/Source/tasks.c **** 
2290:../FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2291:../FreeRTOS/Source/tasks.c **** 
2292:../FreeRTOS/Source/tasks.c **** 		return uxReturn;
2293:../FreeRTOS/Source/tasks.c **** 	}
2294:../FreeRTOS/Source/tasks.c **** 
2295:../FreeRTOS/Source/tasks.c **** #endif
2296:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:../FreeRTOS/Source/tasks.c **** 
2298:../FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2299:../FreeRTOS/Source/tasks.c **** 
2300:../FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2301:../FreeRTOS/Source/tasks.c **** 	{
 3227              		.loc 1 2301 0
 3228              		.cfi_startproc
 3229              		@ args = 0, pretend = 0, frame = 8
 3230              		@ frame_needed = 1, uses_anonymous_args = 0
 3231 0000 80B5     		push	{r7, lr}
 3232              		.cfi_def_cfa_offset 8
 3233              		.cfi_offset 7, -8
 3234              		.cfi_offset 14, -4
 3235 0002 82B0     		sub	sp, sp, #8
 3236              		.cfi_def_cfa_offset 16
 3237 0004 00AF     		add	r7, sp, #0
 3238              		.cfi_def_cfa_register 7
 3239 0006 7860     		str	r0, [r7, #4]
2302:../FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2303:../FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls. */
2304:../FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2305:../FreeRTOS/Source/tasks.c **** 
2306:../FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:../FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2308:../FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3240              		.loc 1 2308 0
 3241 0008 7B68     		ldr	r3, [r7, #4]
 3242 000a 1B6B     		ldr	r3, [r3, #48]
 3243 000c 1846     		mov	r0, r3
 3244 000e FFF7FEFF 		bl	vPortFree
2309:../FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 3245              		.loc 1 2309 0
 3246 0012 7868     		ldr	r0, [r7, #4]
 3247 0014 FFF7FEFF 		bl	vPortFree
2310:../FreeRTOS/Source/tasks.c **** 	}
 3248              		.loc 1 2310 0
 3249 0018 0837     		adds	r7, r7, #8
 3250 001a BD46     		mov	sp, r7
 3251              		@ sp needed
 3252 001c 80BD     		pop	{r7, pc}
 3253              		.cfi_endproc
 3254              	.LFE31:
 3256 001e 00BF     		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3257              		.align	2
 3258              		.global	xTaskGetCurrentTaskHandle
 3259              		.thumb
 3260              		.thumb_func
 3262              	xTaskGetCurrentTaskHandle:
 3263              	.LFB32:
2311:../FreeRTOS/Source/tasks.c **** 
2312:../FreeRTOS/Source/tasks.c **** #endif
2313:../FreeRTOS/Source/tasks.c **** 
2314:../FreeRTOS/Source/tasks.c **** 
2315:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2316:../FreeRTOS/Source/tasks.c **** 
2317:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:../FreeRTOS/Source/tasks.c **** 
2319:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:../FreeRTOS/Source/tasks.c **** 	{
 3264              		.loc 1 2320 0
 3265              		.cfi_startproc
 3266              		@ args = 0, pretend = 0, frame = 8
 3267              		@ frame_needed = 1, uses_anonymous_args = 0
 3268              		@ link register save eliminated.
 3269 0000 80B4     		push	{r7}
 3270              		.cfi_def_cfa_offset 4
 3271              		.cfi_offset 7, -4
 3272 0002 83B0     		sub	sp, sp, #12
 3273              		.cfi_def_cfa_offset 16
 3274 0004 00AF     		add	r7, sp, #0
 3275              		.cfi_def_cfa_register 7
2321:../FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2322:../FreeRTOS/Source/tasks.c **** 
2323:../FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2324:../FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2325:../FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2326:../FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3276              		.loc 1 2326 0
 3277 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3278 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3279 000e 1B68     		ldr	r3, [r3]
 3280 0010 7B60     		str	r3, [r7, #4]
2327:../FreeRTOS/Source/tasks.c **** 
2328:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 3281              		.loc 1 2328 0
 3282 0012 7B68     		ldr	r3, [r7, #4]
2329:../FreeRTOS/Source/tasks.c **** 	}
 3283              		.loc 1 2329 0
 3284 0014 1846     		mov	r0, r3
 3285 0016 0C37     		adds	r7, r7, #12
 3286 0018 BD46     		mov	sp, r7
 3287              		@ sp needed
 3288 001a 5DF8047B 		ldr	r7, [sp], #4
 3289 001e 7047     		bx	lr
 3290              		.cfi_endproc
 3291              	.LFE32:
 3293              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3294              		.align	2
 3295              		.global	xTaskGetSchedulerState
 3296              		.thumb
 3297              		.thumb_func
 3299              	xTaskGetSchedulerState:
 3300              	.LFB33:
2330:../FreeRTOS/Source/tasks.c **** 
2331:../FreeRTOS/Source/tasks.c **** #endif
2332:../FreeRTOS/Source/tasks.c **** 
2333:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2334:../FreeRTOS/Source/tasks.c **** 
2335:../FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:../FreeRTOS/Source/tasks.c **** 
2337:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2338:../FreeRTOS/Source/tasks.c **** 	{
 3301              		.loc 1 2338 0
 3302              		.cfi_startproc
 3303              		@ args = 0, pretend = 0, frame = 8
 3304              		@ frame_needed = 1, uses_anonymous_args = 0
 3305              		@ link register save eliminated.
 3306 0000 80B4     		push	{r7}
 3307              		.cfi_def_cfa_offset 4
 3308              		.cfi_offset 7, -4
 3309 0002 83B0     		sub	sp, sp, #12
 3310              		.cfi_def_cfa_offset 16
 3311 0004 00AF     		add	r7, sp, #0
 3312              		.cfi_def_cfa_register 7
2339:../FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2340:../FreeRTOS/Source/tasks.c **** 
2341:../FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3313              		.loc 1 2341 0
 3314 0006 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 3315 000a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 3316 000e 1B68     		ldr	r3, [r3]
 3317 0010 002B     		cmp	r3, #0
 3318 0012 02D1     		bne	.L184
2342:../FreeRTOS/Source/tasks.c **** 		{
2343:../FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3319              		.loc 1 2343 0
 3320 0014 0023     		movs	r3, #0
 3321 0016 7B60     		str	r3, [r7, #4]
 3322 0018 0BE0     		b	.L185
 3323              	.L184:
2344:../FreeRTOS/Source/tasks.c **** 		}
2345:../FreeRTOS/Source/tasks.c **** 		else
2346:../FreeRTOS/Source/tasks.c **** 		{
2347:../FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3324              		.loc 1 2347 0
 3325 001a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 3326 001e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 3327 0022 1B68     		ldr	r3, [r3]
 3328 0024 002B     		cmp	r3, #0
 3329 0026 02D1     		bne	.L186
2348:../FreeRTOS/Source/tasks.c **** 			{
2349:../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3330              		.loc 1 2349 0
 3331 0028 0123     		movs	r3, #1
 3332 002a 7B60     		str	r3, [r7, #4]
 3333 002c 01E0     		b	.L185
 3334              	.L186:
2350:../FreeRTOS/Source/tasks.c **** 			}
2351:../FreeRTOS/Source/tasks.c **** 			else
2352:../FreeRTOS/Source/tasks.c **** 			{
2353:../FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3335              		.loc 1 2353 0
 3336 002e 0223     		movs	r3, #2
 3337 0030 7B60     		str	r3, [r7, #4]
 3338              	.L185:
2354:../FreeRTOS/Source/tasks.c **** 			}
2355:../FreeRTOS/Source/tasks.c **** 		}
2356:../FreeRTOS/Source/tasks.c **** 
2357:../FreeRTOS/Source/tasks.c **** 		return xReturn;
 3339              		.loc 1 2357 0
 3340 0032 7B68     		ldr	r3, [r7, #4]
2358:../FreeRTOS/Source/tasks.c **** 	}
 3341              		.loc 1 2358 0
 3342 0034 1846     		mov	r0, r3
 3343 0036 0C37     		adds	r7, r7, #12
 3344 0038 BD46     		mov	sp, r7
 3345              		@ sp needed
 3346 003a 5DF8047B 		ldr	r7, [sp], #4
 3347 003e 7047     		bx	lr
 3348              		.cfi_endproc
 3349              	.LFE33:
 3351              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3352              		.align	2
 3353              		.global	vTaskPriorityInherit
 3354              		.thumb
 3355              		.thumb_func
 3357              	vTaskPriorityInherit:
 3358              	.LFB34:
2359:../FreeRTOS/Source/tasks.c **** 
2360:../FreeRTOS/Source/tasks.c **** #endif
2361:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2362:../FreeRTOS/Source/tasks.c **** 
2363:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2364:../FreeRTOS/Source/tasks.c **** 
2365:../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:../FreeRTOS/Source/tasks.c **** 	{
 3359              		.loc 1 2366 0
 3360              		.cfi_startproc
 3361              		@ args = 0, pretend = 0, frame = 16
 3362              		@ frame_needed = 1, uses_anonymous_args = 0
 3363 0000 80B5     		push	{r7, lr}
 3364              		.cfi_def_cfa_offset 8
 3365              		.cfi_offset 7, -8
 3366              		.cfi_offset 14, -4
 3367 0002 84B0     		sub	sp, sp, #16
 3368              		.cfi_def_cfa_offset 24
 3369 0004 00AF     		add	r7, sp, #0
 3370              		.cfi_def_cfa_register 7
 3371 0006 7860     		str	r0, [r7, #4]
2367:../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3372              		.loc 1 2367 0
 3373 0008 7B68     		ldr	r3, [r7, #4]
 3374 000a FB60     		str	r3, [r7, #12]
2368:../FreeRTOS/Source/tasks.c **** 
2369:../FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
 3375              		.loc 1 2369 0
 3376 000c 7B68     		ldr	r3, [r7, #4]
 3377 000e 002B     		cmp	r3, #0
 3378 0010 04D1     		bne	.L189
 3379              		.loc 1 2369 0 is_stmt 0 discriminator 1
 3380              	@ 2369 "../FreeRTOS/Source/tasks.c" 1
 3381 0012 4FF05000 			mov r0, #80								
 3382 0016 80F31188 		msr basepri, r0							
 3383              	
 3384              	@ 0 "" 2
 3385              		.thumb
 3386              	.L190:
 3387 001a FEE7     		b	.L190
 3388              	.L189:
2370:../FreeRTOS/Source/tasks.c **** 
2371:../FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3389              		.loc 1 2371 0 is_stmt 1
 3390 001c FB68     		ldr	r3, [r7, #12]
 3391 001e DA6A     		ldr	r2, [r3, #44]
 3392 0020 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3393 0024 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3394 0028 1B68     		ldr	r3, [r3]
 3395 002a DB6A     		ldr	r3, [r3, #44]
 3396 002c 9A42     		cmp	r2, r3
 3397 002e 4FD2     		bcs	.L188
2372:../FreeRTOS/Source/tasks.c **** 		{
2373:../FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2374:../FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3398              		.loc 1 2374 0
 3399 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3400 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3401 0038 1B68     		ldr	r3, [r3]
 3402 003a DB6A     		ldr	r3, [r3, #44]
 3403 003c C3F10502 		rsb	r2, r3, #5
 3404 0040 FB68     		ldr	r3, [r7, #12]
 3405 0042 9A61     		str	r2, [r3, #24]
2375:../FreeRTOS/Source/tasks.c **** 
2376:../FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2377:../FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2378:../FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3406              		.loc 1 2378 0
 3407 0044 FB68     		ldr	r3, [r7, #12]
 3408 0046 5969     		ldr	r1, [r3, #20]
 3409 0048 FB68     		ldr	r3, [r7, #12]
 3410 004a DA6A     		ldr	r2, [r3, #44]
 3411 004c 1346     		mov	r3, r2
 3412 004e 9B00     		lsls	r3, r3, #2
 3413 0050 1344     		add	r3, r3, r2
 3414 0052 9B00     		lsls	r3, r3, #2
 3415 0054 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3416 0058 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3417 005c 1344     		add	r3, r3, r2
 3418 005e 9942     		cmp	r1, r3
 3419 0060 2ED1     		bne	.L192
2379:../FreeRTOS/Source/tasks.c **** 			{
2380:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3420              		.loc 1 2380 0
 3421 0062 FB68     		ldr	r3, [r7, #12]
 3422 0064 0433     		adds	r3, r3, #4
 3423 0066 1846     		mov	r0, r3
 3424 0068 FFF7FEFF 		bl	vListRemove
2381:../FreeRTOS/Source/tasks.c **** 
2382:../FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2383:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3425              		.loc 1 2383 0
 3426 006c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3427 0070 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3428 0074 1B68     		ldr	r3, [r3]
 3429 0076 DA6A     		ldr	r2, [r3, #44]
 3430 0078 FB68     		ldr	r3, [r7, #12]
 3431 007a DA62     		str	r2, [r3, #44]
2384:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3432              		.loc 1 2384 0
 3433 007c FB68     		ldr	r3, [r7, #12]
 3434 007e DA6A     		ldr	r2, [r3, #44]
 3435 0080 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3436 0084 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3437 0088 1B68     		ldr	r3, [r3]
 3438 008a 9A42     		cmp	r2, r3
 3439 008c 06D9     		bls	.L193
 3440              		.loc 1 2384 0 is_stmt 0 discriminator 1
 3441 008e FB68     		ldr	r3, [r7, #12]
 3442 0090 DA6A     		ldr	r2, [r3, #44]
 3443 0092 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3444 0096 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3445 009a 1A60     		str	r2, [r3]
 3446              	.L193:
 3447              		.loc 1 2384 0 discriminator 2
 3448 009c FB68     		ldr	r3, [r7, #12]
 3449 009e DA6A     		ldr	r2, [r3, #44]
 3450 00a0 1346     		mov	r3, r2
 3451 00a2 9B00     		lsls	r3, r3, #2
 3452 00a4 1344     		add	r3, r3, r2
 3453 00a6 9B00     		lsls	r3, r3, #2
 3454 00a8 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3455 00ac C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3456 00b0 1A44     		add	r2, r2, r3
 3457 00b2 FB68     		ldr	r3, [r7, #12]
 3458 00b4 0433     		adds	r3, r3, #4
 3459 00b6 1046     		mov	r0, r2
 3460 00b8 1946     		mov	r1, r3
 3461 00ba FFF7FEFF 		bl	vListInsertEnd
 3462 00be 07E0     		b	.L188
 3463              	.L192:
2385:../FreeRTOS/Source/tasks.c **** 			}
2386:../FreeRTOS/Source/tasks.c **** 			else
2387:../FreeRTOS/Source/tasks.c **** 			{
2388:../FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2389:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3464              		.loc 1 2389 0 is_stmt 1
 3465 00c0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3466 00c4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3467 00c8 1B68     		ldr	r3, [r3]
 3468 00ca DA6A     		ldr	r2, [r3, #44]
 3469 00cc FB68     		ldr	r3, [r7, #12]
 3470 00ce DA62     		str	r2, [r3, #44]
 3471              	.L188:
2390:../FreeRTOS/Source/tasks.c **** 			}
2391:../FreeRTOS/Source/tasks.c **** 
2392:../FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:../FreeRTOS/Source/tasks.c **** 		}
2394:../FreeRTOS/Source/tasks.c **** 	}
 3472              		.loc 1 2394 0
 3473 00d0 1037     		adds	r7, r7, #16
 3474 00d2 BD46     		mov	sp, r7
 3475              		@ sp needed
 3476 00d4 80BD     		pop	{r7, pc}
 3477              		.cfi_endproc
 3478              	.LFE34:
 3480 00d6 00BF     		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3481              		.align	2
 3482              		.global	vTaskPriorityDisinherit
 3483              		.thumb
 3484              		.thumb_func
 3486              	vTaskPriorityDisinherit:
 3487              	.LFB35:
2395:../FreeRTOS/Source/tasks.c **** 
2396:../FreeRTOS/Source/tasks.c **** #endif
2397:../FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2398:../FreeRTOS/Source/tasks.c **** 
2399:../FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2400:../FreeRTOS/Source/tasks.c **** 
2401:../FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:../FreeRTOS/Source/tasks.c **** 	{
 3488              		.loc 1 2402 0
 3489              		.cfi_startproc
 3490              		@ args = 0, pretend = 0, frame = 16
 3491              		@ frame_needed = 1, uses_anonymous_args = 0
 3492 0000 80B5     		push	{r7, lr}
 3493              		.cfi_def_cfa_offset 8
 3494              		.cfi_offset 7, -8
 3495              		.cfi_offset 14, -4
 3496 0002 84B0     		sub	sp, sp, #16
 3497              		.cfi_def_cfa_offset 24
 3498 0004 00AF     		add	r7, sp, #0
 3499              		.cfi_def_cfa_register 7
 3500 0006 7860     		str	r0, [r7, #4]
2403:../FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3501              		.loc 1 2403 0
 3502 0008 7B68     		ldr	r3, [r7, #4]
 3503 000a FB60     		str	r3, [r7, #12]
2404:../FreeRTOS/Source/tasks.c **** 
2405:../FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3504              		.loc 1 2405 0
 3505 000c 7B68     		ldr	r3, [r7, #4]
 3506 000e 002B     		cmp	r3, #0
 3507 0010 35D0     		beq	.L194
2406:../FreeRTOS/Source/tasks.c **** 		{
2407:../FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3508              		.loc 1 2407 0
 3509 0012 FB68     		ldr	r3, [r7, #12]
 3510 0014 DA6A     		ldr	r2, [r3, #44]
 3511 0016 FB68     		ldr	r3, [r7, #12]
 3512 0018 1B6C     		ldr	r3, [r3, #64]
 3513 001a 9A42     		cmp	r2, r3
 3514 001c 2FD0     		beq	.L194
2408:../FreeRTOS/Source/tasks.c **** 			{
2409:../FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2410:../FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2411:../FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3515              		.loc 1 2411 0
 3516 001e FB68     		ldr	r3, [r7, #12]
 3517 0020 0433     		adds	r3, r3, #4
 3518 0022 1846     		mov	r0, r3
 3519 0024 FFF7FEFF 		bl	vListRemove
2412:../FreeRTOS/Source/tasks.c **** 
2413:../FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2414:../FreeRTOS/Source/tasks.c **** 				ready list. */
2415:../FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:../FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3520              		.loc 1 2416 0
 3521 0028 FB68     		ldr	r3, [r7, #12]
 3522 002a 1A6C     		ldr	r2, [r3, #64]
 3523 002c FB68     		ldr	r3, [r7, #12]
 3524 002e DA62     		str	r2, [r3, #44]
2417:../FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3525              		.loc 1 2417 0
 3526 0030 FB68     		ldr	r3, [r7, #12]
 3527 0032 DB6A     		ldr	r3, [r3, #44]
 3528 0034 C3F10502 		rsb	r2, r3, #5
 3529 0038 FB68     		ldr	r3, [r7, #12]
 3530 003a 9A61     		str	r2, [r3, #24]
2418:../FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3531              		.loc 1 2418 0
 3532 003c FB68     		ldr	r3, [r7, #12]
 3533 003e DA6A     		ldr	r2, [r3, #44]
 3534 0040 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3535 0044 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3536 0048 1B68     		ldr	r3, [r3]
 3537 004a 9A42     		cmp	r2, r3
 3538 004c 06D9     		bls	.L196
 3539              		.loc 1 2418 0 is_stmt 0 discriminator 1
 3540 004e FB68     		ldr	r3, [r7, #12]
 3541 0050 DA6A     		ldr	r2, [r3, #44]
 3542 0052 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3543 0056 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3544 005a 1A60     		str	r2, [r3]
 3545              	.L196:
 3546              		.loc 1 2418 0 discriminator 2
 3547 005c FB68     		ldr	r3, [r7, #12]
 3548 005e DA6A     		ldr	r2, [r3, #44]
 3549 0060 1346     		mov	r3, r2
 3550 0062 9B00     		lsls	r3, r3, #2
 3551 0064 1344     		add	r3, r3, r2
 3552 0066 9B00     		lsls	r3, r3, #2
 3553 0068 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3554 006c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3555 0070 1A44     		add	r2, r2, r3
 3556 0072 FB68     		ldr	r3, [r7, #12]
 3557 0074 0433     		adds	r3, r3, #4
 3558 0076 1046     		mov	r0, r2
 3559 0078 1946     		mov	r1, r3
 3560 007a FFF7FEFF 		bl	vListInsertEnd
 3561              	.L194:
2419:../FreeRTOS/Source/tasks.c **** 			}
2420:../FreeRTOS/Source/tasks.c **** 		}
2421:../FreeRTOS/Source/tasks.c **** 	}
 3562              		.loc 1 2421 0 is_stmt 1
 3563 007e 1037     		adds	r7, r7, #16
 3564 0080 BD46     		mov	sp, r7
 3565              		@ sp needed
 3566 0082 80BD     		pop	{r7, pc}
 3567              		.cfi_endproc
 3568              	.LFE35:
 3570              		.text
 3571              	.Letext0:
 3572              		.file 2 "c:\\tools\\lib\\gcc\\arm-none-eabi\\4.8.1\\include\\stddef.h"
 3573              		.file 3 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeRTOS\\Source\\include/projdefs.h"
 3574              		.file 4 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeRTOS\\Source\\portable\\GCC\\ARM_CM3/por
 3575              		.file 5 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeRTOS\\Source\\include/list.h"
 3576              		.file 6 "D:\\pall\\workspace\\Snack_stm32_drv_modbus\\FreeRTOS\\Source\\include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:23     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:20     .bss.pxCurrentTCB:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:26     .bss.pxReadyTasksLists:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:29     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:32     .bss.xDelayedTaskList1:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:35     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:38     .bss.xDelayedTaskList2:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:41     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:44     .bss.pxDelayedTaskList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:47     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:50     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:53     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:56     .bss.xPendingReadyList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:59     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:62     .bss.xTasksWaitingTermination:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:65     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:68     .bss.uxTasksDeleted:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:71     .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:74     .bss.xSuspendedTaskList:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:77     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:80     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:83     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:86     .bss.xTickCount:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:89     .bss.xTickCount:00000000 xTickCount
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:92     .bss.uxTopUsedPriority:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:95     .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:98     .bss.uxTopReadyPriority:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:101    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:104    .bss.xSchedulerRunning:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:107    .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:110    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:113    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:116    .bss.uxMissedTicks:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:119    .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:122    .bss.xMissedYield:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:125    .bss.xMissedYield:00000000 xMissedYield
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:128    .bss.xNumOfOverflows:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:131    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:134    .bss.uxTCBNumber:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:137    .bss.uxTCBNumber:00000000 uxTCBNumber
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:140    .data.xNextTaskUnblockTime:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:143    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:146    .text.xTaskGenericCreate:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:151    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3143   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2810   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2891   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:428    .text.vTaskDelete:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:433    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:539    .text.vTaskDelayUntil:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:544    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1576   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3065   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1610   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:681    .text.vTaskDelay:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:686    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:747    .text.uxTaskPriorityGet:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:752    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:802    .text.vTaskPrioritySet:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:807    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:995    .text.vTaskSuspend:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1000   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2152   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1110   .text.xTaskIsTaskSuspended:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1115   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1186   .text.vTaskResume:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1191   .text.vTaskResume:00000000 vTaskResume
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1301   .text.xTaskResumeFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1306   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1439   .rodata:00000000 $d
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1440   .rodata:00000000 .LC0
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1443   .text.vTaskStartScheduler:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1448   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2772   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1534   .text.vTaskEndScheduler:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1539   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1571   .text.vTaskSuspendAll:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1605   .text.xTaskResumeAll:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1926   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1797   .text.xTaskGetTickCount:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1802   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1837   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1842   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1890   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1895   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:1921   .text.vTaskIncrementTick:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2147   .text.vTaskSwitchContext:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2271   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2276   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2356   .text.vTaskPlaceOnEventListRestricted:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2361   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2425   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2430   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2550   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2555   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2606   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2611   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2737   .text.vTaskMissedYield:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2742   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2768   .text.prvIdleTask:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2975   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2806   .text.prvInitialiseTCBVariables:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2887   .text.prvInitialiseTaskLists:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:2971   .text.prvCheckTasksWaitingTermination:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3225   .text.prvDeleteTCB:00000000 prvDeleteTCB
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3061   .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3139   .text.prvAllocateTCBAndStack:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3221   .text.prvDeleteTCB:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3257   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3262   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3294   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3299   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3352   .text.vTaskPriorityInherit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3357   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3481   .text.vTaskPriorityDisinherit:00000000 $t
C:\Users\Alex\AppData\Local\Temp\cc0ONjGu.s:3486   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.98ffea2db242cfdb58f411f7407f2b59
                           .group:00000000 wm4.newlib.h.8.384a112feabb3bef7b573ae48cde2e3b
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4.config.h.183.aa62afef667fb61d15fa64c48beb2f14
                           .group:00000000 wm4._ansi.h.23.5644b60c990a4800b02a6e654e88f93a
                           .group:00000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:00000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.59.db8450f33c1f6150c0372fa1091a887a
                           .group:00000000 wm4.stddef.h.348.9a99de77b6ba3b4278b57e9cc6d6e349
                           .group:00000000 wm4.reent.h.16.567d760e6ae9ad7f917851a308bd7a57
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.5759fe41f87f5211a5952dfb1fc64f19
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.64.f9f1bb6b0d3d7e12f6a27968d859709c
                           .group:00000000 wm4.stdlib.h.18.8bab2fb43ac4e90235390733c30a4530
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.55.7091a050e07f1c4abd225630fe3d62f1
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.cdefs.h.56.efab90f4d89fbc41d6b3a5c5fb0d3d0f
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:00000000 wm4.FreeRTOSConfig.h.64.0af6644bda3c4312e69b231c06f0909a
                           .group:00000000 wm4.portmacro.h.56.a47bdd86bc36d334ca6056492e2d709f
                           .group:00000000 wm4.portable.h.311.02653c2286cc0addcb8e7b32211fdde5
                           .group:00000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:00000000 wm4.FreeRTOS.h.132.e7bb8eabd42aedb15fb3c1f00c9886e6
                           .group:00000000 wm4.list.h.84.e713c47e239b06424d7c93968625e34d
                           .group:00000000 wm4.task.h.73.4db227e33e5981749a1e912949d705ee
                           .group:00000000 wm4.timers.h.73.68db9af5780c070cb7dae421a5220129
                           .group:00000000 wm4.StackMacros.h.55.6d32da70bba937a3f8476e3b9d518421

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
